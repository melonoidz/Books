# A PHILOSPOPHY OF SOFTWARE DESIGN 
- Software開発について

# 本の構成

1. Introduction
 - 1.1 How to use this book

2. The Nature of Complexity
 - 2.1 Complexiy defined
 - 2.2 Symptoms of complexity
 - 2.3 Causes of complexity
 - 2.4 Complexity is incremental
 - 2.5 Conclusion

3. Working Code isn't enough
 - 3.1 Tactical programming
 - 3.2 Strategic programming
 - 3.3 How much to invest?
 - 3.4 Startups and investment
 - 3.5 Conclusion

4. Modules Should Be Deep
 - 4.1 Modular design
 - 4.2 What's in an interface?
 - 4.3 Abstractions
 - 4.4 Deep modules
 - 4.5 Shallow modules
 - 4.6 Classitis
 - 4.7 Examples: Java and Unix I/O
 - 4.8 Conclusion

5. Information Hiding (and Leakage)
 - 5.1 Information hiding
 - 5.2 Information leakage
 - 5.3 Temporal decomposition
 - 5.4 Example: HTTP server
 - 5.5 Example: too many classes
 - 5.6 Example: HTTP parameter handling
 - 5.7 Example: defaults in HTTP responses
 - 5.8 Information hiding within a class
 - 5.9 Taking it too far
 - 5.10 Conclusion

6. General-Purpose Modules are Deeper
 - 6.1 Make classes somewhat general-purpose
 - 6.2 Example: storing text for an editor
 - 6.3 A more general-purpose API
 - 6.4 Generality leads to better information hiding
 - 6.5 Questions to ask yourself
 - 6.6 Push specialization upwards (and downwards)
 - 6.7 Example: editor undo mechanism
 - 6.8 Eliminate special cases in code
 - 6.9 Conclusion

7. Different Layor, Different Abstraction
 - 7.1 Pass-through methods
 - 7.2 When in interface duplication OK?
 - 7.3 Decorators
 - 7.4 Interface versus implementation

8. Pull Complexity Downwards
 - 8.1 Example: editor text class
 - 8.2 Example: configuration parameters
 - 8.3 Taking it too far
 - 8.4 Conclusion

9. Better Together Or Better Apart?
 - 9.1 Bring together if information is shared
 - 9.2 Bring together if it will simplify the interface
 - 9.3 Bring together to eliminate duplication
 -  