＃ソフトウェア設計の哲学
-ソフトウェア開発

＃本の

1.はじめに
 -1.1この本の使い方

2.複雑さの性質
 -2.1複雑に定義
 -2.2複雑さの症状
 -2.3複雑さの原因
 -2.4複雑さは段階的
 -2.5結論

3.作業コードだけでは不十分です
 -3.1戦術プログラミング
 -3.2戦略的プログラミング
 --3.3いくら投資しますか？
 -3.4スタートアップと投資
 -3.5結論

4.モジュールは深くする必要があります
 -4.1モジュラー設計
 --4.2インターフェースには何がありますか？
 -4.3抽象化
 -4.4ディープモジュール
 -4.5浅いモジュール
 -4.6分類炎
 -4.7例：JavaおよびUnix I / O
 -4.8結論

5.情報​​の隠蔽（および漏洩）
 -5.1情報隠蔽
 -5.2情報漏えい
 -5.3時間的分解
 -5.4例：HTTPサーバー
 -5.5例：クラスが多すぎます
 -5.6例：HTTPパラメータの処理
 -5.7例：HTTP応答のデフォルト
 -5.8クラス内に隠されている情報
 -5.9行き過ぎ
 -5.10結論

6.汎用モジュールはより深い
 -6.1クラスをやや汎用的にする
 -6.2例：エディター用のテキストの保存
 -6.3より汎用的なAPI
 -6.4一般性はより良い情報隠蔽につながります
 -6.5自分自身に尋ねる質問
 -6.6スペシャライゼーションを上向き（および下向き）にプッシュ
 -6.7例：エディターの元に戻すメカニズム
 -6.8コード内の特殊なケースを排除する
 -6.9結論

7.異なる層、異なる抽象化
 -7.1パススルー方法
 --7.2インターフェースの複製はOKですか？
 -7.3デコレータ
 -7.4インターフェースと実装

8.複雑さを下に引っ張る
 -8.1例：エディタテキストクラス
 -8.2例：構成パラメーター
 -8.3やりすぎ
 -8.4結論

9.一緒に、または離れて、より良いですか？
 -9.1情報が共有されている場合はまとめる
 -9.2インターフェースを簡素化する場合はまとめる
 -9.3重複を排除するためにまとめる
 -9.4汎用と特殊目的の分離
 -9.5例：挿入カーソルと選択
 -9.6例：ロギング用の個別のクラス
 -9.7分割と結合の方法
 -9.8別の意見：クリーンコード
 -9.9結論

10.存在しないエラーを定義する
 -10.1例外が複雑さを増す理由
 -10.2例外が多すぎます
 -10.3存在しないエラーを定義する
 -10.4例：Windowsでのファイルの選択
 -10.5例：Javaサブストリングメソッド
 -10.6マスクの例外
 -10.7例外の集約
 -10.8ただクラッシュしますか？
 -10.9やりすぎ
 -10.10結論

11.それを2回設計する

12.なぜコメントを書くのですか？ 4つの言い訳
 -12.1良いコードは自己文書化です
 -12.2コメントを書く時間がない
 -12.3コメントは古くなり、誤解を招くようになります
 -12.4私が見たすべてのコメントは価値がありません
 -12.5よく書かれたコメントの利点
 -12.6別の意見：コメントは失敗です

13.コメントは、コードから明らかではないことを説明する必要があります
 -13.1選択規則
 -13.2コードを繰り返さないでください
 -13.3下位レベルのコメントは精度を追加します
 -13.4高レベルのコメントは直感を強化します
 -13.5インターフェースのドキュメント
 -13.6実装コメント：方法ではなく、何を、なぜ
 -13.7クロスモジュール設計の決定
 -13.8結論
 -13.9セクション13.5からの質問への回答

14.名前の選択
 -14.1例：悪い名前はバグを引き起こします
 -14.2画像を作成する
 -14.3名前は正確である必要があります
 -14.4一貫して名前を使用する
 -14.5余分な単語を避ける
 -14.6別の意見：Goスタイルガイド
 -14.7結論

15.最初にコメントを書く
 -15.1Deleyedコメントは悪いコメントです
 -15.2最初にコメントを書く
 -15.3コメントは設計ツールです
 -15.4初期のコメントは楽しいコメントです
 -15.5初期のコメントは高価ですか？
 -15.6結論

16.既存のコードの変更
 -16.1戦略を維持する
 -16.2コメントの維持：コメントをコードの近くに置いてください
 -16.3コメントは、コミットログではなく、コードに属します
 -16.4コメントの維持：重複を避ける
 -16.5コメントの維持：相違点を確認してください
 -16.6上位レベルのコメントは保守が容易です

17.一貫性
 -17.1一貫性のあるEcamples
 -17.2一貫性の確保
 -17.3行き過ぎ
 -17.4結論

18.コードは明白でなければなりません
 -18.1コードをより明確にするもの
 -18.2コードをわかりにくくするもの
 -18.3結論

19.ソフトウェアトレッド
 -19.1オブジェクト指向プログラミングと継承
 -19.2アジャイル開発
 -19.3ユニットテスト
 -19.4テスト駆動開発
 -19.5デザインパターン
 -19.6ゲッターとセッター
 -19.7結論

20.パフォーマンスのための設計
 --20.1パフォーマンスについての考え方
 -20.2変更前（および変更後）の測定
 --20.3クリティカルパス周辺の設計
 --20.4例：RAMCloudバッファー
 --20.5結論

21.重要事項を決定する
 --21.1重要なことを決定する方法は？
 --21.2重要なことを最小限に抑える
 --21.3重要なことを強調する方法
 --21.4間違い
 -21.5より広く考える

22.結論