d：\ work \ kindle \ phil \ 101.png@@6.4一般性はより良い情報につながる
隠蔽
汎用アプローチは、よりクリーンなものを提供します
テキストとユーザーインターフェイスの分離
クラス。これにより、情報の隠蔽が向上します。
テキストクラスは、の詳細を認識する必要はありません。
バックスペースキーの種類などのユーザーインターフェイス
処理された;これらの詳細は現在、
ユーザーインターフェイスクラス。新しいユーザーインターフェイス機能
新しいサポートを作成せずに追加できます
テキストクラスの関数。汎用
インターフェイスはまた、認知的負荷を軽減します：開発者
ユーザーインターフェイスでの作業は、学ぶ必要があるだけです
に再利用できるいくつかの簡単な方法
さまざまな目的。

元のバージョンのバックスペースメソッド
テキストクラスは誤った抽象化でした。それは主張した
どのキャラクターについての情報を隠すため
削除されましたが、ユーザーインターフェイスモジュールには本当に必要です
これを知るために;ユーザーインターフェイスの開発者は
バックスペースメソッドのコードを読んで、
その正確な動作を確認します。メソッドを入れる
テキストクラスは、ユーザーインターフェイスを難しくします
開発者は必要な情報を入手できます。の一つ
ソフトウェア設計の最も重要な要素は、isd：\ work \ Kindle \ phil \ 102.png @@誰が、いつ、何を知る必要があるかを決定することです。
詳細が重要な場合は、
それらは明示的で可能な限り明白です。
バックスペース操作の実装を改訂しました。
この情報をインターフェイスの背後に隠すだけ
あいまいさを作成します。

6.5自分自身に尋ねる質問

きれいな汎用を認識しやすい
クラスデザインはそれを作成することよりも。ここにあるいくつかの
あなたが自分自身に尋ねることができる質問、それはあなたを助けるでしょう
汎用間の適切なバランスを見つけるために
インターフェース専用です。

カバーする最も単純なインターフェースは何ですか

私の現在のすべてのニーズ？数を減らすと
全体を減らすことなくAPIのメソッドの
機能、そしてあなたはおそらくより多くを作成しています
汎用メソッド。専用
テキストAPIには、削除するための少なくとも3つのメソッドがありました
テキスト：バックスペース、削除、およびdeleteSelection。 The
より汎用的なAPIには1つのメソッドしかありませんでした
テキストを削除するため。これは3つの目的すべてに役立ちました。
メソッドの数を減らすことは意味があります
個々のメソッドのAPIが残っている限り：\ work \ Kindle \ phil \ 103.png @@ simple;追加の情報をたくさん導入する必要がある場合
の数を減らすための引数
メソッド、それならあなたは本当に単純化していないかもしれません
もの。

この方法はどのような状況で使用されますか？
メソッドが特定の用途向けに設計されている場合、
バックスペースメソッドとして、それはそれが
あまりにも特別な目的かもしれません。交換できるかどうかを確認してください
単一の特別な目的の方法
汎用方式。

このAPIは私の現在のニーズに合わせて使いやすいですか？これ
質問はあなたがいつ持っているかを判断するのに役立ちます
APIをシンプルで一般的なものにするのに行き過ぎ-
目的。あなたが追加の多くを書く必要がある場合
現在の目的のためにクラスを使用するためのコード、それは
インターフェイスが提供しないことを示すaredフラグ
適切な機能。たとえば、1つのアプローチ

テキストクラスはそれをデザインすることになるでしょう
単一文字操作：挿入は単一を挿入します
文字と削除は、単一の文字を削除します。これ
APIはシンプルで汎用的です。でも、
テキストに使用するのは特に簡単ではありません
エディター：高レベルのコードには多くのループが含まれます
文字の範囲を挿入または削除します。シングルd：\ work \ Kindle \ phil \104.png@@文字アプローチも非効率的です
大規模な操作。したがって、テキストクラスの方が適しています
の範囲での操作のサポートが組み込まれている
文字。

6.6スペシャライゼーションを上向きにプッシュする（および
下向き！）

ほとんどのソフトウェアシステムは必然的にいくつかを持っている必要があります
特殊化されたコード。たとえば、アプリケーション
ユーザーに特定の機能を提供します。これらは

多くの場合、高度に専門化されています。したがって、通常はそうではありません
専門性を完全に排除することが可能です。
ただし、特殊なコードはきれいにする必要があります
汎用コードから分離。これは
特殊なコードを上にプッシュするか、
ソフトウェアスタックにダウンします。

特殊なコードを分離する1つの方法は、
上に押します。のトップレベルクラス
特定の機能を提供するアプリケーションは、
必然的にそれらの機能に特化します。だが
この専門分野は浸透する必要はありません
実装に使用される下位レベルのクラス
機能。これはエディターの例で見ました
この章の前半。元の学生
実装は、バックスペースキーの動作などの特殊なユーザーインターフェイス：\ work \ Kindle \ phil \105.png@@の詳細をリークしました
テキストクラスの実装に至るまで。 The
改善されたテキストAPIは、すべての専門分野を推進しました
ユーザーインターフェイスコードに上向きに、
テキストクラスの汎用コード。

時々最良のアプローチはプッシュすることです
下向きの専門。この一例
デバイスドライバです。オペレーティングシステム

通常
数百または数千の異なるをサポートする必要があります
さまざまな種類のデバイスなど、デバイスの種類
セカンダリストレージデバイス。これらの各デバイス
typesには、独自の専用コマンドセットがあります。の
特殊なデバイス特性を防ぐため
メインオペレーティングシステムへのリークから
コード、オペレーティングシステムはとのインターフェイスを定義します
二次的な汎用操作
ストレージデバイスは、「読み取り
「ブロック」と「ブロックを書く」。それぞれの異なる
デバイス、デバイスドライバモジュールは、
専用インターフェースを使用した汎用インターフェース
その特定のデバイスの機能。このアプローチ
スペシャライゼーションをデバイスドライバーにプッシュダウンし、
オペレーティングシステムのコアができるように
特定のデバイスの知識なしで書かれた
特性。このアプローチはまたそれを容易にします
新しいデバイスを追加するには：デバイスに十分な機能がある場合：\ work \ Kindle \ phil \ 106.png @@デバイスドライバーインターフェイスを実装するには、次のようにします。
メインに変更を加えることなくシステムに追加

オペレーティング·システム。

6.7例：エディターの元に戻すメカニズム

GUIエディタープロジェクトでは、要件の1つ
だけでなく、マルチレベルの元に/やり直しをサポートすることでした
テキスト自体への変更だけでなく、
選択、挿入カーソル、および表示。例えば、
ユーザーがテキストを選択して削除し、スクロールして
ファイル内の別の場所で、undoを呼び出します。
エディターは、その状態を元の状態に復元する必要があります
削除前。これには、復元が含まれます
テキストを削除し、再度選択して、
ウィンドウに表示される選択したテキスト。

いくつかの学生プロジェクトは、
テキストクラスの一部としての取り消しメカニズム全体。
テキストクラスは、元に戻すことができるすべてのリストを維持していました
変更します。これに自動的にエントリを追加しました
テキストが変更されたときはいつでもリストします。変更について
選択、挿入カーソル、およびビューに、
ユーザーインターフェイスコードが追加のメソッドを呼び出しました
テキストクラスで、次のエントリを追加しました
元にできるリストへのそれらの変更。元に戻すかやり直すとき
ユーザーから要求された場合、次のコード化されたユーザーインターフェイス：\ work \ Kindle \ phil \ 107.png @@は、テキストクラスのメソッドを呼び出し、その後、
元にできるリストのエントリを処理しました。エントリー用
テキストに関連して、テキストの内部を更新しました
クラス;他のものに関連するエントリの場合、
選択、ユーザーにコールバックされたテキストクラス
元に戻すまたはやり直しを実行するためのインターフェースコード。

このアプローチは、厄介なセットをもたらしました
テキストクラスの機能。元に戻す/やり直しのコア
の汎用メカニズムで構成されています
実行されたアクションのリストの管理
元に戻すときにそれらをステップスルーし、
やり直し操作。コアはテキストにありました
クラスと特別な目的のハンドラー
特定のもののために元に戻るとやり直しを実装しました
テキストや選択など。専用
選択のためのハンドラーを元に戻し、カーソルが持っていた
テキストクラスの他のものとは何の関係もありません。
それらは、
テキストクラスとユーザーインターフェイス、および追加
元に戻す情報を渡すための各モジュールのメソッド
行ったり来たり。新しい種類の取り消し可能なエンティティの場合
将来的にシステムに追加された場合、
新規を含むテキストクラスへの変更が必要
そのエンティティに固有のメソッド。加えて
汎用アンドゥコアは、
class.d：\ work \ Kindle \ phil \ 108.png @@の汎用テキスト機能これらの問題は、抽出することで解決できます。
元に戻る/やり直しメカニズムの汎用コア
別のクラスに配置します。

パブリッククラスの履歴{
パブリックインターフェイスアクション{

public void redo（）;
public void undo（）;

歴史（ {...}

void addAction（Action action）{...}

void addFence（）{...}

void undo）{..-}
void redo（）{..-}

}
この設計では、Historyクラスが

インターフェイスを実装するオブジェクトのコレクション
History.Action。各History.Actionは、
テキスト挿入や
カーソル位置の変更、およびそれは提供します
操作を元に戻したりやり直したりできるメソッド。 The
歴史の授業は情報について何も知りません
アクションに保存されるか、アクションがどのように実装されるか
元に戻すとやり直しのメソッド。歴史は歴史を維持します
で実行されたすべてのアクションを説明するリスト
アプリケーションの存続期間、および元に戻すと
ユーザーが要求した取り消しに応じて、リストを前後に移動するREDOメソッドd：\ work \ Kindle \ phil \ 109.png @@
とやり直し、で元にとやり直しメソッドを呼び出す
History.Actions。

History.Actionsは特別な目的のオブジェクトです：それぞれ
特定の種類の元に戻すことができることを理解している
手術。それらは外部で実装されます
特定を理解するモジュールの歴史クラス
取り消し可能なアクションの種類。テキストクラスは
UndoableInsertとUndoableDeleteを実装します
テキストの挿入と削除を説明するオブジェクト。
テキストを挿入するたびに、テキストクラスは
挿入を説明する新しいUndoableInsertオブジェクト
そして、History.addActionを呼び出して、
履歴リスト。編集者のユーザー

インターフェイスコードは
UndoableSelectionオブジェクトとUndoableCursorオブジェクトを作成します
選択と挿入の変更について説明します
カーソル。

Historyクラスでは、アクションを次のようにすることもできます
たとえば、単一の取り消し要求が行われるようにグループ化されます
ユーザーから削除されたテキストを復元できます、再選択
テキストを削除し、挿入カーソルを再配置します。
Historyクラスのグループ化を実装するには、
履歴リストに配置されたマーカーであるフェンス
関連するアクションのグループを分離します。への各呼び出し
歴史。 REDOは歴史をさかのぼります
リスト、次のフェンスに到達するまでアクションを元に戻します。d：\ work \ Kindle \ phil \110.png@@フェンスの配置は上位によって決定されます-
History.addFenceを呼び出してコードをレベルアップします。

このアプローチは、元に戻すの機能を分割します
それぞれが実装されている3つのカテゴリに分類されます
別の場所で：

+管理のための汎用メカニズム
アクションをグループ化し、undo/を呼び出す
やり直し操作（履歴によって実装）
クラス）。

+特定のアクションの詳細
（さまざまなクラスによって実装され、それぞれが
少数の行動を理解する
タイプ）。

+アクションをグループ化するためのポリシー
（高レベルのユーザーインターフェイスによって実装されます
適切な全体的なアプリケーションを提供するためのコード
行動）。

これらの各カテゴリを実装できます。
他のカテゴリーを理解せずに。
Historyクラスはどのような種類かわかりません
アクションの数が取り消されています。使用できます
さまざまなアプリケーションで。各アクションクラス
単一の種類のアクションのみを理解し、
履歴クラスもアクションクラスもありません
アクションをグループ化するためのポリシーを知っておく必要があります。d：\ work \ Kindle \ phil \ 111.png@@重要な設計上の決定は、次のようなものでした。
元にスキャンの汎用部分を分離しました
専用部品の機構、
汎用用に別のクラスを作成する
パーツと専用パーツを押し下げる
History.Actionのサブクラスに。かつては
完了すると、残りのデザインは自然に落ちました。

注：一般的なものを分離するための提案-
専用コードからの目的コードは参照します
特定のメカニズムに関連するコードに。にとって
例、特別な目的の元に戻るコード（コードなど
テキストの挿入を元に戻すには）を
汎用アンドゥコード（管理するコードなど）
履歴リスト）。ただし、
1つのメカニズムに専用コードを組み合わせる
別の汎用コードで。テキスト
クラスはこの例です：それは一般的なものを実装します-
テキストを管理するための目的メカニズム、しかしそれは
元に戻すことに関連する特別な目的のコードが含まれています。
元にスキャンコードは、それだけのために特別な目的です
テキスト変更の取り消し操作を処理します。

このコードをと組み合わせても意味がありません
の汎用元に戻すインフラストラクチャ
歴史の授業ですが、
テキストクラス、他のテキストと密接に関連しているため
関数.d：\ work \ Kindle \ phil \ 112.png@@6.8コード内の特殊なケースを排除する

この時点まで私は話し合っていました
クラスとメソッドのコンテキストでの専門化
設計。特殊化の別の形式はで発生します
特別な形式のメソッド本体のコード
ケース。特殊なケースでは、コードが乱雑になる可能性があります
ifステートメントを使用すると、コードが困難になります
理解し、バグが発生しやすい。したがって、特別
ケースは可能な限り排除する必要があります。

これを行うための最良の方法は、通常の設計を行うことです
エッジを自動的に処理する方法でケース
余分なコードなしの条件。

テキストエディタプロジェクトでは、学生は
テキストを選択するためのメカニズムを実装し、
選択範囲をコピーまたは削除します。生徒の大半
それらの選択に状態変数を導入しました
かどうかを示すための実装
選択が存在します。彼らはおそらくこのアプローチを選択しました
選択範囲が表示されない場合があるため
画面に表示されるので、表現するのは自然なことのように見えました
実装におけるこの概念。しかし、これは
アプローチは、を検出するための多数のチェックをもたらしました
「選択なし」の状態で、特別に処理します。

選択処理コードを簡略化できます
「選択なし」の特殊なケースを排除することにより、
選択が常に存在するようにします。 thered：\ work \ Kindle \ phil \ 113.png @@が画面に表示されていない場合は、次のようになります。
空の選択で内部的に表され、
その開始位置と終了位置は同じです。
このアプローチでは、選択管理
コードは、「いいえ」のチェックなしで記述できます。
選択"。選択範囲をコピーする場合、
選択が空の場合、0バイトがに挿入されます
新しい場所。正しく実装されている場合は、
特別なものとして0バイトをチェックする必要はありません
場合。同様に、
空になるように選択を削除するためのコード
ケースは特別なケースのチェックなしで処理されます。
すべて1行で選択することを検討してください。を削除するには
選択して、前の行の部分を抽出します
選択して、その部分と連結します
新しいを形成するための選択に続く行の
ライン。選択がeの場合

mpty、このアプローチは
元の行を再生成します。

第10章では、
さらに多くの特殊なケース、および
それらが処理されなければならない場所の数。

6.9結論

不必要な専門化、
特別な目的のクラスとメソッドの形式ord：\ work \ Kindle \ phil \ 114.png @@コードの特別な場合は、重要な貢献者です

ソフトウェアの複雑さに。専門化することはできません
完全に排除されましたが、優れたデザインです

あなたはそれを大幅に減らすことができるはずですそして
特殊なコードを汎用から分離する
コード。これにより、クラスがより深くなり、より良い結果が得られます
情報隠蔽、そしてよりシンプルでより明白

code.d：\ work \ Kindle \ phil \115.png@@第7章

別のレイヤー、別の
抽象化

ソフトウェアシステムはレイヤーで構成されており、
上位層は下位層が提供する機能を使用します
レイヤー。適切に設計されたシステムでは、各レイヤー
レイヤーとは異なる抽象化を提供します
その上下;単一の操作に従う場合
を呼び出すことにより、レイヤーを上下に移動します
メソッド、抽象化はそれぞれで変化します
メソッド呼び出し。例えば：

-最上位層のInaファイルシステム
ファイルの抽象化を実装します。ファイルは次のとおりです
バイトの可変長配列の
読み書きで更新できます
可変長バイト範囲。次の下
ファイルシステムのレイヤーはキャッシュを実装します
固定サイズのディスクブロックのメモリ内。発信者
頻繁に使用されるblocked：\ work \ Kindle \ phil \ 116.png @@は、メモリ内に残り、
すぐにアクセスしました。最下層はで構成されています
ブロックを移動するデバイスドライバー
セカンダリストレージデバイスとメモリ。

+ TCPなどのネットワークトランスポートプロトコルでは、
最上位によって提供される抽象化
レイヤーは、確実に配信されるバイトのストリームです
あるマシンから別のマシンへ。このレベルは
パケットを送信する下位レベルに構築
最高のマシン間の制限されたサイズの
労力ベース：ほとんどのパケットが配信されます
正常に実行されましたが、一部のパケットが失われたり、
故障して配達されました。

システムに隣接するレイヤーが含まれている場合
同様の抽象化、これは示唆する赤い旗です
クラス分解の問題。これ
この章では、これが発生する状況について説明します。
結果として生じる問題、およびリファクタリングする方法
問題を解消します。

7.1パススルー方法

隣接するレイヤーに同様の抽象化がある場合、
問題はしばしば次の形で現れます
パススルーメソッド。パススルー方式は
別のメソッドを呼び出す以外はほとんど何もしません。d：\ work \ Kindle \ phil \117.png@@署名がそれと類似または同一である

呼び出し元のメソッドの。たとえば、学生
含まれているGUIテキストエディタを実装するプロジェクト
ほぼ完全にパススルーで構成されるクラス
メソッド。そのクラスからの抜粋は次のとおりです。

パブリッククラスTextDocument...{

プライベートTextAreatextArea;

プライベートTextDocumentListenerリスナー;

public Character getLastTypedCharacter（）{
textArea.getLastTypedCharacter（）を返します;
3
public int getCursor0ffset（）{
textArea.getCursorOffset（）を返します;
3
public void insertString（String textToInsert、
intオフセット）{
textArea。 insertString（textToInsert、offset）;
3
public void willInsertString（String stringToInsert、
intオフセット）{
if（listener！= null）{
listener.willInsertString（this、stringToInsert、
オフセット）;
3

 危険信号：パススルー方式：\ work \ Kindle \ phil \ 118.png @@パススルー方式は、何も実行しない方式です。
引数を別のメソッドに渡すことを除いて、
通常、パススルーと同じAPIを使用します
方法。これは通常、存在しないことを示します
間の責任のクリーンな分割
クラス。

そのクラスの15のパブリックメソッドのうち13が合格でした-
メソッドを介して。
パススルーメソッドはクラスを浅くします：
それらは、インターフェースの複雑さを増します
クラス。複雑さが増しますが、そうではありません
システムの総合的な機能を向上させます。
上記の4つの方法のうち、最後の1つだけが
任意の機能、そしてそれでも些細なことです：
メソッドは、1つの変数の有効性をチェックします。パス-
メソッドを介して、間の依存関係も作成します
クラス：insertStringの署名が変更された場合
TextAreaのメソッド、次にinsertStringメソッド
TextDocumentは、一致するように変更する必要があります。
パススルーメソッドは、
責任分担をめぐる混乱
クラス間。上記の例では、

TextDocumentクラスはinsertStringメソッドを提供しますが、butd：\ work \ Kindle \ phil \119.png@@テキストを挿入する機能が実装されています
完全にTextAreaにあります。これは通常悪い考えです：
機能の一部へのインターフェースは
機能を実装する同じクラス。
1つのパススルーメソッドを見るとき
別のクラスに、2つのクラスを検討し、質問します
あなた自身「正確にどの機能と抽象化
これらのクラスのそれぞれが責任を負っていますか？」君

おそらく重複があることに気付くでしょう
クラス間の責任。

解決策は、クラスをリファクタリングして、
各クラスにはdistがあります

inctとコヒーレントなセット
責任。図7.1は、いくつかの方法を示しています
これをする。図7.1（b）に示す1つのアプローチは、
下位レベルのクラスを発信者に直接公開する
より高いレベルのクラスの、すべての責任を取り除く
上位クラスの機能の場合。別
アプローチは、機能を再配布することです
図7.1（c）のように、クラス間。最後に、
クラスを解きほぐすことはできません、最良の解決策
図7.1（d）のようにそれらをマージすることかもしれません。

上記の例では、3つのクラスがありました
絡み合った責任を持つ：TextDocument、
TextArea、およびTextDocumentListener。学生
移動することでパススルー方式を排除
クラス間のメソッドと3つのクラスの折りたたみ：\ work \ Kindle \ phil \ 120.png @@クラスを2つにまとめ、その責任は
より明確に区別されます。

7.2インターフェースの複製はいつOKですか？

同じシグニチャを持つメソッドを持つことは
いつも悪い。重要なことは、それぞれの新しいことです
メソッドは重要な機能に貢献する必要があります。
パススルー方式は、パススルー方式が悪いためです。
新しい機能は提供しません。

メソッドが次のことを行うのに役立つ1つの例
同じ署名を持つ別のメソッドを呼び出すと、
発車係。ディスパッチャは、
他のいくつかの方法の1つを選択するための引数
呼び出す;次に、引数のほとんどまたはすべてを渡します
選択した方法に。の署名
コーディネーターは多くの場合、の署名と同じです
それが呼び出すメソッド。それでも、コーディネーター
便利な機能を提供します：それはどれを選択します
他のいくつかの方法で各タスクを実行する必要があります。d：\ work \ Kindle \ phil \ 121.png @@ ty yy i
olDlelole oi |
calyx] Ol @）> <c2alyx | Ol @ | <
（a）（b）
th iit Lidl
ciL [Olsx] c2lOo [@px c1LOlxlOle @ px
（CD）

図7.1：パススルーメソッド。 （a）では、クラスC1には
呼び出すだけの3つのパススルーメソッド
C2で同じシグネチャを持つメソッド（各シンボル
特定のメソッドシグネチャを表します）。パススルー
C1の呼び出し元にC2を呼び出させることで、メソッドを排除できます。
（b）のように、機能を

（c）のように、またはによってクラス間の呼び出しを回避するためのC1およびC2

（d）のようにクラスを組み合わせる。

たとえば、Webサーバーが
Webブラウザからの着信HTTPリクエスト、それ
内のURLを調べるディスパッチャを呼び出します
着信要求と特定のメソッドを選択して
リクエストを処理します。一部のURLは処理される場合があります
ディスク上のファイルの内容を返すことによって。その他
プロシージャinaを呼び出すことによって処理される可能性があります
PHPやJavaScriptなどの言語。派遣
プロセスは非常に複雑になる可能性があり、通常は次のように駆動されます：\ work \ Kindle \ phil \ 122.png @@は、
着信URL。

いくつかの方法で同じものを使用することは問題ありません
それらのそれぞれが有用なものを提供する限り、署名
と明確な機能。によって呼び出されるメソッド
ディスパッチャにはこのプロパティがあります。もう一つの例
は、次のような複数の実装を持つインターフェイスです
オペレーティングシステムのディスクドライバとして。各ドライバー
別の種類のディスクをサポートしますが、
それらはすべて同じインターフェースを持っています。いくつかの場合
メソッドは、さまざまな実装を提供します
同じインターフェースで、認知的負荷を軽減します。一度あなた
これらの方法のいずれかを使用した方が簡単です
他の人と一緒に仕事をする必要がないので
新しいインターフェースを学びます。このような方法は通常
同じレイヤーにあり、お互いを呼び出しません。

7.3デコレータ

デコレータデザインパターン（別名
「ラッパー」）は、APIの複製を促進するものです
レイヤー間。デコレータオブジェクトは既存のものを取ります
オブジェクトとその機能を拡張します。それは提供します
基盤となるAPIと類似または同一のAPI
オブジェクト、およびそのメソッドは、のメソッドを呼び出します
基になるオブジェクト。 Java I / Oの例：\ work \ Kindle \ phil \ 123.png @@第4章、BufferedInputStreamクラス

デコレータです：InputStreamオブジェクトが与えられると、それは
同じAPIを提供しますが、バッファリングを導入します。
たとえば、readメソッドが呼び出されたとき

単一の文字を読み取るには、読み取りを呼び出します。
基になるInputStreamは、はるかに大きなブロックを読み取ります。
将来を満たすために余分な文字を保存します
呼び出しを読み取ります。別の例はウィンドウ処理で発生します
システム：Windowクラスは単純な
スクロールできないウィンドウの形式、およびa
ScrollableWindowクラスは、ウィンドウクラスを次のように装飾します。
水平および垂直スクロールバーを追加します。

デコレータの動機は分離することです
より多くからのクラスの特別な目的の拡張
ジェネリックコア。ただし、デコレータクラスは
浅くする：彼らは大量の
少量の新機能のための定型文。
デコレータクラスには、多くの場合、多くのパススルーが含まれています
メソッド。デコレータパターンを使いすぎるのは簡単ですが、
小さな新機能ごとに新しいクラスを作成します。
これにより、次のような浅いクラスが爆発します。
Java I/Oの例として。

デコレータクラスを作成する前に、
次のような代替手段：

+新しい機能を追加していただけませんか
直接下に
gクラス、むしろ：\ work \ Kindle \ phil \ 124.png @@デコレータクラスを作成するよりも？これにより
新しい機能が比較的であるかどうかを感知します
汎用、または論理的に関連している場合
基礎となるクラスに、またはほとんどの場合

基礎となるクラスの
新機能。たとえば、事実上
JavaInputStreamを作成するすべての人
また、BufferedInputStreamを作成し、
バッファリングはI/Oの自然な部分であるため、これらは
クラスを組み合わせる必要がありました。

-新機能がに特化している場合
特定のユースケース、それは理にかなっていますか
ユースケースではなく、ユースケースとマージする
別のクラスを作成しますか？

+新機能を
を作成するのではなく、既存のデコレータ
新しいデコレータ？これにより、単一の結果になります
複数ではなく、より深いデコレータクラス
浅いもの。

+最後に、新しいかどうかを自問してください
機能は本当にラップする必要があります
既存の機能：実装できますか
独立したスタンドアロンクラスとして
基本クラスの？ウィンドウで
たとえば、スクロールバーはおそらく
maind：\ work \ Kindle \ phil \ 125.png @@ウィンドウとは別に実装され、既存のすべてをラップすることはありません
機能。

時々状況があります
ラッパーは理にかなっています。一例として、
システムは、そのインターフェースが外部クラスを使用します
変更することはできませんが、クラスは準拠している必要があります
アプリケーション内の別のインターフェイスに
使用されています。この場合、ラッパークラスは次のようになります。
インターフェイス間の変換に使用されます。でも、
このような状況はまれです。通常はより良いものがあります
ラッパークラスを使用する代わりに。

7.4インターフェースと実装

「異なる層の別のアプリケーション、
異なる抽象化」のルールは、インターフェースが

クラスのは通常、とは異なる必要があります

その実装：使用される表現
内部的には抽象化とは異なる必要があります
インターフェイスに表示されます。 2つが似ている場合
抽象化すると、クラスはおそらくそれほど深くはありません。
たとえば、議論されたテキストエディタプロジェクトでは

第6章では、ほとんどのチームが
テキストの行に関するテキストモジュール、各行
別々に保管されます。一部のチームも設計しました
行周辺のテキストクラスのAPI、withd：\ work \ Kindle \ phil \ 126.png@@メソッド（getLineやputLineなど）。しかし、これは
テキストクラスを浅く、使いにくいものにしました。の
高レベルのユーザーインターフェースコード、それは一般的です
行の途中にテキストを挿入する（例：
ユーザーが入力している）またはテキストの範囲を削除するには
行にまたがる。テキスト用の行指向APIを使用
クラスでは、発信者はラインを分割して結合することを余儀なくされました
ユーザーインターフェイス操作を実装します。このコード
自明ではなく、複製され、散らばっていた
ユーザーインターフェイスの実装全体。
テキストクラスは、次の場合にはるかに使いやすくなりました。
彼らは文字指向のインターフェースを提供しました、
任意のを挿入する挿入メソッドなど
テキストの文字列（改行を含む場合があります）
テキスト内の任意の位置と削除
2つの任意のテキストの間のテキストを削除するメソッド
テキスト内の位置。内部的には、テキストはまだでした
線で表されます。キャラクター志向
インターフェイスはラインの複雑さをカプセル化します
テキストクラス内での分割と結合。
テキストクラスをより深くし、より高く単純化します
クラスを使用するレベルコード。このアプローチでは、
テキストAPIは行指向とはかなり異なります
ストレージメカニズム;違いは
class.d：\ work \ Kindle \ phil \ 127.png@@7.5パススルー変数によって提供される貴重な機能

レイヤー間でのAPI複製の別の形式は

パススルー変数。これは、
メソッドの長いチェーンを介して受け継がれました。
図7.2（a）は、データセンターの例を示しています
サービス。コマンドライン引数は説明します
安全な通信に使用する証明書。これ
情報は低レベルの方法でのみ必要です
ライブラリメソッドを呼び出してソケットを開くm3、
しかし、それは上のすべてのメソッドを介して受け継がれます
mainとm3の間のパス。証明書変数
各中間体の署名に表示されます
メソッド。

パススルー変数は複雑さを増します。
それらはすべての中間メソッドを強制します
方法にもかかわらず、それらの存在に気づいています
変数は使用できません。さらに、
新しい変数が発生します（たとえば、

システムは最初、サポートなしで構築されます
証明書ですが、後でそれを追加することにします
サポート）、あなたは多数を変更する必要があるかもしれません
変数を渡すためのインターフェースとメソッドの数
関連するすべてのパスを介して。

パススルー変数を削除すると、
挑戦。 1つのアプローチは、あるかどうかを確認することです
すでに最上位のメソッドと最下位のメソッド間で共有されているオブジェクト：\ work \ Kindle \ phil \128.png@@最下位のメソッド。データセンターサービス
図7.2の例、おそらくオブジェクトがあります
ネットワークに関するその他の情報が含まれています
メインとの両方で利用可能な通信
m3。もしそうなら、メイン

証明書情報をに保存できます
そのオブジェクトなので、すべてを通過する必要はありません
m3へのパスに介在するメソッド（図を参照）
7.2（b））。ただし、そのようなオブジェクトがある場合は、
それ自体がパススルー変数である可能性があります（他にどのように
m3はそれにアクセスできますか？）。

別のアプローチは、情報を保存することです
図7.2（c）のように、グローバル変数で。これは回避します
メソッドからに情報を渡す必要性
メソッドですが、グローバル変数はほとんどの場合作成します
その他の問題。たとえば、グローバル変数は
2つの独立したインスタンスを作成することは不可能です
同じプロセスで同じシステムの
グローバル変数へのアクセスは競合します。それ
複数が必要になる可能性は低いと思われるかもしれません
本番環境のインスタンスですが、多くの場合、
テスト。

私が最も頻繁に使用する解決策は、
図7.2（d）のようなコンテキストオブジェクト。コンテキストストア
アプリケーションのすべてのグローバル状態（
それ以外の場合はパススルー変数または
グローバル変数）。ほとんどのアプリケーションは、グローバル状態で複数の：\ work \ Kindle \ phil \129.png@@変数を持っています。
構成オプション、共有サブシステムなど、
とパフォーマンスカウンター。 1つのコンテキストがあります
システムのインスタンスごとのオブジェクト。コンテキスト
システムの複数のインスタンスを共存させることができます
それぞれ独自のコンテキストを持つ単一のプロセス。d：\ work \ Kindle \ phil \ 130.png @@ main（arge、argv）main（arge、argv）

| 1 os

m1（... cert、...）m1￠...）x

| |バイ共有
物体
mC ... cert、22.）mc。）LS
m3（... cert、...）{m3 ...￡
openSocket（cert、...）openSocket（obj.cert、...）
oo oo
（a）（b）
main（arge、argv）main（argc、argv）
' \ タイムアウト
mu。）slobalmidメトリック|コンテキスト
4変数| cert[オブジェクト
m2 ...）f m2（...）
m3（...）m3 ...￡
openSocket（cert、...）openSocket（context.cert、...）
3 +
（）（4）

図7.2：パスを処理するための可能な手法-
変数を介して。 （a）では、証明書はメソッドを介して渡されます

m1とm2は使用していませんが。 （b）では、mainとm3
オブジェクトへの共有アクセス権があるため、変数を格納できます
m1とmzを通過する代わりにそこにあります。 （c）では、証明書は
グローバル変数として格納されます。 （d）では、証明書はコンテキストに保存されます
オブジェクトと他のシステム全体の情報（
タイムアウト値とパフォーマンスカウンター。への参照
コンテキストは、メソッドがアクセスする必要があるすべてのオブジェクトに格納されます
it.d:​​\work\kindle\phil\131.png @@残念ながら、コンテキストはおそらく
多くの場所で必要になるため、
パススルー変数。の数を減らすために
それを認識しなければならないメソッド、への参照
コンテキストは、ほとんどのシステムに保存できます
主要なオブジェクト。図7.2（d）の例では、
m3を含むクラスは、コンテキストへの参照を格納します
オブジェクトのインスタンス変数として。新しいとき
オブジェクトが作成されると、作成メソッドは
そのオブジェクトからのコンテキスト参照とそれをに渡します
新しいオブジェクトのコンストラクタ。このアプローチでは、
コンテキストはどこでも利用できますが、それだけです
コンストラクターでは明示的な引数として表示されます。

コンテキストオブジェクトは、すべての処理を統合します
システム-グローバル情報と必要性を排除します
パススルー変数の場合。新しい変数が必要な場合
追加する場合は、コンテキストオブジェクトに追加できます。いいえ
コンストラクターを除いて、既存のコードが影響を受けます
コンテキストのデストラクタ。コンテキストは
のグローバルな状態を識別して管理するのは簡単です
システムはすべて1か所に保存されているためです。 The
コンテキストはテストにも便利です：テストコードは
アプリケーションのグローバル構成を変更する
コンテキスト内のフィールドを変更する。それはそのようになります
このような変更を実装するのははるかに困難です

システムはパススルー変数を使用しました。d：\ work \ kindle \ phil \132.png@@コンテキストは理想的なソリューションとはほど遠いものです。 The
コンテキストに格納された変数には、ほとんどの
グローバル変数の欠点;たとえば、
特定の変数がなぜであるかは明らかではないかもしれません
存在する、またはそれが使用される場所。規律がなければ、
コンテキストは、データの巨大なグラブバッグに変わる可能性があります
全体に非自明な依存関係を作成します
システム。コンテキストによってスレッドが作成される場合もあります-
安全性の問題;問題を回避するための最良の方法
コンテキスト内の変数が不変であるためのものです。
残念ながら、私はより良い解決策を見つけられませんでした
コンテキストより。

7.6結論

設計インフラストラクチャの各部分が追加されました
インターフェイス、引数、関数などのシステム、
クラス、または定義は、複雑さを追加します。
開発者はこの要素について学ぶ必要があります。の

要素がに対して純利益を提供するための注文
複雑さ、それはいくつかの複雑さを排除する必要があります
それがない場合に存在します

デザイン要素。そうでなければ、あなたはより良いです
その特定なしでシステムを実装する
エレメント。たとえば、クラスは機能をカプセル化することで複雑さを軽減できます：\ work \ Kindle \ phil \ 133.png @@
クラスはそれを意識する必要はありません。

「異なるレイヤー、異なる抽象化」
ルールはこのアイデアの単なる適用です：異なる場合
レイヤーは同じabstractioを持っています

n、pass-など
メソッドやデコレーターを通して、良いものがあります
彼らが十分な利益を提供していない可能性
追加のインフラストラクチャを補うため
それらは表します。同様に、パススルー引数
いくつかの方法のそれぞれに注意する必要があります
それらの存在（複雑さを増す）なし
追加機能の提供.d：\ work \ Kindle \ phil \134.png@@第8章

複雑さを下に引っ張る

この章では、別の考え方を紹介します
より深いクラスを作成する方法について。仮定
新しいモジュールを開発していて、
避けられない複雑さの一部。どちらが良いですか：
モジュールのユーザーに対処させる必要があります
複雑さ、または複雑さを処理する必要があります
モジュール内で？複雑さが
モジュールによって提供される機能に関連して、
次に、2番目の答えは通常正しいものです。
ほとんどのモジュールには、開発者よりも多くのユーザーがいます。

したがって、開発者にとっては、
ユーザー。モジュール開発者として、あなたは努力する必要があります
あなたのユーザーの生活をできるだけ簡単にします
モジュール、たとえそれがあなたのために余分な仕事を意味するとしても。
この考えを表現する別の方法は、
モジュールがシンプルであることがより重要です
単純な実装よりもインターフェース。d：\ work \ kindle \ phil \ 135.png @@開発者として、
反対の方法：簡単な問題を解決し、
難しいものを他の誰かにパントします。条件の場合
対処方法がわからない場合は、
最も簡単なのは、例外をスローして、
発信者がそれを処理します。どのポリシーかわからない場合
実装するには、いくつかの構成を定義できます
ポリシーを制御し、そのままにしておくためのパラメータ
システム管理者に最適なものを見つけてもらいます
それらの値。

このようなアプローチはあなたの人生を楽にします
短期的には、しかしそれらは複雑さを増幅し、
多くの人が問題に対処しなければならないように、
一人ではなくたとえば、クラスの場合
例外をスローします。クラスのすべての呼び出し元は
それに対処する必要があります。クラスが構成をエクスポートする場合
パラメータ、すべてのすべてのシステム管理者
インストールはそれらを設定する方法を学ぶ必要があります。

8.1例：エディタテキストクラス

次のファイルのテキストを管理するクラスについて考えてみます。
章で説明されているGUIテキストエディタ
6および7。このクラスは、ファイルを読み取るためのメソッドを提供します。
ディスクからメモリに、クエリを実行して変更します。
ファイルのメモリコピーを作成し、modifiedd：\ work \ Kindle \ phil \136.png@@バージョンをディスクに書き込みます。学生がしなければならなかったとき
このクラスを実装し、それらの多くは行を選択しました-
読み取り、挿入、
テキストの行全体を削除します。これにより、
クラスの単純な実装ですが、作成されました
より高いレベルのソフトウェアの複雑さ。のレベルで
ユーザーインターフェイス、操作が全体を含むことはめったにありません
行。たとえば、キーストロークは個人を引き起こします
既存の行に挿入される文字。
選択範囲をコピーまたは削除すると、パーツが変更される可能性があります
いくつかの異なる行の。ライン指向で
テキストインターフェイス、高レベルのソフトウェアを分割する必要があり、
ユーザーインターフェイスを実装するために行を結合します。
のような文字指向のインターフェース
セクション6.3で説明されているものは複雑さを引き出します
下向き。ユーザーインターフェイスソフトウェアができるようになりました
任意の範囲のテキストを挿入および削除せずに
行を分割してマージするため、より簡単になります。
おそらくテキストクラスの実装
より複雑になります：それがテキストを表す場合
行のコレクションとして内部的に、それはする必要があります
行を分割してマージし、文字を実装します-
指向の操作。このアプローチの方が優れています
分割の複雑さをカプセル化するため
テキストクラス内でマージすると、
システムの全体的な複雑さ.d：\ work \ kindle \ phil \ 137.png @@ 8.2例：構成パラメーター
構成パラメーターは、
複雑さを下ではなく上に移動します。
特定の行動を決定するのではなく
内部的には、クラスはいくつかのパラメータをエクスポートできます。
キャッシュのサイズなどの動作を制御する
与える前にリクエストを再試行する回数
上。次に、クラスのユーザーは適切なものを指定する必要があります
パラメータの値。構成
パラメータはシステムで非常に人気があります
今日;一部のシステムには数百個あります。

支持者は、構成パラメータが
ユーザーが調整できるので良いです
特定の要件のためのシステムと
ワークロード。状況によっては、低めの場合は困難です-
最適なポリシーを知るためのレベルのインフラストラクチャコード
適用しますが、ユーザーははるかに精通しています
それらのドメイン。たとえば、ユーザーは知っているかもしれません
一部のリクエストはよりタイムクリティカルです
その他、ユーザーが指定するのは理にかなっています
これらのリクエストの優先度が高くなります。次のような状況では
これにより、構成パラメーターの結果が向上する可能性があります
さまざまなドメインにわたるパフォーマンス。

ただし、構成パラメーターは
重要なものを扱うことを避けるための簡単な言い訳
問題を発行し、それらを渡します

他の誰かに。 Ind：\ work \ Kindle \ phil \ 138.png @@多くの場合、ユーザーにとっては困難または不可能です。
管理者は、の適切な値を決定します
パラメーター。他の場合には、正しい値が
少しで自動的に決定されています
システム実装での追加作業。検討
失われたパケットを処理する必要があるネットワークプロトコル。
リクエストを送信してもレスポンスを受信しない場合
一定期間内に、リクエストを再送信します。
再試行間隔を決定する1つの方法は、
構成パラメーターを導入します。でも、
トランスポートプロトコルは合理的な計算を行うことができます
応答時間を測定することにより、それ自体の値
成功してから複数を使用するリクエストの場合
再試行間隔のためにこれの。このアプローチは
複雑さを軽減し、ユーザーを
適切な再試行間隔を把握する必要があります。それは持っています
再試行を計算することの追加の利点
間隔は動的であるため、自動的に調整されます
動作条件が変化した場合。対照的に、
構成パラメーターは簡単に外れる可能性があります
日にち。

したがって、構成は避ける必要があります
可能な限りパラメータ。エクスポートする前に
構成パラメータについては、次のように自問してください。
（またはより高いレベルのモジュール）を決定することができます
ここで決定できるよりも良い値ですか？」いつd：\ work \ Kindle \ phil \ 139.png @@構成パラメーターを作成しますか？
妥当なデフォルトを提供できるため、ユーザーは
例外的な値の下でのみ値を提供する必要があります
条件。理想的には、各モジュールは
完全に問題;構成パラメーター
結果として不完全なソリューションになり、
システムの複雑さ。

8.3やりすぎ
複雑さを引き下げるときは、慎重に行ってください。
これは簡単にやり過ぎてしまう可能性のあるアイデアです。アン
極端なアプローチは、すべてを引っ張ることです
アプリケーション全体の機能がダウン
単一のクラスになりますが、明らかに
検出。複雑さを引き下げることは最大限に活用します
（a）引き下げられている複雑さが
クラスの既存の機能と密接に関連しており、
（b）複雑さを引き下げると、
アプリケーションの他の場所での簡略化、および（c）
複雑さを軽減すると、クラスが簡素化されます
インターフェース。目標は最小化することであることを忘れないでください
システム全体の複雑さ。

第6章では、一部の学生がどのように定義したかについて説明しました
ユーザーを反映したテキストクラスのメソッド
d：\ work \ Kindle \ phil \140.png@@バックスペースキーの機能を実装するメソッドなどのインターフェイス。かもしれない
複雑さを増すので、これは良いようです
下向き。ただし、知識を追加する

テキストクラスへのユーザーインターフェースは単純化されていません
非常に高レベルのコード、およびユーザーインターフェイス
知識はのコア機能とは関係ありません
テキストクラス。この場合、複雑さを軽減します
情報漏えいにつながっただけです。

8.4結論

モジュールを開発するときは、機会を探してください
自分自身に少し余分な苦しみを取るために
ユーザーの苦痛を軽減するために。d：\ work \ Kindle \ phil \141.png@@第9章

一緒に良いですか、それとも離れていますか？

ソフトウェアの最も基本的な質問の1つ
デザインはこれです：2つの機能が与えられた場合、
それらを一緒に実装する必要があります

同じ場所、またはそれらの実装は
分離？この質問は、のすべてのレベルに当てはまります
関数、メソッド、クラスなどのシステム、

とサービス。たとえば、バッファリングは
ストリーム指向を提供するクラスに含まれています
ファイルI/O、または別のクラスに含める必要がありますか？したほうがいい
HTTPリクエストの解析が実装されています
完全に1つの方法で、または分割する必要があります
複数の方法の間で（または複数の方法でさえ）
クラス）？この章では、
これらの決定を行う際に考慮してください。いくつかの

これらの要因の内、すでに議論されています
前の章ですが、ここで再検討します
for completeness.d：\ work \ Kindle \ phil \ 142.png @@結合するか分離するかを決定するときは、
目標は、システムの複雑さを軽減することです
全体として、そのモジュール性を向上させます。かもしれない
この目標を達成するための最良の方法は
システムを多数の小さなものに分割する
コンポーネント：コンポーネントが小さいほど、
個々のコンポーネントはより単純になる可能性があります。
ただし、細分化するという行為は、追加の
細分化前には存在しなかった複雑さ：

+いくつかの複雑さは
コンポーネントの数：より多く
コンポーネント、追跡するのが難しい
それらすべてと希望を見つけるのが難しい
大規模なコレクション内のコンポーネント。
細分化は通常、より多くの結果をもたらします
インターフェイス、およびすべての新しいインターフェイスが追加されます
複雑。

+細分化すると、追加のコードが生成される可能性があります
コンポーネントを管理します。たとえば、
以前に単一のオブジェクトを使用したコードの一部
サブディビジョンは今管理する必要があるかもしれません
複数のオブジェクト。

+細分化は分離を作成します：
細分化されたコンポーネントはさらに遠くなります
細分化前とは別に。
たとえば、一緒にされたメソッド：\ work \ Kindle \ phil \ 143.png @@ ina single class bef
鉱石の細分化は

細分化した後、異なるクラスにいる、

おそらく別のファイルにあります。分離
開発者が見にくくします
同時に、または
彼らの存在に気づいています。コンポーネントの場合
本当に独立しているなら、分離は
良い：それは開発者が集中することを可能にします
一度に単一のコンポーネントである必要はありません
他のコンポーネントに気を取られています。の上

一方、依存関係がある場合
コンポーネント間で、分離は
悪い例：開発者はひっくり返ってしまい、
コンポーネント間で4番目。さらに悪いことに、
彼らは依存関係を認識していないかもしれません、
バグにつながる可能性があります。

+細分化すると重複が生じる可能性があります：コード
以前は単一のインスタンスに存在していました
サブディビジョンは、それぞれに存在する必要がある場合があります
細分化されたコンポーネント。

コードの断片をまとめることが最も重要です
それらが密接に関連している場合は有益です。ピースが
無関係ですが、それらはおそらく離れた方が良いでしょう。ここ
2つのコードが
related：d：\ work \ Kindle \ phil \ 144.png@@+情報を共有します。たとえば、両方
コードの一部は、の構文に依存する可能性があります
特定の種類のドキュメント。
+それらは一緒に使用されます：
コードの一部は他を使用する可能性があります
同じように。この形の関係はただ
双方向であれば説得力があります。カウンターとして-
たとえば、ディスクブロックキャッシュはほとんど
常にハッシュテーブルが含まれますが、ハッシュテーブル
そうでない多くの状況で使用できます
ブロックキャッシュを含みます。したがって、これらのモジュール
分離する必要があります。
+それらは概念的に重複しており、
は単純な上位レベルのカテゴリです
両方のコードが含まれています。にとって
例、部分文字列と大文字小文字の検索
コンバージョンは両方ともカテゴリに分類されます
文字列操作の;フロー制御と
信頼性の高い配信は両方ともカテゴリに分類されます
ネットワーク通信の。
+の一部を理解するのは難しい
他を見ずにコードします。
この章の残りの部分では、より具体的なルールを使用します
それが理にかなっているときに示す例と同様に
コードの断片をまとめて、

それらを分離する意味。d：\ work \ Kindle \ phil \ 145.png@@9.1情報が共有されている場合はまとめる
セクション5.4は、この原則を文脈で紹介しました
HTTPサーバーを実装するプロジェクトのその中で
最初の実装では、プロジェクトは2つの異なるものを使用しました
読み込んで解析するさまざまなクラスのメソッド
HTTPリクエスト。最初の方法は、
ネットワークソケットからの着信要求と配置
文字列オブジェクトでそれを。解析された2番目のメソッド

のさまざまなコンポーネントを抽出する文字列
リクエスト。この分解により、両方の
メソッドは、かなりの知識を持って終わりました
HTTPリクエストの形式：最初の方法は
リクエストを読み取ろうとするだけで、解析はしませんが、
なしではリクエストの終了を識別できませんでした
それを解析する作業のほとんどを実行します（たとえば、
識別するためにヘッダー行を解析する必要がありました

リクエスト全体の長さを含むヘッダー）。
この共有情報のために、
同じ場所でリクエストの読み取りと解析の両方を行います。
2つのクラスが1つに結合されたとき、
コードが短くなり、シンプルになりました。

9.2単純化する場合はまとめる
インターフェース

2つ以上のモジュールを1つのモジュールに結合すると、次のように定義できる場合があります。
より単純な新しいモジュールのインターフェースまたは
元のインターフェイスよりも使いやすいです。これ

多くの場合、元のモジュールがそれぞれ
問題の解決策の一部を実装します。の中に
前のセクションのHTTPサーバーの例、
元のメソッドは、戻るためにインターフェースを必要としました
最初のメソッドからのHTTPリクエスト文字列

そしてそれを2番目に渡します。メソッドがあったとき
組み合わせて、これらのインターフェースは排除されました。

また、2つまたはの機能が
より多くのクラスが組み合わされると、
一部の機能を自動的に実行するため、
ほとんどのユーザーはそれらを意識する必要はありません。 Java
1/Oライブラリはこの機会を示しています。の場合
FileInputStreamクラスとBufferedInputStreamクラスは
組み合わせとバッファリングはデフォルトで提供されていましたが、
大多数のユーザーは、
バッファリングの存在に注意してください。組み合わせた
FileInputStreamクラスは、メソッドを提供する可能性があります
デフォルトのバッファリングメカニズムを無効にするか、置き換えます。
しかし、ほとんどのユーザーはそれらについて学ぶ必要はありません。

9.3重複を排除するためにまとめる

同じパターンのコードがoverd：\ work \ kindle \ phil \ 147.png @@以上繰り返されている場合は、コードを次のように再編成できるかどうかを確認してください。
繰り返しを排除します。 1つのアプローチは因数分解することです
繰り返されるコードを別のメソッドに出力し、
繰り返されるコードスニペットをへの呼び出しに置き換えます
メソッド。このアプローチは、
繰り返されるコードスニペットは長く、置換
メソッドには単純な署名があります。スニペットの場合

たった1行か2行の長さで、
メソッド呼び出しに置き換えることには多くの利点があります。

スニペットが複雑なwaで相互作用する場合

ysとその
環境（多数のローカルにアクセスするなど）
変数）、その後、置換メソッドは
複雑な署名が必要です（多くのパスなど）
参照引数による）、それはそのを減らすでしょう
価値。

重複を排除する別の方法は、

問題のスニペットになるようにコードをリファクタリングします
1か所で実行するだけで済みます。あなたが
エラーを返す必要があるメソッドを書いています
いくつかの異なるポイントで、同じクリーンアップ
これらの各ポイントでアクションを実行する必要があります
戻る前に（例については図9.1を参照）。
プログラミング言語がgotoをサポートしている場合、
クリーンアップコードを最後に移動できます
メソッドを実行してから、各スニペットでそのスニペットに移動します。
ind：\ work \ Kindle \ phil \ 148.png @@のように、エラーを返す必要があるポイント図9.2。 Gotoステートメントは一般的に考慮されます
悪い考えです、そしてそれらは判読不能になる可能性があります
無差別に使用する場合はコードしますが、便利です

彼らが逃げるために使用されるこのような状況では
ネストされたコードから。

9.4汎用と特殊の分離-

目的コード
モジュールに次のようなメカニズムが含まれている場合
いくつかの異なる目的で使用される場合は、
その1つの汎用メカニズムだけを提供します。
に特化したコードを含めるべきではありません
特定の用途のためのメカニズム、またそれはすべきではありません
他の汎用メカニズムが含まれています。
一般に関連付けられた専用コード-
目的のメカニズムは通常、伊那に行く必要があります
別のモジュール（通常、に関連付けられているモジュール
特定の目的）。 GUIエディターのディスカッション
第6章でこの原則を説明しました：最高
デザインは、テキストクラスが提供するものでした
汎用テキスト操作、操作中
ユーザーインターフェイスに固有（削除など）
選択）はユーザーインターフェイスに実装されました
モジュール。このアプローチは情報を排除しました
提示されたリークと追加のインターフェイス：\ work \ Kindle \ phil \ 149.png@@専門のユーザーがいる以前の設計では、
インターフェイス操作はテキストで実装されました
クラス。

 赤旗：繰り返し

同じコード（またはほぼ同じコード）の場合
同じ）何度も何度も現れます、それは
あなたが正しいものを見つけていないことを示す旗
abstractions.d：\ work \ Kindle \ phil \ 150.png @@ switch（connon-sopcode）{

ケースデータ：{
DataHeadersヘッダー=受信->getStartDataHleader>（：
if（header == NULL）{

LOG（警告、 "％sからのEsパケットが短すぎます（Zuバイト）"、
‘opcodeSynbol（comion-opcode）、
受信->送信者->tostring（）、
受信->len）;

戻る;

F

ケースGRANT：{
GrantHeadersヘッダー=受信->getStart<GrantHeader>（）;
if（header == NULL）{

LOG（WARNING、 "XsからのXsパケットが短すぎます（Suバイト）"、
‘opcodeSynbol（conmon-> opcode）、
受信->送信者->tostring（）、
受信->10）;

戻る;

ケースの再送：{
ResendHeader+ヘッダー=受信->getStart<ResendHeader>（）;
if（header == NULL）{

LOGCWARNING、「XからのKsパケットが短すぎます（Huバイト）」、
‘opcodeSynbol（comon-> opcode）、
受信->送信者->tostring（
受信->len）：

）cers
図9.1：このコードは着信ネットワークパケットを処理します
さまざまなタイプの;タイプごとに、パケットが短すぎる場合

そのタイプの場合、メッセージがログに記録されます。このバージョンのコードでは、
Locステートメントはいくつかの異なるパケットに対して複製されます

タイプ。

d：\ work \ Kindle \ phil \ 151.png @@スイッチ（comon-ropcode）￡
ケースデータ：{
DataHeader+ヘッダー=受信-sgetStartDataHeader>Q;
if（header = MULL）
‘goto packetTooshort;
ケースGRANT：￠
‘GrantHeader+ヘッダー=受信->getStart <GrantHeader>（）;
if（header = NULL）
goto packetTooshort;
ケースRESEND：{
Resendieadersヘッダー=受信-sgetStart<ResendHeader>（）：
if（header == NULL）
‘goto packetTooShort;

3

acketTooshore：

LOGCWARNING、「SisからのSsパケットが短すぎます（Suバイト）」、
‘opcodeSymbol（conmon-> opcode）
受信->送信者->tostring（）、
受信->10）;

戻り値

図9.2：図9.1からのコードの再編成
Locステートメントのコピーは1つだけです。

9.5例：挿入カーソルと

選択
次のセクションでは、次の2つの例について説明します。
上記の原則を説明します。の中に
最初の例最良のアプローチは、
関連するコード。 2番目の例では
それらを一緒に結合する方が良いです。

最初の例は挿入で構成されています
カーソルとGUIエディタプロジェクトでの選択
第6章から。エディタに点滅が表示されます
によって入力されたテキストの場所を示す垂直線
ユーザーがドキュメントに表示されます。また、
テキストのコピーまたは削除に使用されるselection、d：\ work \ Kindle \ phil \152.png@@と呼ばれる強調表示された文字範囲。 The
挿入カーソルは常に表示されますが、
テキストが選択されていない場合。選択した場合
存在する場合、挿入カーソルは常にに配置されます
その一端。

選択カーソルと挿入カーソルは関連しています
いくつかの点で。たとえば、カーソルは常に
選択範囲の一方の端に配置され、
カーソルと選択は操作される傾向があります
一緒に：マウスをクリックしてドラッグすると、両方が設定されます
それらの、そしてテキスト挿入は最初に選択されたものを削除します。
テキストがある場合は、に新しいテキストを挿入します
カーソル位置。したがって、を使用することは論理的に見えるかもしれません
選択との両方を管理する単一のオブジェクト
カーソル、および1つのプロジェクトチームがこのアプローチを採用しました。
オブジェクトは、ファイルに2つの位置を格納しました。
どちらの端がカーソルであったかを示すブール値
選択が存在したかどうか。

ただし、結合されたオブジェクトは扱いにくいものでした。
なぜなら、それはより高いレベルのコードには何の利益ももたらさなかったからです。
高レベルのコードはまだ知っておく必要がありました
選択とカーソルを別個のエンティティとして、
そしてそれはそれらを別々に操作しました（テキストの間に
挿入、それは最初に結合されたメソッドを呼び出しました。
選択したテキストを削除するオブジェクト。それからそれは呼び出されました
カーソル位置を取得する別の方法ind：\ work \ Kindle \ phil \ 153.png @@新しいテキストを挿入する順序）。結合されたオブジェクトは
実際には、分離するよりも実装が複雑です
オブジェクト。カーソル位置をとして保存することを避けました
別のエンティティですが、代わりにブール値を格納する必要がありました
選択のどちらの端が
カーソル。カーソル位置を取得するために、
結合されたオブジェクトは、最初にブール値をテストする必要があり、
次に、選択の適切な端を選択します。
この場合、選択とカーソルはそうではありませんでした
それらを組み合わせるのに十分に密接に関連しています。いつ
選択を分離するためにコードが改訂され、
カーソル、使用法と実装の両方
シンプルになりました。個別のオブジェクトが提供されます
からの結合オブジェクトよりも単純なインターフェイス
どの選択とカーソル情報が必要でしたか
抽出されます。カーソルの実装も
カーソル位置が
間接的にではなく、直接表現される
選択とブール値。実際、改訂版では
バージョンどちらにも特別なクラスは使用されていません
選択またはカーソル。代わりに、新しいポジション
クラスは、の場所を表すために導入されました
ファイル（行番号と行内の文字）。 The
選択は2つのポジションで表されました
1つのカーソル。ポジションは他の用途も見つけました

プロジェクトで。この例は、低レベルであるがより汎用的なthed：\ work \ Kindle \ phil \154.png@@の利点も示しています。
第6章で説明したインターフェイス。

 レッドフラッグ：スペシャル-
一般的な混合物5

この危険信号は、汎用の場合に発生します
メカニズムには、専用のコードも含まれています
そのメカニズムの特定の使用。これにより
メカニズムはより複雑になり、
メカニズム間の情報漏えい
および特定のユースケース：将来の変更
ユースケースに変更が必要になる可能性があります
基礎となるメカニズムも同様です。

9.6例：ロギング用の個別のクラス

2番目の例には、エラーロギングが含まれていました。
学生プロジェクト。クラスにはいくつかのコードが含まれていました

次のようなシーケンス：
試す {

rpcConn = connectionPoo！ .getConnection（dest）;
} catch（IOException e）{

NetworkErrorLogger.logRpcOpenError（req、dest、e）;

nullを返す;d：\ work \ Kindle \ phil \ 155.png @@エラーをログに記録するのではなく、
それが検出されました、特別なエラーの別の方法
ロギングクラスが呼び出されました。エラーロギングクラス
同じソースファイルの最後に定義されています：

プライベート静的クラスNetworkErrorLogger{
ええ

エラーthに関連する出力情報

発生時
しようとすると

RPCを送信するための接続を開きます。

@param req
送信されたはずのRPCリクエスト
終えた

接続

@param dest
*RPCの宛先
@param e
キャッチされたエラー
は
public static void logRpcOpenError（RpcRequest req、

AddrPortTuple dest、例外e）{

ジョガー。 1og（Level.WARNING、 "メッセージを送信できません：

+ req +

。 \n"4"への接続が見つからないか開くことができません

dest +

+ e）;

}
含まれているNetworkErrorLoggerクラス

logRpcSendErrorやd：\ work \ Kindle \ phil \ 156.png @@ logRpcReceiveErrorなどのいくつかのメソッドで、それぞれが異なるログを記録しました
一種のエラー。

この分離により、複雑さが増しました。
利点。ロギング方法は浅かった：ほとんど
1行のコードで構成されていましたが、
かなりの量のドキュメント。各
メソッドは1か所でのみ呼び出されました。 The
ロギング方法は彼らに大きく依存していました
呼び出し：呼び出しを読んでいる人は
ほとんどの場合、ロギングメソッドに切り替えて作成します
正しい情報が記録されていることを確認してください。
同様に、ロギングメソッドを読んでいる人
おそらく呼び出しサイトにめくります
メソッドの目的を理解します。

この例では、削除する方がよいでしょう
ロギング方法とロギングの配置
エラーが発生した場所でのステートメント
検出されました。これにより、コードが簡単になります
に必要なインターフェイスを読んで削除します

ロギングメソッド。

9.7分割と結合の方法

いつ細分化するかという問題は、
クラスだけでなく、メソッドにも：
既存のメソッドを複数に分割する方が良いです：\ work \ Kindle \ phil \ 157.png @@小さいメソッド？または、2つの小さな方法が必要です
1つの大きなものに結合されますか？長い方法
短いよりも理解しにくい傾向があります
もの、非常に多くの人々は長さだけが

メソッドを分割するための適切な理由。
クラスの生徒には、厳格な基準が与えられることがよくあります。
「20行より長いメソッドを分割してください！」など。

ただし、長さ自体が正当な理由になることはめったにありません
メソッドを分割するため。一般的に、開発者
メソッドを分割しすぎる傾向があります。分割
メソッドは追加のインターフェースを導入します。
複雑さを増します。また、の部分を分離します
コードを難しくする元の方法
作品が実際に関連しているかどうかを読んでください。すべきではない
全体的にならない限り、メソッドを分割します
よりシンプルなシステム。これがどのように発生するかについて説明します
下。

長い方法は必ずしも悪いとは限りません。例えば、
メソッドに次の20行のブロックが5つ含まれているとします。
順番に実行されるコード。ブロックが
比較的独立している場合、メソッドは
一度に1つのブロックを読んで理解しました。あります
各ブロックを移動してもあまりメリットはありません
別の方法に。ブロックが複雑な場合
相互作用、それらを維持することはさらに重要です
一緒にすると、読者はすべてのコードを一度に見ることができます; d：\ work \ Kindle \ phil \ 158.png @@各ブロックが別々のメソッドにある場合、読者は
これらのスプレッドの間を行ったり来たりする必要があります-
それらがどのように機能するかを理解するためにメソッドを出します
一緒。の数百行を含むメソッド
単純な署名があり、
読みやすいです。これらの方法は深いです（たくさん
機能性、シンプルなインターフェース）、これは良いことです。

[Ges] aes]

インターフェイス>om

私| |
実装>}i|わたしは

 4 \

！ |

7大胆に動作します）（避けてください！）
L_ |

（a）（b）（c）（a）

図9.3：メソッド（a）は、
サブタスク（b）またはその機能を2つの別々に分割することによって
メソッド（c）。結果が生じる場合、メソッドを分割しないでください

（d）のような浅い方法。

メソッドを設計する場合、最も重要なのは
目標は、クリーンな抽象化を提供することです。それぞれの方法
1つのことを実行し、それを完全に実行する必要があります。 The
メソッドはシンプルなインターフェースを持つ必要があります。
ユーザーは多くの情報を持っている必要はありません
それを正しく使用するために彼らの頭。方法
深くする必要があります：そのインターフェイスは多くある必要があります
その実装よりも簡単です。メソッドが：\ work \ Kindle \ phil \ 159.png @@これらすべてのプロパティを持っている場合、おそらくそうではありません
長いかどうかは関係ありません。

メソッドを分割することは、次の場合にのみ意味があります。
全体として、よりクリーンな抽象化が実現します。三
これを行うには2つの方法があります。
図9.3で。最良の方法は、
図に示すように、サブタスクを別のメソッドに変換します
9.3（b）。サブディビジョンは子メソッドになります
サブタスクと親メソッドを含む
元のメソッドの残りを含みます。
親が子を呼び出します。のインターフェース
新しい親メソッドは元のメソッドと同じです
方法。この形式の細分化は、次の場合に意味があります。
からきれいに分離できるサブタスクがあります
元のメソッドの残りの部分、つまり（a）
子メソッドを読んでいる人は必要ありません
親メソッドについて何かを知り、
（b）親メソッドを読んでいる人は
の実装を理解する必要があります
子メソッド。通常、これは子供が
方法は比較的一般的です-pur

ポーズ：それは可能性があります
おそらく他の方法で使用されます
親。このフォームを分割してから
自分がの間を行ったり来たりしているのを見つけてください
親と子がどのように機能したかを理解する：\ work \ Kindle \ phil \ 160.png @@一緒に、それは危険信号です（「結合されたメソッド」）
分割はおそらく悪い考えだったことを示しています。

メソッドを分割する2番目の方法は、分割することです
2つの別々のメソッドに分けられ、それぞれが発信者に表示されます
図9.3（c）のように、元の方法のこれ
元の方法が過度にあった場合は理にかなっています
複数を実行しようとしたため、複雑なインターフェイス
密接に関連していないもの。これが
場合によっては、メソッドを分割できる可能性があります
機能を2つ以上の小さなメソッドに変換します。
それぞれがオリジナルの一部しか持っていません
メソッドの機能。このように分割すると、
結果として得られる各メソッドのインターフェース
オリジナルのインターフェースよりもシンプルでなければなりません
方法。理想的には、ほとんどの発信者は
2つの新しいメソッドのいずれかを呼び出す。発信者の場合
新しいメソッドの両方を呼び出す必要があります。
複雑さが増すため、
分割は良い考えです。新しいメソッドは
彼らが何をするかにもっと焦点を合わせます。それは良い兆候です
新しい方法は、
オリジナルの方法（つまり、それらを使用することを想像できます
他の状況では個別に）。

図9.3（c）に示されている形式の分割は、
発信者になるため、非常に頻繁に意味があります
d：\ work \ Kindle \ phil \ 161.png@@oneの代わりに複数のメソッドを処理する必要があります。このように分割すると、リスクが発生します
のように、いくつかの浅い方法で終わる
図9.3（d）。発信者がそれぞれを呼び出す必要がある場合
別々のメソッド、状態を前後に渡す
それらの間で、分割することは良い考えではありません。
図のような分割を検討している場合
9.3（c）、あなたはそれがそれであるかどうかに基づいてそれを判断する必要があります
発信者のために物事を簡素化します。

システムができる状況もあります
メソッドを結合することで、より簡単になります。
たとえば、結合メソッドは2つを置き換える可能性があります
1つのより深い方法による浅い方法;かもしれない
コードの重複を排除します。それは排除するかもしれません
元のメソッド間の依存関係、
または中間データ構造。結果として生じる可能性があります
より良いカプセル化で、その知識は
以前は複数の場所に存在していましたが、現在は
一箇所に隔離されています。またはそれは結果になるかもしれません
セクション9.2で説明したように、より単純なインターフェイス。

 危険信号：結合されたメソッド

それぞれの方法を理解できるはずです
独立して。理解できない場合
alsodなしの1つのメソッドの実装：\ work \ Kindle \ phil \ 162.png @@別のメソッドの実装を理解し、
それは危険信号です。この危険信号は、

他のコンテキストも同様です：2つのコードの場合

物理的に分離されていますが、それぞれは
他を見て理解すると、それは赤です
国旗。

9.8別の意見：クリーンコード

「CleanCode」という本の中で、RobertMartinは次のように主張しています。
関数は長さに基づいて分割する必要があります
1人。彼は、機能は非常にあるべきだと言います
短く、10行でも長すぎます。

関数の最初のルールは、それらが
小さいはずです。関数の2番目のルール
それよりも小さくする必要があるということです...ブロック
ifステートメント内、elseステートメント、while
ステートメントなどは1行の長さにする必要があります。
おそらく、その行は関数呼び出しである必要があります...
これはまた、関数がすべきではないことを意味します
ネストされた構造を保持するのに十分な大きさである。
したがって、関数のインデントレベル
1つまたは2つを超えてはなりません。これは、ofd：\ work \ Kindle \ phil \ 163.png @@コースで、関数を読みやすくし、
理解する。

私は、より短い機能が一般的にあることに同意します
長いものよりも理解しやすいです。でも、
関数が数十行に達すると、
サイズをさらに縮小する可能性は低いです。
読みやすさに大きな影響を与えます。より重要な
問題は次のとおりです。関数を分割すると、
システムの全体的な複雑さ？言い換えると、
いくつかの短い関数を読みやすく、
彼らがどのように連携するかを理解する
1つの大きな関数を読みますか？より多くの機能は意味します
文書化して学習するためのより多くのインターフェース。機能する場合
小さくなりすぎると、独立性が失われます。
その結果、読み取る必要のある結合された関数が生成されます
一緒に理解しました。これが起こったとき、
より大きな関数を維持する方が良いので、
関連するコードは1か所です。深さはより重要です
長さよりも：最初に関数を深くしてから、
読みやすいように短くしてください。しないでください
長さのために深さを犠牲にします。

9.9結論

モジュールを分割するか結合するかの決定は、複雑さに基づいて次のようになります。\ work \ Kindle \ phil \164.png@@。その構造を選択してください
最高の情報隠蔽、最小の情報をもたらします
依存関係、および最も深いインターフェイス。

4clean Code、Robert C. Martin、Pearson Education、Inc.、
マサチューセッツ州ボストン2009d：\ work \ Kindle \ phil \165.png@@第10章

存在しないエラーを定義する

例外処理は最悪の1つなので

のurces
ソフトウェアシステムの複雑さ。取引するコード
特別な条件で行うことは本質的に困難です
通常の場合を扱うコードよりも書く、

開発者は多くの場合、例外を定義せずに
それらがどのように扱われるかを考慮します。これ

この章では、例外が寄与する理由について説明します
複雑さに不釣り合いに、それからそれは示します
例外処理を簡素化する方法。全体的な鍵
この章からの教訓は、
例外を処理する必要がある場所。いくつかの
操作のセマンティクスを変更できる場合
通常の動作ですべての状況を処理できるようにします
報告すべき例外的な条件はありません
（したがって、この章のタイトル）d：\ work \ Kindle \ phil \ 166.png@@10.1例外が複雑さを増す理由
例外という用語は、一般的でないものを指すために使用します
制御の通常の流れを変える条件
プログラムで。多くのプログラミング言語
を可能にする正式な例外メカニズムを含める
下位レベルのコードによってスローされる例外と
コードを囲むことによってキャッチされます。ただし、例外
正式な例外を使用しなくても発生する可能性があります
メソッドの場合などのレポートメカニズム
しなかったことを示す特別な値を返します
通常の動作を完了します。これらすべての形式
例外は複雑さの原因になります。

特定のコードが遭遇する可能性があります
いくつかの異なる方法での例外：

+発信者が悪い引数を提供したり、
構成情報。

+呼び出されたメソッドはできない場合があります
要求された操作を完了します。例えば、
I / O操作が失敗するか、必須
リソースが利用できない場合があります。

-配布されていないシステム、ネットワークパケット
紛失または遅延する可能性がありますが、サーバーはそうではない可能性があります
タイムリーに対応するか、同僚が
予期しない方法で通信します。d：\ work \ kindle \ phil \ 167.png @@ +コードは、内部のバグを検出する可能性があります
不整合、またはそうではない状況
処理する準備をしました。

大規模なシステムは多くを処理する必要があります
例外的な条件、特に
分散されているか、フォールトトレラントである必要があります。例外
取り扱いはすべてのかなりの部分を占めることができます
システム内のコード。

例外処理コードは本質的にもっと
通常の場合のコードよりも書くのは難しい。アン
例外は、コードの通常のフローを中断します。
これは通常、何かが次のように機能しなかったことを意味します
予期され、操作を完了できません
予定通り。例外が発生すると、
プログラマーは2つの方法でそれを扱うことができます、それぞれ
そのうち複雑になる可能性があります。最初のアプローチ
前進して作業を完了することです
例外にもかかわらず進歩。たとえば、
ネットワークパケットが失われると、再送される可能性があります。データの場合
破損している、おそらくそれはから回復することができます
冗長コピー。 2番目のアプローチは中絶することです
進行中の操作と例外の報告
上向き。ただし、中止は複雑になる可能性があります
ある時点で例外が発生した可能性があるため
システム状態に一貫性がない場合（データ構造
部分的に初期化されている可能性があります）;例外：\ work \ Kindle \ phil \ 168.png @@処理コードは、次のように一貫性を復元する必要があります
例外の前に行われた変更の巻き戻し
発生した。

さらに、例外処理コードは
より多くの例外の機会。考えます
失われたネットワークパケットを再送する場合。多分
パケットは実際には失われていませんが、単に失われました
遅延。この場合、パケットを再送すると
重複したパケットがピアに到着します。
これにより、新しい例外的な条件が導入されます
ピアが処理する必要があります。または、ケースを検討してください
冗長コピーから失われたデータを回復する方法：
冗長コピーも失われた場合はどうなりますか？
リカバリ中に発生する二次例外
多くの場合、
主な例外。例外がによって処理される場合
進行中の操作を中止する場合、これは
別の例外として発信者に報告されます。に
例外の終わりのないカスケードを防ぎ、
開発者は最終的に処理する方法を見つける必要があります
より多くの例外を導入せずに例外。

例外の言語サポートは
冗長で不格好であるため、例外が発生します
読みにくいコードの処理。たとえば、
次のコードは、Javaのオブジェクトのサポートを使用してファイルからd：\ work \ Kindle \ phil \169.png@@ツイートのコレクションを読み取ります。

シリアル化と逆シリアル化：
試す
FileInputStream fileStream =
new FileInputStream（fi1leName）;
BufferedInputStream bufferedStream =
new BufferedInputStream（fileStream）;
ObjectInputStream objectStream =

new ObjectInputStream（bufferedStream）;
df

for（int i = 0; i <tweetsPerFile; i ++）{

tweets.add（（Tweet）objectStream.readObject（））;

+
catch（FileNotFoundException e）{

+
catch（ClassNotFoundException e）{

+
catch（EOFException e）{

//問題ありません：すべてのツイートファイルがいっぱいになっているわけではありません

//ツイートのセット。
+
catch（IOException e）{

+
catch（ClassCastException e）{

}
基本的なトライキャッチボイラープレートだけが

通常の場合のコードよりも多くのコード行：\ work \ Kindle \ phil \ 170.png @@操作（コードを考慮しなくても）
実際に例外を処理します。するのは難しい
関連する

通常の例外処理コード-
ケースコード：たとえば、それぞれがどこにあるかは明確ではありません
例外が生成されます。別のアプローチは
コードを多くの異なるtryブロックに分割します。
極端な場合、各行を試すことができます
例外を生成する可能性のあるコードの。これは
例外が発生する場所を明確にしますが、試してみてください
ブロック自体がコードのフローを分割し、
読みにくくします。さらに、いくつかの例外
処理コードが複数に重複してしまう可能性があります
ブロックを試してください。

例外処理を確実にすることは困難です
コードは実際に機能します。いくつかの例外、
I / Oエラー、テストで簡単に生成できない
環境なので、そのコードをテストするのは難しいです
それらを処理します。例外はあまり頻繁に発生しません
システムを実行しているため、例外処理コードはめったにありません
実行します。バグは長い間検出されないままになる可能性がありますが、
そして、例外処理コードが最終的に
必要な場合は、機能しない可能性があります
（私の好きなことわざの1つ：「
実行されません」）。

最近の調査によると、
分散データ集約型：\ work \ Kindle \ phil \ 171.png @@システムでの壊滅的な障害は、誤ったエラー処理が原因でした。
例外処理コードが失敗した場合、
発生頻度が低いため、問題をデバッグします。

10.2例外が多すぎる

プログラマーは関連する問題を悪化させます
不要なものを定義して例外処理する
例外。ほとんどのプログラマーはそれが
エラーを検出して報告することが重要です。彼らはしばしば
これは、「検出されたエラーが多いほど、
よりいい。"これは過防御なスタイルにつながります
少しでも疑わしいと思われるもの
例外を除いて拒否され、その結果、

不必要な例外の急増
システムの複雑さを増します。

私は自分でこの間違いをしました
Tclスクリプト言語。 Tclには未設定が含まれています
変数を削除するために使用できるコマンド。

unsetを定義したので、次の場合にエラーがスローされます。
変数は存在しません。当時私はそれを考えました
誰かが変数を削除しようとするとバグになるはずです
それは存在しないので、Tclはそれを報告する必要があります。でも、
unsetの最も一般的な使用法の1つは、クリーニングすることです
以前に作成された一時的な状態をアップ
手術。特に操作の場合、whatd：\ work \ Kindle \ phil \172.png@@状態が作成されたことを正確に予測するのは難しいことがよくあります。
途中で中止しました。したがって、最も単純なこと
可能性のあるすべての変数を削除することです
作成されました。未設定の定義は
これは厄介です：開発者は、
エラーをキャッチして無視するには、catchステートメントの設定を解除します
unsetによってスローされます。振り返ってみると、
unsetコマンドは私が犯した最大の間違いの1つです
Tclのデザインで作られました。

取引を避けるために例外を使用したくなる
困難な状況で：
それを処理するためのクリーンな方法、ただ例外をスローし、
問題を発信者にパントします。一部の人は主張するかもしれません
このアプローチにより、発信者に権限が与えられます。
異なる方法で例外を処理する各呼び出し元
仕方。ただし、理解に問題がある場合
特定の状況に対して何をすべきかについては、
発信者が何をすべきかわからない可能性が高い
また。次のような状況で例外を生成する
これは問題を他の誰かに渡すだけで、
システムの複雑さが増します。

クラスによってスローされる例外は、
そのインターフェース;多くの例外があるクラスには
複雑なインターフェースであり、より浅い
例外の少ないクラス。例外は
インターフェイスの特に複雑な要素。それはできます：\ work \ Kindle \ phil \ 173.png @@は、前にいくつかのスタックレベルを伝播します
捕らえられるので、メソッドだけでなく影響します
発信者だけでなく、潜在的に高レベルの発信者（および
それらのインターフェース）。

例外をスローするのは簡単です。それらの取り扱いは
難しい。したがって、例外の複雑さが発生します
例外処理コードから。するための最良の方法
例外によって引き起こされる複雑さのダメージを減らす
取り扱いは場所の数を減らすことです
例外を処理する必要があります。この残りの部分
この章では、削減するための4つの手法について説明します。
例外ハンドラーの数。

10.3存在しないエラーを定義する

例外処理を排除するための最良の方法
複雑さは、APIを定義して

処理する例外はありません：からエラーを定義します
存在。これはいけにえのように見えるかもしれませんが、
実際には非常に効果的です。 Tclが設定されていないことを考慮してください
上記のコマンド。投げるのではなく
unsetが不明なものを削除するように求められたときのエラー
変数、それは単になしで戻るべきでした
何かをして。私は変更する必要があります
わずかに設定解除の定義：削除するのではなく

変数を設定解除すると、変数nod：\ work \ Kindle \ phil \174.png@@が長く存在するようになります。最初の定義では、unsetはできません
変数が存在しない場合はその仕事をするので、
例外は理にかなっています。 2番目で
定義、それは設定されていないために完全に自然です

なれ
呼び出されない変数の名前で呼び出されます
存在。この場合、その作業はすでに完了しているので、
単に戻る。エラーケースはもうありません
報告する。

10.4例：Windowsでのファイル削除

ファイルの削除は、その方法の別の例を提供します
エラーを定義することができます。動作しているWindows
システムは、ファイルが削除されている場合、削除を許可しません
プロセスで開きます。これは継続的な情報源です
開発者とユーザーのフラストレーション。そうするには
使用中のファイルを削除するには、ユーザーは検索する必要があります
システムを介して、
ファイルを開き、そのプロセスを強制終了します。時々
ユーザーはシステムをあきらめて再起動します。
ファイルを削除できます。

Unixオペレーティングシステムはファイル削除を定義します
よりエレガントに。 Unixでは、ファイルが開いているときに開いている場合
削除された場合、Unixはファイルをすぐに削除しません。
代わりに、ファイルに削除のマークを付けてから、
削除操作は正常に戻ります。次の名前のファイル：\ work \ Kindle \ phil \ 175.png @@はそのディレクトリから削除されたため、他のファイルは削除されていません
プロセスは、古いファイルと新しいファイルを次のように開くことができます。
同じ名前を作成できますが、既存のファイル
データは存続します。すでにファイルを持っているプロセス
openは、引き続き読み取りと書き込みを行うことができます。
すべてのアクセスによってファイルが閉じられたら
プロセス、そのデータは解放されます。

Unixのアプローチでは、2つの異なるものを定義しています
エラーの種類。まず、削除操作はもうありません
ファイルが現在使用中の場合はエラーを返します。 the
削除は成功し、ファイルは最終的に
削除されました。次に、使用中のファイルを削除しても、
ファイルを使用してプロセスの例外を作成します。
この問題への1つの可能なアプローチは
ファイルをすぐに削除し、すべてにマークを付けます
それらを無効にするためのファイルのオープン。あらゆる試み
削除されたものを読み書きする他のプロセスによって
ファイルは失敗します。ただし、このアプローチは
それらのプロセスが処理する新しいエラーを作成します。
代わりに、Unixではファイルへのアクセスを継続できます
通常は;ファイルの削除を遅らせることはエラーを定義します
存在しない。

Unixがプロセスを許可するのは奇妙に思えるかもしれません
運命のファイルの読み取りと書き込みを続行しますが、
私はこれがこのような状況に遭遇したことはありません
重大な問題を引き起こしました。 Unixの定義d：\ work \ Kindle \ phil \ 176.png @@ファイルの削除は、どちらの場合もはるかに簡単に操作できます。
開発者とユーザー、Windowsの定義よりも。

10.5例：Javaサブストリングメソッド

最後の例として、Java文字列クラスについて考えてみましょう。
およびその部分文字列メソッド。与えられた2つのインデックス

文字列に変換すると、substringはsubstringを返します
最初のインデックスで指定された文字から開始
直前の文字で終わる
2番目のインデックス。ただし、いずれかのインデックスが外部にある場合
文字列の範囲、次に部分文字列がスローされます
IndexOutOfBoundsException。この例外は
不要であり、これの使用を複雑にします
方法。私はよく自分が
インデックスの一方または両方が範囲外である可能性があります
文字列の、そして私はすべてを抽出したいと思います
指定された文字列と重複する文字列
範囲。残念ながら、これは私がチェックする必要があります
各インデックスをゼロに切り上げるか、
文字列の最後まで。 1行方式
呼び出しは5〜10行のコードになります。

Javaの部分文字列メソッドはより簡単になります
この調整を自動的に実行した場合に使用します。
そのため、次のAPIを実装しました。
indexed：\ work \ Kindle \ phil \ 177.png @@がbeginIndex以上で、以下の文字列の文字（存在する場合）
endIndex。」これはシンプルで自然なAPIであり、
IndexoutOfBoundsException例外を定義します
存在しない。メソッドの動作は次のようになりました
インデックスの一方または両方が
負の場合、またはbeginIndexがendIndexより大きい場合。
このアプローチにより、メソッドのAPIが簡素化されます
その機能を増やしながら、それは
より深い方法。他の多くの言語が取っています
エラーのないアプローチ。たとえば、Python
範囲外のリストスライスに対して空の結果を返します。
Jがエラーを定義することを主張するとき
存在、人々は時々その投げに反対します
エラーはバグをキャッチします。エラーがから定義されている場合
存在、それはバグの多いソフトウェアになりませんか？
おそらくこれが、Java開発者が決定した理由です
その部分文字列は例外をスローする必要があります。エラー-
完全なアプローチはいくつかのバグをキャッチするかもしれませんが、それはまた
複雑さが増し、他のバグが発生します。
エラーの多いアプローチでは、開発者は次のように書く必要があります
エラーを回避または無視するための追加のコード、および
これにより、バグが発生する可能性が高くなります。または、彼らはかもしれません
追加のコードを書くのを忘れてください。その場合
実行時に予期しないエラーがスローされる場合があります。の
対照的に、存在しないエラーを定義すると、次のように簡略化されます：\ work \ Kindle \ phil \ 178.png @@ APIと、必要なコードの量が削減されます
書かれました。

全体として、バグを減らすための最良の方法は、
よりシンプルなソフトウェア。

10.6マスクの例外

数を減らすための2番目のテクニック

例外を処理しなければならない場所の

例外マスキングです。この承認で

ach、an
例外的な状態が検出され、処理されます

システムの低レベルで、より高いレベルで

ソフトウェアの状態を認識する必要はありません。
例外マスキングは特に一般的です
分散システム。たとえば、ネットワークで
TCPなどのトランスポートプロトコル、パケットは
破損や
混雑。 TCPは、再送によってパケット損失をマスクします
実装内でパケットが失われたため、すべてのデータ
最終的には通り抜け、クライアントは気づいていません
ドロップされたパケット。

マスキングのさらに物議を醸す例が発生します
NFSネットワークファイルシステムで。 NFSファイルサーバーの場合
クラッシュするか、何らかの理由で応答しない、クライアント
サーバーへのリクエストを何度も再発行します
問題が最終的に解決されるまで、もう一度。d：\ work \ Kindle \ phil \179.png@@クライアントの低レベルのファイルシステムコード

呼び出しに対して例外を報告しません
応用。進行中の操作（したがって
アプリケーション）は、操作ができるようになるまでハングします
正常に完了します。ハングが以上続く場合
短時間、NFSクライアントはメッセージを
「NFSサーバーxyzzynot
まだ試みている応答。」

NFSユーザーは、次のような事実について不満を言うことがよくあります。
NFSの待機中にアプリケーションがハングする
サーバーは通常の操作を再開します。多くの人々
NFSは操作を中止する必要があることを示唆しています
ぶら下がるのではなく例外を除いて。でも、
例外を報告すると事態はさらに悪化しますが、
良くない。アプリケーションでできることはあまりありません
ファイルにアクセスできなくなった場合。 1つの可能性は
アプリケーションがファイル操作を再試行するために、
しかし、これでもアプリケーションがハングし、
で1か所で再試行を実行する方が簡単です
すべてのファイルシステムではなく、NFSレイヤー
すべてのアプリケーションを呼び出します（コンパイラはすべきではありません）
これについて心配する必要があります！）。他の選択肢
アプリケーションが中止してエラーを返すためのものです
彼らの発信者。発信者がそうする可能性は低いです
どちらかを知っているので、彼らは次のように中止します
その結果、ユーザーのworking：\ work \ Kindle \ phil \180.png@@環境が崩壊します。ユーザーはまだ何も取得できません
ファイルサーバーがダウンしている間に行われた作業、およびそれら
すべてのアプリケーションを一度再起動する必要があります
ファイルサーバーが復活しました。

したがって、最良の代替策は、NFSがマスクすることです。
エラーが発生し、アプリケーションがハングします。このアプローチでは、
アプリケーションは、処理するためのコードを必要としません
サーバーの問題、およびそれらはシームレスに再開できます
サーバーが復活したら。ユーザーが疲れたら
待っている間、彼らはいつでもアプリケーションを中止することができます
手動で。

例外マスキングはすべてでは機能しません
状況、しかしそれは状況で強力なツールです
それが機能する場所。以来、より深いクラスになります
クラスのインターフェースを減らします（例外が少なくなります）
ユーザーが知っておくべき）そして機能を追加する
例外をマスクするコードの形式で。
例外マスキングはプルの例です
下向きの複雑さ。

10.7例外の集約

複雑さを軽減するための3番目の手法
例外に関連するのは例外の集約です。 The
例外集約の背後にある考え方は、処理することです
単一のコードで多くの例外。むしろ：\ work \ Kindle \ phil \181.png@@多くの個人のために別個のハンドラーを書くよりも
例外は、それらすべてを1か所で処理します。
シングルハンドラー。

不足しているパラメータを処理する方法を検討してください
Webサーバー。 Webサーバーはコレクションを実装します
URLの。サーバーが着信を受信したとき
URL、URL固有のサービスメソッドにディスパッチします
そのURLを処理し、応答を生成します。 The
URLには、以下に使用されるさまざまなパラメータが含まれています
応答を生成します。各サービスメソッドは
下位レベルのメソッド（getParameterと呼びましょう）
URLから必要なパラメータを抽出します。
URLに目的のパラメータが含まれていない場合は、
getParameterは例外をスローします。

ソフトウェア設計クラスの学生が
そのようなサーバーを実装しました、それらの多くは
getParameterinaへの個別の呼び出しをラップしました
NoSuchParameterをキャッチするための個別の例外ハンドラー
図10.1のような例外。これは大きな結果になりました
ハンドラーの数、これらはすべて本質的に
同じこと（エラー応答を生成します）。d：\ work \ Kindle \ phil \ 182.png @@ディスパッチャー：

oo￠
nandieurtc。 95
デルスfC。）f
ハンドテ2G。 .95
ペレiPゴフ
handtevrt3￠。 3;
pels ih G23
）。
ハンドラーハンドラーを処理する
ty C uy t try
getParaneter（ "photo 44"）gerParameterC * user id "）getParaneter（" Togin "）
3ガッチ（nosuchvaraneter e）￠ | | y catch（NoSuchParameter）（|| 1 ca％ch（NosuchParaneter e）￠
> 1、
wt tet
get Parameter（nessage "）gotParameverc password"）
4} Gatch（oSuchParaneter @）} Gatch WosuchParaneter e）（
a 2

図10.1：上部のコードはいくつかのコードの1つにディスパッチします
Webサーバーのメソッド。それぞれが特定のメソッドを処理します。
URL。これらの各メソッド（下）は、
着信HTTPリクエスト。この図では、別のものがあります
getParameterの各呼び出しの例外ハンドラー。これにより、

重複したコード。

より良いアプローチは、集約することです

例外。
個人の例外をキャッチする代わりに
サービスメソッド、それらをまで伝播させます
Webサーバーのトップレベルのディスパッチ方法。
図10.2で。このメソッドの単一のハンドラー
すべての例外をキャッチし、生成することができます
欠落しているパラメーターに対する適切なエラー応答。

集約アプローチも採用できます
さらにWebの例で。沢山あります
cand：\ work \ Kindle \ phil \183.png@@がWebページの処理中に発生するパラメータの欠落以外のその他のエラー。例えば、

パラメータの構文が正しくない可能性があります（
サービスメソッドは整数を期待していましたが、値は
「xyz」でした）、またはユーザーに権限がない可能性があります
要求された操作に対して。いずれの場合も、エラー
エラー応答が発生するはずです。エラーは異なります
応答に含めるエラーメッセージのみ
（「パラメータ「数量」がURLに存在しない」または

「数量」パラメータの「不正な値」xyz。でなければなりません
正の整数"）。したがって、結果として生じるすべての条件

エラー応答では、単一で処理できます
トップレベルの例外ハンドラー。エラーメッセージ

例外が発生したときに生成できます
スローされ、例外に変数として含まれます
記録;たとえば、getParameterは
「パラメータ「数量」がURLに存在しません」というメッセージ。
トップレベルハンドラーはからメッセージを抽出します
例外とそれをエラーに組み込む

response.d：\ work \ Kindle \ phil \ 184.png @@ディスパッチャー：

試す （
テット
ハンドラ
C2の場合は失敗します。）
handleurl2G
yelse if（...）
handteurt3￠..
} else if C ..）

mH
￠
は
q

ああ

5
）catch（NoSuchParaneter e）（
エラー応答を送信します。

3

andleUrit handleUn2：handleUrl：

‘getParancter（-photo_ia°）] [---getParaneterCuser1°][-、。 getParaneter（ログイン "）
51 getParameter（ "nessage"）I getParaneter（ "password"）

図10.2：このコードは機能的に図と同等です
10.1、ただし例外処理が集約されました：単一
ディスパッチャの例外ハンドラは、すべての
すべてのURL固有のNoSuchParameter例外
メソッド。

前に説明した集約
段落は、観点から優れた特性を持っています
カプセル化と情報隠蔽の。トップ-
レベルの例外ハンドラーは知識をカプセル化します
エラー応答を生成する方法についてですが、
特定のエラーについては何も知りません。それはただ使用します
例外で提供されるエラーメッセージ。 The
getParameterメソッドは知識をカプセル化します
URLからパラメータを抽出する方法について、および
また、抽出エラーを説明する方法も知っています
人間が読める形式で。これらの2つの部分
情報の数は密接に関連しているので、同じ場所にあることを意味します：\ work \ Kindle \ phil \185.png@@。でも、
getParameterは、構文について何も知りません。
HTTPエラー応答。新しい機能が追加されると
Webサーバーに、getParameterのような新しいメソッド
独自のエラーで作成される可能性があります。新しい場合
メソッドは、と同じ方法で例外をスローします
getParameter（継承する例外を生成することにより
同じスーパークラスからのエラーを含む
各例外のメッセージ）、彼らはプラグインすることができます
他に変更のない既存のシステム：トップ-
レベルハンドラーは自動的にエラーを生成します
それらのための応答。

この例は、一般的に役立つことを示しています
例外処理のデザインパターン。システムの場合
一連のリクエストを処理する場合、定義すると便利です
現在のリクエストを中止し、クリーンアップする例外
システムの状態を上げて、次の状態に進みます
リクエスト。例外は1か所でキャッチされます
システムのリクエスト処理の上部近く
ループ。この例外はいつでもスローできます
リクエストを中止するリクエストの処理中。
例外のさまざまなサブクラスを定義できます
さまざまな条件で。このタイプの例外
例外と明確に区​​別する必要があります
これはシステム全体にとって致命的です。d：\ work \ Kindle \ phil \ 186.png @@例外の集約は、次の場合に最適に機能します。
例外はスタックのいくつかのレベルに伝播します
処理される前。これにより、より多くの例外が許可されます
同じで処理されるより多くのメソッドから
場所。これは、例外マスキングの反対です。
マスキングは通常、例外が
低レベルの方法で処理されます。マスキングの場合、
低レベルのメソッドは、通常、使用されるライブラリメソッドです。
他の多くの方法で、例外を許可する
伝播することは場所の数を増やすでしょう
それが処理される場所。マスキングと集約
両方のアプローチが位置するという点で類似しています
最も多くキャッチできる例外ハンドラー
例外、多くのハンドラーを排除します
それ以外の場合は作成する必要があります。

例外集約の別の例
RAMCloudストレージシステムで発生します
クラッシュリカバリ。 RAMCloudシステムはで構成されています
複数を保持するストレージサーバーのコレクション
各オブジェクトのコピー。システムが回復できるようにします
さまざまな失敗から。たとえば、サーバーの場合
クラッシュしてすべてのデータ、RAMCloudを失います
に保存されているコピーを使用して、失われたデータを再構築します
他のサーバー。エラーは、より小さなものでも発生する可能性があります
規模;たとえば、サーバーが次のことを検出する場合があります。

n
個々のオブジェクトが破損しています。d：\ work \ Kindle \ phil \ 187.png@@RAMCloudには個別のリカバリがありません
さまざまな種類のエラーごとのメカニズム。
代わりに、RAMCloudは多くの小さなエラーを「促進」します
より大きなものに。 RAMCloudは、原則として、
破損したオブジェクトを復元して処理します
バックアップコピーからのオブジェクト。しかし、それはしません
これ。代わりに、破損したオブジェクトを検出した場合は
オブジェクトを含むサーバーをクラッシュさせます。 RAMCloud
クラッシュリカバリは非常に優れているため、このアプローチを使用します
複雑で、このアプローチは数を最小限に抑えました
しなければならなかったさまざまな回復メカニズムの
作成した。クラッシュした場合の回復メカニズムの作成
サーバーは避けられなかったので、RAMCloudは
他の種類の回復のための同じメカニズム
良い。これにより、コードの量が減りました
書かれるべきであり、それはまたサーバーがクラッシュすることを意味しました
リカバリはより頻繁に呼び出されます。その結果、バグ
回復中は発見される可能性が高く、
修繕。

破損したものを宣伝することの1つの欠点
サーバークラッシュへのオブジェクトは、コストが増加することです
かなり回復の。これは問題ではありません
RAMCloud、オブジェクトの破損は非常にまれであるため。
ただし、エラーの昇格は意味をなさない場合があります
頻繁に発生するエラー。一例として、itd：\ work \ Kindle \ phil \ 188.png @@は、サーバーをいつでもクラッシュさせるのは実用的ではありません。
そのネットワークパケットの一部が失われます。

例外についての1つの考え方
集約は、それがいくつかの特別なものを置き換えることです-
それぞれが
特定の状況、単一の汎用
複数の状況を処理できるメカニズム。
これは、の利点の別の図を提供します
汎用メカニズム。

10.8ただクラッシュしますか？

複雑さを軽減するための4番目の手法
例外処理に関連するのは、クラッシュすることです。
応用。ほとんどのアプリケーションでは、
処理する価値のない特定のエラー。
通常、これらのエラーは困難または不可能です
処理し、あまり頻繁に発生しません。もっとも単純な
これらのエラーに対応して行うことは、印刷することです
診断情報を入力してから中止します
応用。

1つの例は、「メモリ不足」エラーです。
ストレージの割り当て中に発生します。考えます
Cのmalloc関数。これができない場合はNuLLを返します。
必要なメモリブロックを割り当てます。これは
不幸な振る舞い。d：\ work \ Kindle \ phil \ 189.png@@mallocのすべての呼び出し元がリターンをチェックすることを前提としているため
価値があり、ない場合は適切な措置を講じる
メモリー。アプリケーションには多数の呼び出しが含まれています

mallocに変換するため、呼び出しのたびに結果を確認します
かなり複雑になります。プログラマーの場合
チェックを忘れて（かなり可能性が高いです）、

アプリケーションはnullポインタを逆参照します

メモリが不足し、クラッシュが発生した場合
本当の問題をカモフラージュします。

さらに、アプリケーションはあまりありません
メモリが使い果たされていることを発見したときに実行できます。
原則として、アプリケーションは
不要なメモリを解放しますが、アプリケーションの場合
すでに持っている可能性のある不要なメモリがありました
それを解放しました。
そもそもメモリエラー。今日のシステム
あまりにも多くのメモリを持っているので、メモリはほとんどありません
なくなります;もしそうなら、それは通常のバグを示しています
アプリケーション。したがって、試してみるのはほとんど意味がありません
メモリ不足エラーを処理するため。これも作成します
メリットが少なすぎるため、複雑さが増します。

より良いアプローチは、新しいメソッドを定義することです
mallocを呼び出すckallocは結果をチェックし、
エラーメッセージでアプリケーションを中止します
メモリが使い果たされた場合。アプリケーションは決して
mallocを直接呼び出します。常にckalloc.d：\ work \ Kindle \ phil \ 190.png@@を呼び出します。C++やJavaなどの新しい言語では、
メモリが
疲れ果てた。捕まえる意味はあまりない
この例外は、
例外ハンドラーもメモリの割り当てを試みますが、
これも失敗します。動的に割り当てられたメモリ
現代のそのような基本的な要素です
意味をなさないアプリケーション
メモリが使い果たされた場合に続行するアプリケーション。これは
エラーが検出されたらすぐにクラッシュすることをお勧めします。

エラーの例は他にもたくさんあります。
アプリケーションをクラッシュさせることは理にかなっています。ほとんどの場合
プログラム、読み取り中にI/Oエラーが発生した場合または
開いているファイルの書き込み（ディスクハードエラーなど）、または
ネットワークソケットを開くことができない場合は、
アプリケーションが回復するためにできることの多くは、中止する
明確なエラーメッセージを表示するのが賢明なアプローチです。
これらのエラーはまれであるため、発生する可能性はほとんどありません。
アプリケーションの全体的なユーザビリティに影響を与えます。
エラーメッセージで中止することも適切です
アプリケーションで次のような内部エラーが発生した場合
一貫性のないデータ構造として。のような条件
これはおそらくプログラムのバグを示しています。

オナを墜落させてもいいかどうか
特定のエラーはアプリケーションによって異なります。のために

複製されたストレージシステム、適切ではありませんtod：\ work \ Kindle \ phil \ 191.png @@ I/Oエラーで中止します。代わりに、システムは

複製されたデータを使用して再

あらゆる情報をカバーする

それは失われました。回復メカニズムは

プログラムにかなりの複雑さを追加しますが、
失われたデータの回復は価値の重要な部分です
システムはユーザーに提供します。

10.9行き過ぎ

例外を定義する、またはそれらをマスクする
モジュール内では、例外が発生した場合にのみ意味があります
モジュールの外部では情報は必要ありません。これ
この章の例には当てはまりました。
TclunsetコマンドとJavaサブストリングメソッド。
発信者が気にするまれな状況では
例外によって検出された特別な場合、
この情報を取得するための他の方法。

ただし、この考えを行き過ぎてしまう可能性があります。
ネットワーク通信のモジュールでは、学生
チームはすべてのネットワーク例外をマスクしました：ネットワークの場合
エラーが発生し、モジュールがそれをキャッチし、破棄し、
何の問題もないかのように続けました。これ
モジュールを使用するアプリケーションが持っていたことを意味します
メッセージが失われたのかピアなのかを知る方法はありません
サーバーに障害が発生しました。この情報がなければ、
堅牢なアプリケーションを構築することは不可能です。 thisd：\ work \ Kindle \ phil \ 192.png @@の場合、モジュールが公開することが不可欠です。
例外は、複雑さを増しますが
モジュールのインターフェース。

他の多くの分野と同様に、例外を除いて
ソフトウェア設計では、何を決定する必要があります
重要であり、重要ではないもの。もの
重要ではないものは隠すべきであり、
それらの多くはより良いです。しかし、何かが
重要なのは、それを公開する必要があることです（第21章
このトピックについて詳しく説明します）。

10.10結論

あらゆる形式の特殊なケースでは、コードが難しくなります
バグを理解し、その可能性を高めます。
この章では、例外に焦点を当てました。
特殊なケースのコードの最も重要なソースの
場所の数を減らす方法について話し合った
例外を処理する必要がある場合。するための最良の方法
これを行うには、セマンティクスを再定義してエラーを排除します
条件。定義できない例外の場合
離れて、あなたはマスクする機会を探す必要があります
それらは低レベルであるため、影響は限定的です。
複数の特殊なケースのハンドラーを1つに集約します
より一般的なハンドラー。一緒に、これらのテクニック：\ work \ Kindle \ phil \193.png@@はシステム全体に大きな影響を与える可能性があります
複雑。

1DingYuanet。 al。、「簡単なテストで防ぐことができます
最も重大な障害：本番環境の分析
分散データ集約型システムの障害」、2014年
オペレーティングシステムの設計とに関するUSENIX会議

Implementation.d：\ work \ Kindle \ phil \194.png@@

第11章 2回デザインする

ソフトウェアの設計は難しいので、
モジュールを構築する方法についての最初の考えまたは
システムは最高のデザインを生み出します。あなたは結局
複数を考慮すると、はるかに良い結果が得られます
主要な設計決定ごとのオプション：設計する
2回。

次のようなクラスを設計しているとします。
GUIテキストエディタのファイルのテキストを管理します。 The
最初のステップは、クラスが使用するインターフェースを定義することです
残りの編集者に提示します。選ぶのではなく
頭に浮かぶ最初のアイデア、いくつか考えてみてください
可能性。 1つの選択肢は、回線指向のインターフェイスです。
全体を挿入、変更、削除する操作
テキストの行。別のオプションは、インターフェースベースです
個々の文字の挿入と削除について。

3番目の選択肢は、文字列指向のインターフェイスです。
任意の範囲の文字で動作する可能性があります
クロスライン境界。ピンダウンする必要はありません：\ work \ Kindle \ phil \195.png@@各選択肢のすべての機能。で十分です
この点で、最も重要ないくつかをスケッチします
メソッド。

根本的なアプローチを選択してみてください
互いに異なる;あなたはそれをもっと学ぶでしょう
仕方。確かに1つしかない場合でも
合理的なアプローチ、2番目の設計を検討する
とにかく、どんなに悪くても。それ
の弱点について考えることは有益になります
そのデザインとそれらの機能との対比
他のデザイン。

のデザインを大まかにした後
代替案、の長所と短所のリストを作成します
各自。の最も重要な考慮事項
インターフェイスは、高レベルのソフトウェアにとって使いやすいものです。
上記の例では、両方の行指向
インターフェイスと文字指向のインターフェイス
を使用するソフトウェアで追加の作業が必要になります
テキストクラス。回線指向のインターフェースには
中にラインを分割して結合するためのより高いレベルのソフトウェア
次のような部分行および複数行の操作
選択範囲を切り取って貼り付けます。キャラクター-
指向性インターフェースを実装するにはループが必要になります
複数を変更する操作
キャラクター。他の要因も考慮する価値があります：d：\ work \ Kindle \ phil \ 196.png @@+1つの代替案はよりシンプルなインターフェースを持っていますか
別のものより？テキストの例では、すべての
テキストインターフェイスは比較的単純です。

+1つのインターフェースはより汎用的です
別？

+1つのインターフェースでより効率的になりますか
別のものよりも実装？本文中
たとえば、文字指向のアプローチ
大幅に遅くなる可能性がありますt

ハン
その他、別の呼び出しが必要なため
各文字のテキストモジュール。

代替設計を比較したら、
あなたは、を識別するためのより良い立場になります
最高のデザイン。最良の選択は、
代替案、またはあなたができることを発見するかもしれません
複数の選択肢の機能を組み合わせて
オリジナルのどれよりも優れている新しいデザイン
選択肢。

時々、選択肢のどれも
特に魅力的です。これが発生した場合は、
追加のスキームを考え出すことができます。使用する
オリジナルで特定した問題
新しい設計を推進するための代替案。もしあなたが
テキストクラスを設計し、
行指向および文字指向のアプローチ、
より高いレベルのソフトウェアが必要なため、それぞれの選択肢がisd：\ work \ Kindle \ phil \197.png@@ぎこちないことに気付くかもしれません。
追加のテキスト操作を実行します。それは
赤旗：テキストクラスがある場合は、
すべてのテキスト操作を処理します。そうするには
追加のテキスト操作を排除し、
テキストインターフェイスは、より厳密に一致する必要があります
より高いレベルのソフトウェアで発生する操作。
これらの操作は必ずしも単一に対応するとは限りません
文字または1行。この一連の推論
テキスト用の範囲指向のAPIにつながるはずです。
これにより、以前の問題が解消されます
デザイン。

デザイン・イット・ツースの原則は、次の場所で適用できます。
システムの多くのレベル。モジュールの場合、次を使用できます
説明されているように、最初にインターフェイスを選択するこのアプローチ
その上。その後、あなたがいるときにそれを再び適用することができます
実装の設計：テキストクラスの場合、
次のような実装を検討するかもしれません
行のリンクリスト、固定サイズの文字ブロック、
または「ギャップバッファ」。目標は異なります
インターフェイスよりも実装：
実装、最も重要なこと
シンプルさとパフォーマンスです。それも便利です
でより高いレベルで複数の設計を探索する
の機能を選択するときなどのシステム
ユーザーインターフェイス、またはsystemd：\ work \ Kindle \ phil \198.png@@

を主要なモジュールに分解する場合。いずれの場合も、
いくつかを比較できる場合は、最良のアプローチを特定します
代替案。

2回設計するのに多くの時間をかける必要はありません
延長時間。クラスなどの小さなモジュールの場合、
あなたは1時間か2時間以上を必要としないかもしれません
代替案を検討してください。これは少量です
あなたがする日または週と比較した時間の
クラスの実装に費やします。初期設計
実験はおそらくかなりの結果になるでしょう
より良いデザイン、それは時間の代償以上のものになります
それを2回設計するのに費やしました。より大きなモジュールの場合は、
初期の設計調査により多くの時間を費やし、
ただし、実装にも時間がかかり、
より良い設計の利点も高くなります。

デザイン・イット・ツースの原則に気づきました
本当に賢い人にとっては難しいこともあります
擁する。彼らが成長しているとき、賢い
人々は彼らの最初の簡単なアイデアが
良い成績を得るにはどんな問題でも十分です。がある
2番目または3番目の可能性を考慮する必要はありません。
これは悪い仕事の習慣をもたらす傾向があります。でも、
これらの人々が年をとるにつれて、彼らはに昇進します
ますます困難な問題を抱える環境。
最終的に、誰もがあなたの
最初のアイデアはもはや十分ではありません。必要に応じて
：\ work \ Kindle \ phil \ 199.png @@

本当に素晴らしい結果を得るには、次のことを検討する必要があります。
関係なく、2番目の可能性、またはおそらく3番目の可能性
あなたはどれほど頭がいいか。大規模なソフトウェアの設計
システムはこのカテゴリに分類されます：誰も良い人はいない
彼らの最初の試みでそれを正しくするのに十分です。

残念ながら、私はよく賢い人を見かけます
に来る最初のアイデアを実装することを主張する
心、そしてこれは彼らが彼らのパフォーマンスを下回る原因になります
真の可能性（それはまた彼らを苛立たせます
と連携）。おそらく彼らは無意識のうちに信じています
「賢い人は最初にそれを正しく理解する」ので、
彼らは複数のデザインを試します
結局のところ賢くない。これはそうではありません。それではありません
あなたは賢くない。問題は本当に
難しい！さらに、それは良いことです。
あなたがいる難しい問題に取り組むのがもっと楽しく
簡単な問題ではなく、慎重に考える必要があります
まったく考える必要がない場所です。

デザイン・イット・ツースのアプローチは改善するだけではありません
あなたのデザインだけでなく、それはあなたのデザインを改善します
スキル。考案して比較するプロセス
複数のアプローチがあなたに
デザインを良くしたり悪くしたりする要因。以上
時間、これはあなたが悪いことを除外するのをより簡単にするでしょう
デザインして本当に素晴らしいものに磨きをかけます。
d：\ work \ Kindle \ phil \200.png@@

第12章

なぜコメントを書くのですか？
4つの言い訳

コード内のドキュメントは、
ソフトウェア設計。コメントはに不可欠です

開発者がシステムを理解して作業するのを支援する
効率的に、しかしコメントの役割は超えています
これ。ドキュメントも重要な役割を果たします
抽象化における役割;コメントなしではできません
複雑さを隠します。最後に、書くプロセス
コメント、もし
正しく行われ、実際に
システムの設計を改善します。 逆に、良い
ソフトウェア設計は、それが不十分である場合、その価値の多くを失います
文書化。

残念ながら、この見方は普遍的ではありません
共有。 プロダクションコードのかなりの部分
基本的にコメントは含まれていません。 多くの開発者
コメントは時間の無駄だと思います。 その他
コメントで値を確認しますが、どういうわけか決して
