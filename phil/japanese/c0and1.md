
- 
ジョン・オースターハウト

Red Flagsdの概要：\ work \ Kindle \ phil \011.png@@序文

人々は電子のためのプログラムを書いています
80年以上のコンピュータがあります
どのように驚くほどほとんど会話していません

それらのプログラムやどのような良いプログラムを設計するか
のように見えるはずです。かなりありました
ソフトウェア開発プロセスに関する議論
アジャイル開発や開発について
デバッガー、バージョン管理システムなどのツール、
カバレッジツールをテストします。もありました
プログラミング技術の広範な分析
オブジェクト指向プログラミングや
関数型プログラミング、およびデザインパターン
およびアルゴリズム。これらの議論はすべて
価値はありますが、ソフトウェア設計の中心的な問題は
まだほとんど手つかずです。デイビッドパーナスの古典的な論文
「分解システムで使用される基準について
モジュールに」は1971年に登場しましたが、
ソフトウェア設計の芸術はあまり進歩していません
その後の45年間でその論文を超えて。d：\ work \ Kindle \ phil \012.png@@コンピュータの最も根本的な問題
科学は問題の分解です：取る方法
複雑な問題とそれを細かく分割する
それは独立して解決することができます。問題
分解は、
プログラマーは毎日直面していますが、それでも
ここで説明されている作業、私はできませんでした
大学内の単一のクラスを特定する
問題の分解は中心的なトピックです。教えます
forループとオブジェクト指向プログラミング。
ソフトウェア設計。


また、品質には大きなばらつきがあります
プログラマーの間で生産性が向上しますが、
何が原因かを理解しようとはしませんでした
最高のプログラマーがはるかに優れているか、教える
私たちのクラスのそれらのスキル。私はいくつかと話しました
私は素晴らしいプログラマーだと思いますが、
それらのほとんどは特定の明確な表現が困難でした
彼らに彼らの利点を与える技術。たくさんの
人々は、ソフトウェア設計スキルは
教えられない生来の才能。しかし、そこに
傑出した科学的証拠のかなりの部分です
多くの分野でのパフォーマンスは、
生来の能力よりも質の高い実践（
たとえば、才能はジェフ・コルヴィンによって過大評価されています）.d：\ work \ Kindle \ phil \ 013.png @@長年、これらの問題は当惑し、
私を苛立たせた。ソフトウェアかどうか疑問に思いました
デザインを教えることができます、そして私はそれを仮定しました
デザインスキルは優れたプログラマーを分けるものです
平均的なものから。私は最終的に唯一のことを決定しました
これらの質問に答える方法は、
ソフトウェア設計のコースを教えます。結果はCSです
スタンフォード大学で190。このクラスで私は出しました
ソフトウェア設計の一連の原則。学生
その後、一連のプロジェクトに取り組み、同化する
原則を実践します。クラスはで教えられています
伝統的な英語の文章に似たファッション
クラス。英語のクラスでは、生徒は反復を使用します
ドラフトを作成し、フィードバックを取得し、
次に、書き直して改善します。 CS 190では、
学生は実質的なソフトウェアを開発します
ゼロから。次に、広範なコードを実行します
設計上の問題を特定するためのレビュー、および学生
問題を修正するためにプロジェクトを修正します。これにより、
学生は自分のコードをどのように改善できるかを確認します
設計原則の適用。

私は今、ソフトウェア設計のクラスを教えました
数回、そしてこの本はデザインに基づいています
クラスから浮かび上がった原則。 The
原則はかなり高レベルであり、
哲学的（「存在しないエラーを定義する」）、d：\ work \ Kindle \ phil \ 014.png @@なので、学生がアイデアを理解するのは難しい
抽象的に。生徒は書くことで最もよく学ぶ
コードを書き、間違いを犯し、そして彼らがどのように
間違いとその後の修正は、
原則。

この時点で、あなたは疑問に思うかもしれません：何
私は私がについてのすべての答えを知っていると思います
ソフトウェア設計？正直言って、私はしません。あった
私が学んだとき、ソフトウェア設計に関するクラスはありませんでした
プログラム、そして私は私に教えるためのメンターを持っていませんでした
設計原則。私がプログラミングを学んだとき、
コードレビューは事実上存在しませんでした。私の
ソフトウェア設計に関するアイデアは個人から生まれます
コードの作成と読み取りの経験。私の上に
キャリア私は約250,000行のコードを書きました
さまざまな言語で。私はチームで働いてきました
3つのオペレーティングシステムをゼロから作成しました。
複数のファイルおよびストレージシステム、インフラストラクチャ
デバッガー、ビルドシステム、GUIなどのツール
ツールキット、スクリプト言語、およびインタラクティブ
テキスト、図面、プレゼンテーションのエディタ

tations、および
集積回路。私が経験した道に沿って
大規模システムの問題と
さまざまな設計手法を試しました。の
さらに、私は他の人によって書かれたかなりの量のコード化された：\ work \ Kindle \ phil \ 015.png @@を読みました。これは、私を
良いものと悪いものの両方のさまざまなアプローチ。

このすべての経験から、私は抽出しようとしました
共通のスレッド、両方とも避けるべき間違いについて
と使用するテクニック。この本は反省です
私の経験の：ここで説明されているすべての問題
私が個人的に経験したものであり、
提案されたすべてのテクニックは私が使用したものです
私自身のコーディングで成功しました。

この本が最後の言葉になるとは思わない
ソフトウェア設計について;きっと価値があると思います
私が見逃したテクニック、そして私のいくつか
提案は悪い考えであることが判明するかもしれません
ロングラン。しかし、私はその本が
ソフトウェア設計についての会話を開始します。
この本のアイデアをあなた自身のものと比較してください
経験し、自分で決める
ここで説明するアプローチは実際に削減します
ソフトウェアの複雑さ。この本は意見記事です、
だから一部の読者は私の一部に同意しないでしょう
提案。同意しない場合は、理解してみてください
どうして。私はそのことについて聞くことに興味があります
あなたのために働く、うまくいかないこと、その他
あなたがソフトウェア設計について持っているかもしれないアイデア。私は願います
その後の会話が私たちを改善すること
ソフトウェア設計の集合的な理解。私はします：\ work \ Kindle \ phil \016.png@@これの将来の版で私が学んだことを取り入れます
本。

について私と通信するための最良の方法
本は次のアドレスに電子メールを送信することです：

software-design-book@googlegroups.com

特定のフィードバックを聞くことに興味があります
バグや提案などの本について
改善のため、そして一般的な考え
ソフトウェア設計に関連する経験。私
特に説得力のある例に興味がある
この本の将来の版で使用できます。最高の
例は重要な設計原理を示しています
段落で説明するのに十分簡単です
または2つ。他の人が何を見たいのなら
メールアドレスで言って参加
ディスカッションでは、Googleグループに参加できます
ソフトウェアデザインブック。

何らかの理由でソフトウェア設計書の場合
Googleグループは将来消滅するはずですが、
Webで私のホームページを検索します。含まれます
通信方法の更新された手順
本について。本関連のものは送らないでください

私の個人的な電子メールアドレスに電子メールを送信します。
d：\ work \ kindle \ phil \ 017.png@@
塩の粒でこの本。全体的な目標は
複雑さを軽減します。これはより重要です
ここで読んだ特定の原則やアイデア。もしも
あなたはこの本からアイデアを試してみて、それを見つけます
実際に複雑さを軽減するのではなく、
それを使い続ける義務があると感じます（しかし、私に知らせてください
あなたの経験について;フィードバックをお願いします
何が機能し、何が機能しないか）。

多くの人が批判をしたり、
本の質を向上させる提案。
以下の人々が有益なコメントを提供しました
本のさまざまなドラフトについて：Abutalib Aghayev、
ジェフ・ディーン、ウィル・デュケット、サンジャイ・ゲマワット、ジョン
ハートマン、ブライアン・カーニハン、ジェームズ・コッペル、エイミー
Ousterhout、Kay Ousterhout、Rob Pike、Partha
ランガナサン、ダニエルレイ、キースシュワルツ、アレックス
スナップ。 ChristosKozyrakisが用語を提案しました
クラスとインターフェースの「深い」と「浅い」、
以前の用語「厚い」と「薄い」を置き換えます。
やや曖昧でした。お世話になりました
CS190の学生。彼らを読むプロセス
コードとそれについて彼らと話し合うことは、
design.d：\ work \ Kindle \ phil \018.png@@

第1章についての私の考えを具体化する

序章
（複雑さがすべてです）

コンピュータソフトウェアを書くことは最も純粋なものの1つです
人類の歴史における創造的な活動。
プログラマーは実際的な制限に縛られません
物理法則など。エキサイティングなものを作ることができます
決して存在し得ない行動を伴う仮想世界
現実世界では。プログラミングは必要ありません
バレエや
バスケットボール。必要なプログラミングはすべてクリエイティブです
心とあなたの考えを整理する能力。

システムを視覚化できれば、おそらく
コンピュータプログラムでそれを実装します。

これは、
ソフトウェアを書くことは私たちが理解する能力です
私たちが作成しているシステム。プログラムが進化するにつれて、
より多くの機能を取得すると、複雑になり、
コンポーネント間に微妙な依存関係があります。d：\ work \ kindle \ phil \ 019.png @@時間の経過とともに複雑さが蓄積し、次のようになります。
プログラマーがすべてを維持することはますます難しくなっています
彼らが修正するときに彼らの心の関連する要因
システム。これにより開発が遅くなり、
バグにつながり、開発がさらに遅くなります
そしてそのコストに追加します。複雑さは必然的に増加します
プログラムの存続期間中。大きいほど
プログラム、そしてそれに取り組む人々が増えるほど、
複雑さを管理することはより困難です。

良いd
開発ツールは私たちが対処するのに役立ちます
複雑で、多くの優れたツールが作成されています
過去数十年にわたって。しかし、制限があります
ツールだけで何ができるか。作りたいなら
ソフトウェアを作成する方が簡単なので、ビルドできます
より強力なシステムをより安く、私たちは見つけなければなりません
ソフトウェアをよりシンプルにする方法。複雑さは
私たちの最善の努力にもかかわらず、時間の経過とともに増加し続けますが、
しかし、より単純な設計により、より大きく、
複雑になる前のより強力なシステム
圧倒的。

戦うための2つの一般的なアプローチがあります
複雑さ、どちらもこれで説明します
本。最初のアプローチは、複雑さを排除することです
コードをよりシンプルでわかりやすくすることによって。にとって
たとえば、以下を排除することで複雑さを軽減できます：\ work \ Kindle \ phil \ 020.png @@特殊なケース、または一貫性のある識別子を使用する
ファッション。

複雑さへの2番目のアプローチは
プログラマーが作業できるように、それをカプセル化します
すべてにさらされることなくシステム上で
その複雑さを一度に。このアプローチはと呼ばれます
モジュール設計。モジュール設計では、ソフトウェア
システムはクラスなどのモジュールに分割されます
オブジェクト指向言語で。モジュールは
互いに比較的独立するように設計されており、
プログラマーが1つのモジュールで作業できるようにする
他の詳細を理解する必要はありません
モジュール。

ソフトウェアは非常に順応性があるため、ソフトウェア
デザインは、全体にまたがる継続的なプロセスです
ソフトウェアシステムのライフサイクル。これはソフトウェアを作ります
物理的なデザインとは異なるデザイン
建物、船、橋などのシステム。
ただし、ソフトウェアの設計は必ずしもそうではありませんでした
このように見た。プログラミングの初期には、
デザインはしばしば最初に集中していました
他の工学分野と同様に、プロジェクト。
このアプローチの極限はウォーターフォールと呼ばれます
プロジェクトが個別に分割されたモデル
要件の定義、設計、
コーディング、テスト、およびメンテナンス。 waterfalled：\ work \ Kindle \ phil \ 021.png @@モデルでは、各フェーズは次のフェーズの前に完了します
フェーズが開始します。多くの場合、さまざまな人が
各フェーズを担当します。システム全体は
設計段階で一度に設計されます。 The
このフェーズの終わりに設計が凍結され、
後続のフェーズの役割は、肉付けして
その設計を実装します。

残念ながら、ウォーターフォールモデルはめったにありません
ソフトウェアに適しています。ソフトウェアシステムは
物理システムよりも本質的に複雑です。
大規模なデザインを視覚化することはできません
すべてを理解するのに十分なソフトウェアシステム
何かを構築する前にその意味の。として
その結果、初期設計には多くの問題があります。
問題は、
実装は順調に進んでいます。しかし
ウォーターフォールモデルは、対応するように構成されていません
この時点での主要な設計変更（たとえば、
デザイナーは他のプロジェクトに移った可能性があります）。
したがって、開発者は問題を回避しようとします
全体的なデザインを変更することなく。これにより、
複雑さの爆発。

これらの問題のため、ほとんどのソフトウェアは
今日の開発プロジェクトはインクリメンタルを使用しています
アジャイル開発などのアプローチでは、
初期設計では、thed：\ work \ Kindle \ phil \022.png@@全体の機能の小さなサブセットに焦点を当てています。このサブセットは設計されています、
実装され、評価されます。問題

オリジナルデザインで発見され、
修正された後、さらにいくつかの機能が設計され、
実装および評価。各反復は公開します
既存の設計の問題、

次の機能セットが設計される前に修正されました。に
このようにデザインを広げて、問題
初期設計は、システムが
まだ小さい;後の機能は経験から恩恵を受けます
以前の実装中に得られた
機能があるので、問題が少なくなります。

インクリメンタルアプローチはソフトウェアで機能します
ソフトウェアは十分に順応性があるため
途中で大幅な設計変更
実装。対照的に、主要な設計変更
物理システムにとってははるかに困難です。
たとえば、を変更することは実用的ではありません
真ん中の橋を支える塔の数
建設の。

インクリメンタル開発とは、ソフトウェアが
デザインは決して行われません。デザインは継続的に行われます
システムの存続期間中：開発者は常に
デザインの問題について考えています。増分
開発は、継続的な再設計も意味します。

システムまたはコンポーネントの初期設計はisd：\ work \ Kindle \ phil \023.png@@ほとんど最高のものではありません。必然的に経験
物事を行うためのより良い方法を示しています。ソフトウェアとして
開発者、あなたは常に目を光らせている必要があります
の設計を改善する機会のために
あなたが取り組んでいるシステム、そしてあなたは計画する必要があります
あなたの時間の一部をデザインに費やすことに
改善。

ソフトウェア開発者は常に
デザインの問題を考え、削減する
複雑さはの最も重要な要素です
ソフトウェア設計、そしてソフトウェア開発者はすべきです
常に複雑さについて考えています。この本i

s
複雑さを使用して設計をガイドする方法について
その生涯を通じてソフトウェア。

この本には2つの全体的な目標があります。最初は
ソフトウェアの複雑さの性質を説明する：何
「複雑さ」とは、なぜそれが重要なのか、
そして、プログラムがいつ持っているかをどのように認識できますか
不必要な複雑さ？本の2番目、そして
より挑戦的な、目標は技術を提示することです
ソフトウェア開発中に使用できます
複雑さを最小限に抑えるプロセス。不運にも、
保証する簡単なレシピはありません
素晴らしいソフトウェア設計。代わりに、
に隣接する高レベルの概念のコレクション
「クラスは深くする必要がある」などの哲学d：\ work \ Kindle \ phil \024.png@@または「存在しないエラーを定義する」。これらの概念
すぐに最適なデザインを特定できない場合がありますが、
それらを使用して、代替設計を比較できます
デザインスペースの探索をガイドします。

1.1この本の使い方

ここで説明する設計原則の多く

やや抽象的なので、難しいかもしれません
実際のコードを見ずに感謝します。それは持っています
小さな例を見つけるのは困難でした
本に含めるのに十分でありながら、十分な大きさ

実際のシステムの問題を説明するため（
良い例に出会ったら、私に送ってください）。
したがって、この本だけでは十分ではないかもしれません
原則を適用する方法を学びます。

この本を使用する最良の方法は、組み合わせることです
コードレビュー付き。他の人の
コード、それがに準拠しているかどうかを考えてください
ここで説明する概念と、それがどのように関連するか
コードの複雑さ。デザインが見やすい
自分のコード以外の誰かのコードの問題。
ここで説明されている危険信号を使用して、識別できます
問題と改善を提案します。レビュー
コードはまた、新しい設計アプローチにあなたをさらします
およびプログラミングtechniques.d：\ work \ Kindle \ phil \025.png@@デザインを改善するための最良の方法の1つ
スキルは、危険信号を認識することを学ぶことです。
コードの一部はおそらくより複雑です
する必要があります。この本の過程で私は
関連する問題を示唆する危険信号を指摘する
それぞれの主要な設計問題に。最も重要な
それらは本の最後に要約されています。君
次に、コーディング時にこれらを使用できます。
赤い旗を見て、立ち止まって別のデザインを探してください
それは問題を排除します。あなたが最初に試すとき
このアプローチでは、いくつかの設計を試す必要があるかもしれません
あなたが排除するものを見つける前に選択肢
赤旗。簡単に諦めないでください：より多くの選択肢
問題を解決する前に試してみると、より多くの
学びます。時間が経つにつれて、あなたはあなたのコードが
危険信号はますます少なくなり、あなたのデザインは
クリーナーとクリーナー。あなたの経験も表示されます
識別するために使用できる他の危険信号
設計上の問題（これらについて聞いてうれしいです）。

この本のアイデアを適用するとき、それは
節度と裁量を使用することが重要です。毎日
ルールには例外があり、すべての原則には
制限。デザインのアイデアを極限まで追求すると、
あなたはおそらく悪い場所に行き着くでしょう。美しい
デザインは、競合するアイデア間のバランスを反映しています
とアプローチ。いくつかの章にセクションがあります：\ work \ Kindle \ phil \ 026.png@@「Takingittoo far」というタイトルで、
あなたが良いことをやり過ぎているときを認識してください。

この本のほとんどすべての例は
JavaまたはC++、および議論の多くは用語に関するものです
オブジェクト指向言語でクラスを設計する方法。
ただし、このアイデアは他のドメインにも当てはまります。
メソッドに関連するほとんどすべてのアイデアは
なしの言語の関数にも適用されます
Cなどのオブジェクト指向機能。デザインのアイデア
クラス以外のモジュールにも適用されます。
サブシステムまたはネットワークサービス。

このような背景を踏まえて、さらに詳しく話し合いましょう
複雑さの原因とその作成方法の詳細
ソフトウェアシステム

simpler.d:\work\kindle\phil\027.png@@第2章

複雑さの性質

この本はソフトウェアを設計する方法についてです
複雑さを最小限に抑えるシステム。最初
ステップは敵を理解することです。まさに何
「複雑さ」とは？システムが
不必要に複雑ですか？システムの原因
複雑になりますか？この章ではそれらについて説明します
高レベルの質問;後続の章は
より低いレベルで複雑さを認識する方法を示します
レベル、特定の構造的特徴の観点から。

複雑さを認識する能力は
重要な設計スキル。それはあなたが識別することを可能にします
あなたがそれらに多くの努力を投資する前に問題、
そしてそれはあなたが中から良い選択をすることを可能にします
代替案。デザインが
シンプルなデザインを作成するよりもシンプルですが、一度
システムが複雑すぎることを認識できますが、
あなたはあなたのデザインを導くためにその能力を使うことができます
シンプルさへの哲学。デザインが表示された場合：\ work \ Kindle \ phil \ 028.png @@複雑な場合は、別のアプローチを試して、それがどうかを確認してください
簡単です。時間が経つにつれて、あなたは特定のことに気付くでしょう
テクニックはよりシンプルなデザインになる傾向がありますが、
他のものは複雑さと相関しています。

これにより、
よりシンプルなデザインをより迅速に作成できます。

この章では、いくつかの基本的な説明も行います
残りの基礎を提供する仮定
本の。後の章では、この資料を取り上げます
与えられた章とそれを使用してさまざまな

改良と結論。

2.1定義された複雑さ

この本の目的のために、私は「複雑さ」を定義します
実用的な方法で。複雑さは関連するものです
を作るソフトウェアシステムの構造に
システムを理解して変更するのは難しいです。
複雑さにはさまざまな形があります。たとえば、
コードの一部がどのように理解するのは難しいかもしれません
動作します。を実装するには多くの労力がかかる可能性があります
わずかな改善、またはどちらが明確でない可能性があります
システムの一部を変更して作成する必要があります

改善;修正するのは難しいかもしれません
別のものを導入せずにバグ。ソフトウェアの場合

システムを理解して変更するのは難しいので、それは
isd：\ work \ Kindle \ phil \029.png@@
複雑です。理解しやすく、修正しやすい場合は、
それなら簡単です。

複雑さは次の観点から考えることもできます
コストと利益。複雑なシステムでは、多くの時間がかかります
少しでも改善を実装するための作業の。
シンプルなシステムでは、より大きな改善が可能です
より少ない労力で実装されます。

複雑さは、開発者が経験することです
達成しようとする特定の時点
特定の目標。必ずしも
システムの全体的なサイズまたは機能。人々
多くの場合、「複雑」という言葉を使用して大規模な表現をします
洗練された機能を備えたシステムですが、そのような場合
システムは、目的のために、作業が簡単です。
この本の、それは複雑ではありません。もちろん、ほとんどすべて
大規模で洗練されたソフトウェアシステムは実際には
取り組むのが難しいので、彼らも私の定義を満たしています
複雑ですが、これは必ずしも必要ではありません
ケースになります。小さい場合も可能です
洗練されていないシステムは非常に複雑です。

複雑さは、次のような活動によって決まります。
最も一般的です。システムにいくつかの部分がある場合
非常に複雑ですが、それらの部分はほとんどありません
触れる必要がありますそして彼らは多くを持っていません
システムの全体的な複雑さへの影響。に
これを大まかな数学的方法で特徴付けます：d：\ work \ Kindle \ phil \ 030.png @@ C = Yeptp
？

システムの全体的な複雑さ（C）は
各部分の複雑さによって決定されるp（c、）
開発者が費やす時間の割合で重み付け
その部分に取り組んでいます（￠、）。複雑さを分離する
それが決して見られない場所はほとんど同じくらい良いです
複雑さを完全に排除するように。
複雑さは読者よりも明白です
作家。あなたがコードの一部を書いて、それが思われる場合
あなたにとっては単純ですが、他の人々はそれが複雑だと考えています、
それからそれは複雑です。あなたが自分自身を見つけたとき
このような状況では、他の状況を調査する価値があります
コードが複雑に見える理由を見つけるための開発者
彼らへ;おそらくいくつかの興味深いものがあります
あなたの間の切断から学ぶためのレッスン
意見と彼らの。開発者としてのあなたの仕事はそうではありません
簡単に操作できるコードを作成するだけで、
しかし、他の人も使用できるコードを作成する

簡単に。

2.2複雑さの症状

複雑さは、3つの一般的な方法で現れます。
以下の段落で説明されています。 Eachd：\ work \ Kindle \ phil \ 031.png @@これらの症状は、実行を困難にします
開発タスク。

変化の増幅：の最初の症状
複雑さは、一見単純な変更です
多くの異なるコードの変更が必要
場所。たとえば、次のようなWebサイトについて考えてみます。
それぞれがバナーを表示するいくつかのページ
背景色付き。多くの初期のWebサイトでは、
色は各ページで明示的に指定されています。
図2.1（a）に示すように。を変更するには
そのようなWebサイトの背景として、開発者は
既存のすべてのページを手動で変更する必要があります。これ
大規模なサイトではほぼ不可能です
数千ページ。幸いなことに、最新のWebサイト
図2.1（b）のようなアプローチを使用します。
バナーの色は中央の場所で一度指定されますが、
共有されたすべての個々のページ参照
価値。このアプローチでは、バナーの色は
Webサイト全体を1つで変更できます
変形。優れた設計の目標の1つは、
それぞれの影響を受けるコードの量を減らす
設計上の決定なので、設計変更は必要ありません
非常に多くのコード変更。

認知的負荷：の2番目の症状
複雑さは認知的負荷であり、これは
tod：\ work \ Kindle \ phil \032.png@@タスクを完了するために開発者が知る必要がある量。より高い認知負荷は
開発者は学習により多くの時間を費やす必要があります
必要な情報、そしてより大きな
何かを見逃したためにバグが発生するリスク
重要。たとえば、次の関数があるとします。

Cはメモリを割り当て、そのポインタを返します
メモリ、および発信者が解放すると想定します

想い出。これは、の認知的負荷に追加されます
関数を使用する開発者。開発者が失敗した場合
メモリを解放するために、メモリリークが発生します。
発信者が
しません

メモリの解放について心配する必要はありません
（メモリを割り当てる同じモジュールも
それを解放する責任を負います）、それは減少します
認知的負荷。認知的負荷はさまざまな方法で発生しますが、
多くのメソッドを備えたAPI、グローバル変数など
不整合、および間の依存関係
モジュール。

システム設計者は時々
複雑さは、コード行で測定できます。彼ら
1つの実装がより短い場合
別の場合、それはもっと単純でなければなりません。必要なだけなら
変更を加えるための数行のコード、次に
変更は簡単でなければなりません。ただし、このビューは無視します
認知的負荷に関連するコスト。私は見た
アプリケーションの記述を可能にするフレームワーク：\ work \ Kindle \ phil \ 033.png @@ほんの数行のコードで、しかしそれは非常に
それらの線が何であったかを理解するのは難しい。
より多くの行を必要とするアプローチ
コードの数が減るので、実際にはもっと簡単です

認知的負荷。
{[boxed [bg = buttonBg [bg = buttonBg
lemph ="cerkrea
gee p = buttonBp a​​ = baanerB
3SバナーBgバナーBg
24 fgater [bg = VancouverBg red [bg = BannerBg ed
ES
| FA
gees p = buttonBp fg = buttonB
レモン="サレア
u
fa）（b）te）

図2.1：Webサイトの各ページに色付きのバナーが表示されます。
（a）では、バナーの背景色が指定されています
各ページで明示的に。 （b）では、共有変数は
背景色と各ページはその変数を参照します。

（c）一部のページでは、強調するために追加の色が表示されます。
これは、バナーの背景色の暗い色合いです。もしも
背景色が変わると、強調色も変更する必要があります

変化する。

未知の未知数：の3番目の症状
複雑さは、どの部分が明確でないことです
タスクを完了するには、コードの数を変更する必要があります。

開発者が伝えなければならない情報
タスクを正常に実行します。図2.1（c）は、次のことを示しています。\ work \ Kindle \ phil \034.png@@この問題。 Webサイトは中央変数を使用しています
バナーの背景色を決定するので、
変更しやすいようです。ただし、いくつかのWeb
ページは背景色の暗い色合いを使用します
強調するために、そしてその暗い色が指定されています
個々のページで明示的に。背景の場合
色が変わると、強調色が必要になります
一致するように変更します。残念ながら、開発者は
これを実現する可能性は低いので、彼らは変更する可能性があります
更新せずに中央のbannerBg変数
強調色。開発者が知っている場合でも
問題、どのページがどのページを使用しているかは明らかではありません
強調色なので、開発者は検索する必要があるかもしれません
Webサイトのすべてのページ。

複雑さの3つの兆候のうち、
未知の未知数は最悪です。不明
不明とは、必要なものがあることを意味します
知ることはできますが、あなたが知る方法はありません
それが何であるか、あるいは問題があるかどうかさえ。君
あなたの後にバグが現れるまでそれについて知ることはありません
変える。変化の増幅は煩わしいです、
しかし、どのコードが必要かが明確である限り
変更された場合、システムは変更が行われると機能します
完成しました。同様に、高い認知負荷は
変更のコストを増やしますが、明確な場合は
読むべき情報、変更はまだ寝る可能性があります：\ work \ Kindle \ phil \035.png@@正解。未知数で、それは不明確です
何をすべきか、または提案された解決策が
仕事。確実にする唯一の方法は、すべてを読むことです
システム内のコード行。これは、
任意のサイズのシステム。これでも十分ではないかもしれませんが、
変更は微妙なデザインに依存する可能性があるため
文書化されなかった決定。

優れたデザインの最も重要な目標の1つ
システムが明白になるためです。これは反対です
高い認知負荷と未知の未知数の。
明らかなシステムでは、開発者はすぐに
既存のコードがどのように機能し、何を理解する
変更するにはが必要です。明らかなシステム
開発者が簡単に推測できるものです
何をすべきかについて、非常に一生懸命考えずに、そして
それでも、推測が正しいことを確信してください。章
18では、コードをさらに作成するための手法について説明しています
明らか。

2.3複雑さの原因

これで、高レベルの症状がわかりました

複雑さの理由と複雑さが生じる理由

ソフトウェア開発は難しい、次のステップは
複雑さの原因を理解して、
問題を回避するためのシステムを設計します。 Complexityd：\ work \ Kindle \ phil \ 036.png @@は、依存関係とあいまいさの2つが原因です。
このセクションでは、これらの要因について大まかに説明します。
以降の章では、それらがどのように関連するかについて説明します
下位レベルの設計上の決定。

この本の目的のために、依存関係
特定のコードが存在できない場合に存在します
単独で理解および変更された;コード
何らかの形で他のコードに関連し、他の
コードを検討および/または変更する必要がある場合
指定されたコードが変更されます。 Webサイトの例では
図2.1（a）の場合、背景色は
すべてのページ間の依存関係。すべての
ページは同じ背景を持つ必要があるので、
1ページの背景を変更してから、
それらすべてを変更する必要があります。もう一つの例
依存関係の数はnで発生します

etworkプロトコル。
通常、送信者には個別のコードがあります
プロトコルの受信機ですが、それぞれが必要です
プロトコルに準拠します。のコードを変更する
送信者はほとんどの場合、対応する必要があります
受信機で変更し、その逆も同様です。 The
メソッドのシグネチャは依存関係を作成します
そのメソッドの実装と
それを呼び出すコード：新しいパラメーターが追加された場合
toaメソッド、そのメソッドのすべての呼び出し
そのパラメータを指定するように変更する必要があります。d：\ work \ Kindle \ phil \037.png@@依存関係はの基本的な部分です
ソフトウェアであり、完全に排除することはできません。の
実際、依存関係を意図的に導入します
ソフトウェア設計プロセスの一部。毎回
依存関係を作成する新しいクラスを作成します
そのクラスのAPIの周り。ただし、
ソフトウェア設計の目標は、
依存関係と依存関係を作成するには
可能な限りシンプルで明白なままにします。

Webサイトの例を考えてみましょう。古いWebでは
背景が個別に指定されているサイト
各ページ、すべてのWebページはに依存していました
お互い。新しいWebサイトでこの問題が修正されました
中央に背景色を指定する
個々のページを配置してAPIを提供する
レンダリング時にその色を取得するために使用します。
新しいWebサイトは依存関係を排除しました
ページ間ですが、新しい依存関係が作成されました
背景色を取得するためのAPIの周り。
幸いなことに、新しい依存関係はより明白です。
個々のWebページが依存していることは明らかです
BannerBgの色で、開発者は簡単にできます
変数が使用されているすべての場所を検索します
その名前を探しています。さらに、コンパイラ
APIの依存関係を管理するのに役立ちます：

共有変数が変更され、コンパイルエラーが発生します：\ work \ kindle \ phil \ 038.png @@は、古い名前をまだ使用しているコードで発生します。 The
新しいWebサイトが非自明で困難なものに取って代わりました-
よりシンプルでより多くの依存関係を管理する
明らかなもの。

複雑さの2番目の原因は、あいまいさです。
重要な情報が
明確ではない。簡単な例は変数名です
それは非常に一般的であるため、あまり有用ではありません
情報（時間など）。または、
変数はその単位を指定しない可能性があるため、
見つける方法は、コードをスキャンして場所を探すことです
変数が使用されます。あいまいさはしばしば関連付けられます
依存関係がある場合、
依存関係が存在します。たとえば、新しいエラーの場合
ステータスがシステムに追加されると、次のことが必要になる場合があります
次の文字列メッセージを保持するテーブルにエントリを追加します
各ステータスですが、メッセージテーブルの存在
探しているプログラマーには明らかではないかもしれません
ステータス宣言時。矛盾もあります
あいまいさの主な原因：同じ変数の場合
名前は2つの異なる目的で使用されますが、
これらの目的のどれが開発者に明らかであるか
特定の変数が機能します。

多くの場合、あいまいさは次の理由で発生します
不十分な文書の;第13章お得な情報
このトピックで。ただし、あいまいさも設計されています：\ work \ Kindle \ phil \039.png@@問題。システムがクリーンで明白な設計である場合、
そうすれば、必要なドキュメントが少なくなります。の必要性
広範なドキュメントは、多くの場合、
デザインが正しくありません。減らすための最良の方法
あいまいさは、システム設計を単純化することによるものです。

一緒に、依存関係とあいまいさのアカウント
複雑さの3つの兆候のために
セクション2.2で説明されています。依存関係は
増幅と高い認知負荷を変更します。
あいまいさは未知の未知数を生み出し、また
認知的負荷に貢献します。デザインが見つかれば
依存関係を最小限に抑える手法と
あいまいさ、そして私たちはの複雑さを減らすことができます
ソフトウェア。

2.4複雑さは段階的

複雑さは、単一の壊滅的なものによって引き起こされるのではありません
エラー;それはたくさんの小さな塊に蓄積します。 A
単一の依存関係またはあいまいさは、それ自体ではありそうにありません
の保守性に大きく影響する
ソフトウェアシステム。複雑さが生じるのは
数百または数千の小さな依存関係と
あいまいさは時間の経過とともに蓄積されます。最終的には、
これらの小さな問題の多くは、可能な限り
システムへの変更は、それらのいくつかの影響を受けます。d：\ work \ Kindle \ phil \ 040.png @@複雑さの漸進的な性質により、
制御するのは難しい。自分に納得させるのは簡単です
あなたの現在によって導入された少しの複雑さ
変化は大したことではありません。ただし、すべての開発者が
すべての変更、複雑さに対してこのアプローチを採用
急速に蓄積します。複雑になると
蓄積された、修正するので、除去するのは難しい
単一の依存関係またはあいまいさは、それ自体では、
大きな違いを生む。成長を遅らせるために
複雑さの場合、「ゼロトレランス」を採用する必要があります
第3章で説明した哲学。

2.5結論

複雑さは、
依存関係とあいまいさ。複雑さとして
増加すると、変化の増幅につながります。

高い認知負荷、および未知の未知数。

その結果、より多くのコード変更が必要になります
イオン

それぞれの新機能を実装します。加えて、
開発者は十分な取得に多くの時間を費やします
安全に変更を行うための情報、および
最悪の場合、彼らはすべての情報を見つけることさえできません
彼らが必要とする。肝心なのは、その複雑さです
既存のものを変更することは困難で危険です
コードbase.d：\ work \ Kindle \ phil \041.png@@第3章

作業コードが十分ではありません

（戦略的プログラミングと戦術的プログラミング）

善の最も重要な要素の1つ
ソフトウェア設計は、あなたが
プログラミングタスクにアプローチします。多くの組織
取得することに焦点を当てた戦術的な考え方を奨励する
機能は可能な限り迅速に機能します。でも、
あなたが良いデザインを望むなら、あなたはもっと取る必要があります
時間を投資する戦略的アプローチ
きれいなデザインを作成し、問題を修正します。これ
この章では、戦略的アプローチの理由について説明します
より良いデザインを生み出し、実際にはより安い
長期的な戦術的アプローチよりも。

3.1戦術プログラミング

ほとんどのプログラマーはソフトウェアにアプローチします
私がタクティカルドと呼んでいる考え方での開発：\ work \ Kindle \ phil \042.png@@プログラミング。戦術的アプローチでは、あなたのメイン
焦点は、新しいものなど、何かを機能させることです
機能またはバグ修正。一見、これはそうです
完全に合理的：より重要なこと
動作するコードを書くよりも？ただし、戦術
プログラミングはほとんど不可能にします
優れたシステム設計を実現します。

戦術プログラミングの問題は
それは近視眼的です。戦術的にプログラミングしている場合は、
できるだけ早くタスクを完了しようとしています。
おそらくあなたには厳しい締め切りがあります。結果として、
将来の計画は優先事項ではありません。あなたはそうしない
最高のデザインを探すのに多くの時間を費やします。君
すぐに何かを動かしたいだけです。あなたが言う
少し複雑さを加えても大丈夫だと自分自身で
それが可能であれば、小さなクラッジを1つか2つ導入します
現在のタスクをより迅速に完了する必要があります。

これがシステムが複雑になる方法です。として
前の章で説明した複雑さ
インクリメンタルです。特別なことではありません
システムを複雑にしますが、蓄積
数十または数百の小さなものの。もし、あんたが
戦術的にプログラムし、各プログラミングタスクは
これらの複雑さのいくつかに貢献します。それぞれの
それらはおそらく合理的な妥協のようです
現在のタスクをすばやく完了するために。ただし、d：\ work \ Kindle \ phil \ 043.png @@複雑さは、特に次の場合に急速に蓄積されます。
誰もが戦術的にプログラミングしています。

やがて、いくつかの複雑さが始まります
問題を引き起こし、あなたはあなたを望み始めるでしょう
それらの初期の近道をとっていませんでした。しかし、あなたは
を取得することがより重要であることを自分に言い聞かせてください
戻ってリファクタリングするよりも機能する次の機能
既存のコード。リファクタリングは長い間役立つかもしれません
実行しますが、それは間違いなく現在を遅くします
タスク。したがって、回避するためのクイックパッチを探します
発生した問題。これはただより多くを作成します
複雑さ。その場合、より多くのパッチが必要になります。
すぐにコードは混乱しますが、この時点で
物事は非常に悪いので、数ヶ月の作業が必要になります
それをきれいにするために。あなたのスケジュールができる方法はありません
そのような遅延を許容し、1つまたは2つを修正します
問題はそれほど多くはないようです
違いがあるので、戦術的にプログラミングを続けます。

大規模なソフトウェアプロジェクトに取り組んだことがある場合
非常に長い間、あなたは戦術を見てきました
職場でのプログラミングと経験
結果として生じる問題。あなたが始めたら
戦術的な道、変えるのは難しい。

ほとんどすべてのソフトウェア開発
組織には少なくとも1人の開発者がいます
戦術的なプログラミングを極限まで追求します：ad：\ work \ Kindle \ phil \044.png@@戦術的な竜巻。戦術的な竜巻は多作です
コードをはるかに速く送り出すプログラマー
他のものですが、完全に戦術的な方法で動作します。いつ
クイック機能を実装することになると、誰も
戦術的な竜巻よりも速く完了します。の
一部の組織では、経営陣は戦術を扱います
ヒーローとしての竜巻。ただし、戦術的な竜巻
破壊の跡を残します。彼らはめったにありません
しなければならないエンジニアによって英雄と見なされます
将来的には彼らのコードで作業します。通常、その他
エンジニアは残された混乱を一掃しなければなりません

それを出現させる戦術的な竜巻によって
それらのエンジニア（本当のヒーロー）は
戦術的な竜巻よりも進行が遅い。

3.2戦略的プログラミング

良いソフトウェアになるための第一歩
設計者は、機能するコードはそうではないことを理解する必要があります
足りる。紹介することはできません
あなたを完成させるための不必要な複雑さ
現在のタスクが速くなります。最も重要なことは
システムの長期的な構造。ほとんど
どのシステムのコードも、
既存のコードベースなので、あなたの最も重要な仕事は
開発者はそれらの将来の拡張を容易にすることです。d：\ work \ Kindle \ phil \ 045.png @@したがって、「作業コード」を次のように考えるべきではありません。
もちろんあなたのコードですが、あなたの主な目標
働かなければならない。あなたの主な目標は、生産することでなければなりません
素晴らしいデザインで、これもうまくいきます。これは
s
戦略的プログラミング。

戦略的プログラミングには投資が必要です
考え方。最速の道を進むのではなく
現在のプロジェクトを完了するには、投資する必要があります
システムの設計を改善する時間。これらは
投資はあなたを少し遅くします
期間が、彼らは、として、長期的にあなたをスピードアップします
図3.1に示されています。

一部の投資は積極的に行われます。にとって
たとえば、見つけるのに少し余分な時間をかける価値があります
新しいクラスごとのシンプルなデザイン。それよりも
頭に浮かぶ最初のアイデアを実装し、
いくつかの代替デザインを試して、
最もきれいなもの。いくつかの方法を想像してみてください
将来的にシステムを変更する必要があるかもしれません
そしてそれがあなたのデザインで簡単になることを確認してください。
良いドキュメントを書くことは、の別の例です
積極的な投資。

その他の投資は事後対応型になります。どんなに
事前にいくら投資すれば、必然的に
設計上の決定に誤りがあります。時間とともに、
これらの間違いは明らかになります。 youd：\ work \ Kindle \ phil \ 046.png @@がデザインの問題を発見したときは、それを無視したり、無視したりしないでください。
その周りにパッチを当てます。それを修正するために少し余分な時間がかかります。もしも
あなたは戦略的にプログラムします、あなたは継続的になります
システム設計に小さな改善を加えます。
これは戦術的なプログラミングの反対であり、
あなたは継続的に少し複雑さを加えています

将来的に問題を引き起こします。

3.3いくら投資しますか？

それで、適切な投資額はどれくらいですか？ A

設計を試みるなどの巨額の先行投資
システム全体が効果的ではありません。これは
ウォーターフォール方式であり、機能しないことはわかっています。 The
理想的なデザインは、次のように少しずつ現れる傾向があります。
システムの経験を積むことができます。したがって、最高
アプローチは、に多くの小さな投資をすることです
継続的に。私は約10-20％を使うことを提案します
投資の総開発時間の。
この量は、影響を与えないほど十分に少ないです
あなたのスケジュールはかなり大きいですが、十分な大きさです
時間の経過とともに大きなメリットを生み出します。あなたの最初の
したがって、プロジェクトはそれらよりも10〜20％長くかかります
純粋に戦術的なアプローチになります。その余分な
時間はより良いソフトウェア設計につながります、そしてあなたは
数日以内にメリットを体験し始めます：\ work \ Kindle \ phil \047.png@@か月。開発するまでそう長くはかからないでしょう
あなたがする場合よりも少なくとも10〜20％速い

戦術的にプログラムしていました。この時点であなたの
投資は無料になります：あなたからの利益
過去の投資はカバーするのに十分な時間を節約します
将来の投資のコスト。あなたはすぐになります
初期投資のコストを回収します。図3.1
この現象を示しています。

図3.1：最初に、
プログラミングは、
戦略的アプローチ。ただし、複雑さは蓄積されます
戦術的アプローチの下でより迅速に
生産性。時間の経過とともに、戦略的アプローチの結果
より大きな進歩を遂げています。注：この図は、
定性的なイラスト;私は経験的なことを知りません

曲線の正確な形状の測定。

逆に、戦術的にプログラムする場合、
最初のプロジェクトは10〜20％速く完了しますが、
時間の経過とともに、開発速度は遅くなります。
複雑さが蓄積します。それほど長くはありません：\ work \ kindle \ phil \ 048.png @@プログラミングは少なくとも10〜20％遅くなります。君
あなたが節約したすべての時間をすぐに返します
最初に、そしてシステムの残りの寿命の間
あなたはあなたがいる場合よりもゆっくりと発達するでしょう
戦略的アプローチをとっていました。まだの場合
ひどく劣化したコードベースで働いたことがある、
持っている人;彼らはあなたにその貧弱なコードを教えてくれるでしょう
品質は開発を少なくとも20％遅くします。

技術的負債という用語は、多くの場合、説明するために使用されます
戦術的なプログラミングによって引き起こされる問題。に
戦術的にプログラミングするあなたは時間を借りています
将来から：開発はより迅速に進みます
今、しかし後でもっとゆっくり。金融と同じように
借金、あなたが返済する金額は
借りた金額。金融債務とは異なり、ほとんど
技術的負債が完全に返済されることはありません。
支払いと永遠の支払い。

図3.1は、重要な問題を提起します。
戦略とのクロスオーバーポイントです
戦術曲線？言い換えれば、それはどのくらいですか
戦略的アプローチが報われる前に取る
自体？残念ながら、私は上のデータを知りません
このトピック、および実行するのは難しいでしょう
答えるのに必要な一種の制御された実験
説得力のある方法で質問。個人的な
意見は、返済の時期はどこかにあるということです：\ work \ Kindle \ phil \ 049.png @@ 6〜18か月の範囲。これにはやるべきことがたくさんあります
開発者の記憶を使って：
コードは数ヶ月前のもので、開発者は忘れています
彼らが書いたときに彼らの心にあったもののほとんど
そのため、次の場合、開発は大幅に遅くなります
コードは複雑です。これらの追加費用はすぐに
戦略的からの初期利益を補う
プログラミング。繰り返しますが、これは私の意見であり、私は
バックアップするデータがありません。

3.4スタートアップと

祭服

一部の環境では強い力があります
戦略的アプローチに反対する。にとって
たとえば、初期段階のスタートアップは途方もないと感じます
初期のリリースを迅速にリリースするよう圧力をかけます。の
これらの会社では、10人でも
20％の投資は手頃な価格ではありません。その結果、多くの
スタートアップは戦術的なアプローチを取り、ほとんど支出しない
設計に労力を費やし、クリーンアップにさらに労力を費やさない場合
問題が発生します。彼らはこれを合理化します
彼らが成功すれば、彼らは
掃除するために追加のエンジニアを雇うのに十分なお金
物事。

あなたがこの方向に傾いている会社にいるなら、
コードベースがtod：\ work \ Kindle \ phil \ 050.png @@ spaghettiに変わると、修正することはほぼ不可能であることを理解する必要があります。あなたはするであろう
おそらくの寿命のために高い開発コストを支払う
製品。さらに、善のための見返り（または
悪い）デザインはすぐに来るので、良いものがあります
戦術的アプローチがスピードさえ出ない可能性
最初の製品リリースをアップします。

考慮すべきもう1つのことは、
会社の成功のための最も重要な要素は
そのエンジニアの質。下げるための最良の方法
開発コストは優秀なエンジニアを雇うことです：彼らは
平凡なエンジニアよりもはるかに多くの費用はかかりませんが
生産性が大幅に向上します。でも、
最高のエンジニアは、優れた設計に深く関心を持っています。
あなたのコードベースが難破であるならば、言葉は出て行きます、
これにより、採用が難しくなります。として
結果として、あなたは平凡になってしまう可能性があります
エンジニア。これにより、将来のコストが増加し、
おそらくシステム構造が劣化する原因になります
さらに。

Facebookはスタートアップの一例です
戦術的なプログラミングを奨励した。長年
会社のモットーは「速く動き、休憩する
もの。"大学を卒業したばかりの新しいエンジニアは
すぐに会社に飛び込むことをお勧めします
コードベース;エンジニアがプッシュするのは正常でした
最初の週に本番環境に移行します

--

d：\ work \ Kindle \ phil \051.png@@仕事。良い面として、Facebookは開発しました
その力を与えた会社としての評判
従業員。エンジニアは途方もない寛容さを持っていました、そして
彼らに入るルールと制限はほとんどありませんでした
仕方。

Facebookは見事に成功しています
会社として、しかしそのコードベースは
会社の戦術的アプローチのの多くは
コードは不安定で理解しづらいものでした
コメントやテストはほとんどなく、作業するのは面倒です。
やがて会社はその文化に気づきました
持続不可能でした。最終的に、Facebookは変更されました
「強固なインフラストラクチャで迅速に移動する」というモットー
エンジニアにもっと良い投資をするように勧める
設計。 Facebookかどうかはまだ分からない
問題をうまくクリーンアップできます
何年にもわたる戦術的プログラミングの蓄積。

Facebookに公平を期すために、私はそれを指摘する必要があります
Facebookのコードはおそらくそれよりもそれほど悪くはありません
スタートアップの平均。戦術プログラミング
スタートアップの間では当たり前のことです。 Facebookだけ
たまたま特に目に見える例です。

幸いなことに、成功することも可能です
戦略的アプローチによるシリコンバレー。グーグル
とVMwareはほぼ同じ時期に育ちました
Facebookですが、これらの企業はどちらもdd：\ work \ Kindle \ phil \052.png@@より戦略的なアプローチを採用しています。両社が配置
高品質のコードと優れたものに重点を置いています
デザイン、そして両社は洗練されたものを構築しました
複雑な問題を解決した製品
信頼できるソフトウェアシステム。企業の強い
技術文化はシリコンでよく知られるようになりました
谷。競合する可能性のある他の企業はほとんどありません
最高の技術者を雇うために彼ら。

これらの例は、企業ができることを示しています
どちらのアプローチでも成功します。しかし、それはたくさんあります
気になる会社で働くのがもっと楽しく
ソフトウェア設計とクリーンなコードベースを持っています。

3.5結論

優れたデザインは無料ではありません。それはする必要があります
あなたが継続的に投資する何か、

小さな問題が大きな問題に蓄積されることはありません。
幸いなことに、優れた設計は最終的にはそれ自体で報われます。
そしてあなたが思うよりも早く。

一貫して適用することが重要です
戦略的アプローチと投資について考える
明日ではなく、今日することとして。いつ
あなたはクランチになりますそれは延期したくなるでしょう
クランチが終わるまでクリーンアップ。でも、
これは滑りやすい坂道です。現在のクランチの後：\ work \ Kindle \ phil \ 053.png @@ほぼ確実に別のものがあり、
その後別。設計を遅らせ始めたら
改善により、遅延が発生しやすくなります
永続的であり、あなたの文化が
戦術的アプローチ。対処するのを待つ時間が長くなる
設計上の問題が大きくなるほど、問題は大きくなります。 the
ソリューションはより威圧的になり、
それらをさらに延期するのが簡単になります。最も
効果的なアプローチは、すべてのエンジニアが
良い投資を継続的に行う
design.d：\ work \ Kindle \ phil \054.png@@第4章

モジュールは深くする必要があります

のための最も重要なテクニックの1つ
ソフトウェアの複雑さの管理は、システムを設計することです
開発者がほんのわずかに直面する必要があるように
いつでも全体的な複雑さの。これ
このアプローチはモジュラー設計と呼ばれ、この章は

その基本原則を提示します。

4.1モジュラー設計

モジュール設計では、ソフトウェアシステムは
モジュールのコレクションに分解されます
比較的独立しています。モジュールには多くの時間がかかる場合があります
クラス、サブシステム、サービスなどのフォーム。の
理想的な世界では、各モジュールは完全に
他から独立している：開発者は働くことができます
何も知らずにモジュールのいずれかで
他のモジュールについて。この世界では、thed：\ work \ kindle \ phil \055.png@@システムの複雑さは
その最悪のモジュール。

残念ながら、この理想は達成できません。
モジュールは、それぞれを呼び出すことによって連携する必要があります
他の人の関数またはメソッド。その結果、モジュール
お互いについて何かを知っている必要があります。三
モジュール間の依存関係になります：1つの場合
モジュールの変更、他のモジュールはする必要があるかもしれません
一致するように変更します。たとえば、引数
メソッドの場合、
メソッドとそのメソッドを呼び出すコード。もしも
必要な引数が変更され、すべての呼び出しが
メソッドは、に準拠するように変更する必要があります
新しい署名。依存関係は他の多くを取ることができます
フォーム、およびそれらは非常に微妙な場合があります。一例として、
一部のメソッドが正しく機能しない場合があります
他のメソッドが最初に呼び出されました。の目標
モジュラー設計は、依存関係を最小限に抑えることです
モジュール間。

依存関係を特定して管理するために、
各モジュールは2つの部分で考えられます：インターフェース
と実装。インターフェイスは構成されています
開発者が作業しているすべての
を使用するには、別のモジュールが知っている必要があります
与えられたモジュール。通常、インターフェースは次のように記述します
モジュールが行うことですが、どのように行うかではありません。 Thed：\ work \ Kindle \ phil \ 056.png @@実装は、次のコードで構成されています
インターフェイスによってなされた約束を出します。開発者
特定のモジュールでの作業は理解する必要があります
インターフェイスとi
そのモジュールの実装、
加えて、によって呼び出される他のモジュールのインターフェース
指定されたモジュール。開発者はする必要はありません
他のモジュールの実装を理解する
彼または彼女が働いている人よりも。

バランスの取れた実装を行うモジュールを考えてみましょう
木。モジュールにはおそらく洗練されたものが含まれています
ツリーのバランスを保つためのコード。
ただし、この複雑さは、
モジュール。ユーザーには比較的シンプルなインターフェースが表示されます
挿入、削除、およびフェッチする操作を呼び出すため
ツリー内のノード。挿入操作を呼び出すには、
発信者は、キーと値を提供するだけで済みます
新しいノード;ツリーをトラバースするためのメカニズム
分割ノードはインターフェースに表示されません。

この本の目的のために、モジュールは
インターフェイスと
実装。オブジェクト指向の各クラス
プログラミング言語はモジュールです。メソッド
クラス内、またはその言語で機能する
オブジェクト指向ではなく、次のように考えることもできます
モジュール：これらのそれぞれには、インターフェイスと

実装、およびモジュラー設計手法：\ work \ Kindle \ phil \057.png@@をそれらに適用できます。上位レベルのサブシステム
およびサービスもモジュールです。それらのインターフェースは
カーネル呼び出しやHTTPなどのさまざまな形式を取ります
リクエスト。モジュール式に関する議論の多く
この本のデザインは、クラスのデザインに焦点を当てています。
しかし、技術と概念は他にも適用されます
モジュールの種類も。

最高のモジュールは、そのインターフェースが
それらの実装よりもはるかに単純です。
このようなモジュールには2つの利点があります。まず、簡単です
インターフェイスは、モジュールの複雑さを最小限に抑えます
システムの残りの部分に課します。第二に、ifa
モジュールは変更されない方法で変更されます
そのインターフェイス、その後、他のモジュールは影響を受けません
変更によって。モジュールのインターフェースが多い場合
その実装よりも単純で、
変更できるモジュールの多くの側面
他のモジュールに影響を与えることなく。

4.2インターフェースには何がありますか？

モジュールへのインターフェースには、2種類の
情報：公式および非公式。正式
インターフェイスの一部は、で明示的に指定されています
コード、およびこれらのいくつかをチェックすることができます

プログラミング言語による正確さ。 Ford：\ work \ Kindle \ phil \ 058.png @@の例では、メソッドの正式なインターフェイスは
名前とタイプを含む署名

そのパラメータの、その戻り値のタイプ、

およびによってスローされた例外に関する情報
方法。ほとんどのプログラミング言語は
メソッドを呼び出すたびに、
それに一致する引数の正しい数とタイプ
サイン。クラスの正式なインターフェースは次のとおりです。
すべてのパブリックメソッドのシグネチャに加えて
パブリック変数の名前とタイプ。

各インターフェースには、非公式の要素も含まれています。
これらは、次のような方法で指定されていません
プログラミングによって理解または実施される
言語。インターフェイスの非公式な部分
事実などの高レベルの動作を含める
関数がそのいずれかによって指定されたファイルを削除すること
引数。の使用に制約がある場合
aclass（おそらく1つのメソッドを前に呼び出す必要があります
別の）、これらもクラスのインターフェースの一部です。
一般に、開発者が特定のことを知る必要がある場合
モジュールを使用するための情報、次に
その情報はモジュールのインターフェースの一部です。
インターフェイスの非公式な側面は、
コメントとプログラミングを使用して説明
言語は、説明が
完全または正確1。ほとんどのインターフェースでは、thed：\ work \ Kindle \ phil \059.png@@非公式な側面はより大きく複雑です
正式な側面。

明確に指定されたインターフェースの利点の1つ
開発者が必要としているものを正確に示しているということです
関連するモジュールを使用するために知ること。
これは、「未知の未知数」を排除するのに役立ちます
セクション2.2で説明されている問題。

4.3抽象化

抽象化という用語は、アイデアと密接に関連しています
モジュラー設計の。抽象化は単純化されたものです
重要でないものを省略したエンティティのビュー
詳細。抽象化は、
考えたり操作したりするのが簡単になります
複雑なもの。

モジュラープログラミングでは、各モジュール
その形で抽象化を提供します
インターフェース。インターフェイスは簡略化された
モジュールの機能のビュー。の詳細
実装は重要ではありません
モジュールの抽象化の観点から、
インターフェイスから省略されています。

抽象化の定義では、単語
「重要」は非常に重要です。より重要でない
抽象化から省略されている詳細、thed：\ work \ Kindle \ phil \060.png@@より良い。ただし、詳細は省略できます。

それが本当に重要でない場合は、抽象化から。

抽象化は2つの方法でうまくいかない可能性があります。まず、
それほど重要ではない詳細を含めることができます。
これが起こるとき、それは抽象化をより多くします
必要以上に複雑で、
抽象化を使用する開発者の認知的負荷。
2番目のエラーは、abstracが

省略
本当に重要な詳細。この結果

あいまいな状態で：開発者は
抽象化は彼らがすべての情報を持っているわけではありません
抽象化を正しく使用する必要があります。抽象化
重要な詳細を省略しているのは誤った抽象化です。
単純に見えるかもしれませんが、実際にはそうではありません。キー
抽象化を設計することは、何であるかを理解することです
重要であり、最小化する設計を探す
重要な情報の量。

例として、ファイルシステムについて考えてみます。 The
ファイルシステムによって提供される抽象化は、多くを省略します
選択のメカニズムなどの詳細
に使用するストレージデバイス上のブロック
特定のファイルのデータ。これらの詳細は重要ではありません
ファイルシステムのユーザーへ（システムが
十分なパフォーマンスを提供します）。ただし、一部
ファイルシステムの実装の詳細
ユーザーにとって重要です。ほとんどのファイルシステムはメインメモリに\work\ Kindle \ phil \ 061.png @@データをキャッシュしており、書き込みが遅れる可能性があります
改善するためのストレージデバイスへの新しいデータ
パフォーマンス。データベースなどの一部のアプリケーション、
データがいつ書き込まれるかを正確に知る必要があります
ストレージに保存するので、データが確実に
システムがクラッシュした後も保持されます。したがって、
セカンダリストレージへのデータのフラッシュは表示されている必要があります
ファイルシステムのインターフェースで。

管理は抽象化に依存しています
プログラミングだけでなく、複雑さ
私たちの日常生活に浸透しています。電子レンジ
オーブンには、変換するための複雑な電子機器が含まれています
マイクロ波放射への交流と
その放射線を調理全体に分散させる
虫歯。幸いなことに、ユーザーにははるかに単純なものが表示されます
制御するいくつかのボタンで構成される抽象化
マイクロ波のタイミングと強度。車
私たちが運転できるようにする単純な抽象化を提供する
のメカニズムを理解せずにそれら
電気モーター、バッテリー電源管理、アンチ
ロックブレーキ、クルーズコントロールなど。d：\ work \ Kindle \ phil \ 062.png @@インターフェース（コスト：
少ないほど良い）

ae ee ee

ディープモジュール

図4.1：深いモジュールと浅いモジュール。最高のモジュールは
深い：それらは多くの機能にアクセスすることを可能にします
シンプルなインターフェース。浅いモジュールは、比較的
複雑なインターフェースですが、機能はそれほど多くありません。

多くの複雑さを隠します。

4.4ディープモジュール

最高のモジュールは、強力なモジュールを提供するものです
機能はまだシンプルなインターフェースを持っています。私は
そのようなモジュールを説明するための深い用語。視覚化するには
深さの概念、各モジュールが
図4.1に示すように、長方形で表されます。
各長方形の面積は、
モジュールによって実装される機能。 The
長方形の上端はモジュールの
インターフェース;そのエッジの長さは
インターフェイスの複雑さ。最高のモジュール

深い：彼らは隠された多くの機能を持っています
シンプルなインターフェースの背後にあります。深いモジュールはgoodd：\ work \ kindle \ phil \ 063.png @@抽象化です。これは、そのほんの一部にすぎないためです。
内部の複雑さはユーザーに見えます。

モジュールの深さはコストについての考え方です
対利益。モジュールによって提供される利点
その機能です。モジュールのコスト（
システムの複雑さの観点から）はそのインターフェースです。 A
モジュールのインターフェースは、
モジュールはシステムの残りの部分に課します：
インターフェースが小さくてシンプルであればあるほど、
それがもたらす複雑さ。最高のモジュールは
最大の利益と最小のコストを持つもの。
インターフェースは優れていますが、より多くの、またはより大きなインターフェース
必ずしも良いとは限りません！

によって提供されるファイルI/Oのメカニズム
Unixオペレーティングシステムとその子孫など
Linuxとしては、深いインターフェースの美しい例です。
I / Oの基本的なシステムコールは5つだけで、
単純な署名：

int open（const char * path、int flags、mode_t
権限）;

ssize_t read（int fd、void * buffer、size_t count）;
ssize_t write（int fd、const void * buffer、size_t count）;
off_t Iseek（int fd、off_t offset、int
referencePosition）;

int close（int fd）;

オープンシステムコールは階層的なファイル名を取ります
/ a / b / cなど、整数ファイル記述子d：\ work \ Kindle \ phil \064.png@@を返します。これは開いているファイルを参照するために使用されます。他の
openの引数は、オプションの情報を提供します
ファイルが読み取り用に開かれているかどうかなど
または書き込み、新しいファイルを作成する必要があるかどうか
既存のファイルはなく、
新しいファイルが作成された場合は、ファイル。読み取りと書き込み
システムコールはバッファ間で情報を転送します
アプリケーションのメモリとファイルの領域。選ぶ
ファイルへのアクセスを終了します。ほとんどのファイルにアクセスします
順番に、それがデフォルトです。でも、
ランダムアクセスは、
現在のアクセスを変更するための1seekシステムコール
ポジション。

Unix I/Oの最新の実装
インターフェイスには数十万行の
次のような複雑な問題に対処するコード。

+ファイルをディスク上でどのように表現するか
効率的なアクセスを許可しますか？

+ディレクトリはどのように保存され、どのように保存されますか
階層

見つけるために処理されたchicalパス名
彼らが参照するファイル？

+権限はどのように適用されるので、
ユーザーは他のユーザーを変更または削除できません
ファイル？

+ファイルアクセスはどのように実装されていますか？にとって
たとえば、機能はどのように分割されますか：\ work \ Kindle \ phil \065.png@@割り込みハンドラーとバックグラウンドの間
コード、およびこれら2つの要素はどのように実行されますか
安全に通信しますか？

+どのスケジューリングポリシーがいつ使用されるか
複数への同時アクセスがあります
ファイル？

+最近アクセスしたファイルデータをキャッシュするにはどうすればよいですか

の数を減らすためにメモリに
ディスクアクセス？

+さまざまな異なるセカンダリはどのようにできますか
ディスクやフラッシュなどのストレージデバイス
ドライブ、単一のファイルに組み込まれます
システム？

これらすべての問題、およびその他多くの問題が処理されます
Unixファイルシステムの実装による。彼らです
システムを呼び出すプログラマーには見えない
呼び出します。 Unix I/Oインターフェースの実装
何年にもわたって根本的に進化してきましたが、5つ
基本的なカーネル呼び出しは変更されていません。

ディープモジュールのもう1つの例は、
Goやなどの言語のガベージコレクター
Java。このモジュールにはインターフェイスがまったくありません。できます
目に見えない舞台裏で未使用を取り戻す
メモリー。システムへのガベージコレクションの追加
実際には、インターフェイス全体が縮小されます。
オブジェクトを解放するためのインターフェースを排除します。 Thed：\ work \ Kindle \ phil \066.png@@ガベージコレクターの実装はかなりです
複雑ですが、その複雑さは
プログラマー。

Unix I/Oやガベージなどのディープモジュール
コレクターは強力な抽象化を提供します
それらは使いやすいですが、重要なものを隠しています
実装の複雑さ。

4.5浅いモジュール

一方、浅いモジュールは、
インターフェースはに比べて比較的複雑です
それが提供する機能。例えば、
リンクリストを実装するクラスは浅いです。それ
リンクリストを操作するのに多くのコードを必要としません
（要素の挿入または削除には数回しかかかりません
行）、したがって、リンクリストの抽象化は非表示になりません
非常に多くの詳細。リンクリストの複雑さ
インターフェイスは、その複雑さとほぼ同じくらい素晴らしいです
実装。リンクリストのような浅いクラスは
やむを得ない場合もありますが、それでも役立つ場合があります。
しかし、彼らはに対して多くのレバレッジを提供しません
複雑。

これは浅いの極端な例です
ソフトウェア設計のプロジェクトから取られた方法
class：d：\ work \ Kindle \ phil \ 067.png @@ private void addNullValueForAttribute（String attribute）
{{

data.put（attribute、null）;
+

複雑さの管理の観点から、

この方法は事態を悪化させますが、良くはしません。

このメソッドは、そのすべてが抽象化されていないため、抽象化を提供しません。
機能はそのインターフェースを通して見ることができます。にとって
たとえば、発信者はおそらく次のことを知る必要があります
属性はデータ変数に格納されます。それはありません
考えるよりもインターフェースについて考える方が簡単
完全な実装について。メソッドが
適切に文書化されている場合、文書は
メソッドのコードよりも長い。さらに時間がかかります
必要以上にメソッドを呼び出すためのキーストローク
呼び出し元がデータ変数を直接操作するため。
この方法は複雑さを追加します（新しい形で
開発者が学ぶためのインターフェース）が提供しません

利益を補う。

 赤旗：浅いモジュール

Ashallowモジュールは、インターフェイスが
機能に比べて複雑
提供します。浅いモジュールはあまり役に立ちません
複雑さとの戦いでは、thed：\ work \ Kindle \ phil \ 068.png @@のメリットがあります（について学ぶ必要はありません）。
それらが内部でどのように機能するか）はコストによって打ち消されます
それらのインターフェースを学び、使用すること。小さい
モジュールは浅くなる傾向があります。

4.6分類炎

残念ながら、ディープクラスの価値は
今日広く感謝しています。従来型
プログラミングの知恵は、クラスはすべきであるということです
深くはなく、小さくしてください。学生はしばしばそれを教えられます
クラスデザインで最も重要なことは
大きなクラスを小さなクラスに分割します。同じ
多くの場合、方法についてアドバイスがあります。
N行より長い場合は複数に分割する必要があります
メソッド」（Nは10まで低くすることができます）。このアプローチ
浅いクラスが多数発生し、
システム全体の複雑さを増すメソッド。
「クラスは小さくなければならない」の極限
アプローチは私が分類炎と呼ぶ症候群であり、
「クラスは良いので、
クラスが多いほど良いです。」苦しんでいるシステムでは
分類、開発者は最小限に抑えることをお勧めします
新しい各クラスの機能の量：
より多くの機能が必要な場合は、mored：\ work \ Kindle \ phil \069.png@@クラスを導入してください。分類炎は、次のようなクラスになる可能性があります
個々に単純ですが、複雑さが増します
システム全体の。少人数のクラスは貢献しません
多くの機能があるので、たくさんある必要があります
それらは、それぞれ独自のインターフェースを備えています。これらのインターフェース
で途方もない複雑さを作成するために蓄積します
システムレベル。少人数のクラスでも冗長になります
必要なボイラープレートによるプログラミングスタイル
クラスごとに。

4.7例：JavaおよびUnix I / O

最もvisiの1つ

今日の分類の良い例
Javaクラスライブラリです。 Java言語は
たくさんの小さなクラスが必要ですが、分類の文化
Javaプログラミングに根付いたようです
コミュニティ。たとえば、何年もの間Java
開発者はで3つの異なるオブジェクトを作成する必要がありました
ファイルを開き、シリアル化されたオブジェクトを
それ：

FileInputStream fileStream =

new FileInputStream（fileName）;
BufferedInputStream bufferedStream =

new BufferedInputStream（fileStream）;
ObjectInputStream objectStream =

new ObjectInputStream（bufferedStream）;
FileInputStreamオブジェクトは、基本的なものだけを提供します

1 / O：バッファリングされたI / d：\ work \ Kindle \ phil \ 070.png @@ Oを実行することも、シリアル化されたオブジェクトを読み書きすることもできません。 The

BufferedInputStreamオブジェクトはバッファリングを追加します
FileInputStream、およびobjectInputStreamは追加します

シリアル化されたオブジェクトを読み書きする機能。 The
上記のコードの最初の2つのオブジェクト、FileStreamと
bufferedStreamは、ファイルが使用された後は使用されません。
開いた;今後のすべての操作はobjectStreamを使用します。

特に煩わしい（そしてエラーが発生しやすい）
そのバッファリングは、によって明示的に要求する必要があります
別のBufferedInputStreamオブジェクトを作成します。もし
開発者はこのオブジェクトを作成するのを忘れます。
バッファリングがなく、I/Oが遅くなります。おそらくJava
開発者は、誰もが望んでいるわけではないと主張するでしょう
ファイルI/Oにバッファリングを使用するため、ビルドしないでください
基本メカニズムに。彼らはそれを主張するかもしれません
バッファリングを分離しておくことをお勧めします。そうすれば、人々は
使用するかどうかを選択します。選択肢を提供することは
良いですが、インターフェースは次のように設計する必要があります
可能な限り単純な一般的なケース（
6ページの式）。ファイルI/Oのほぼすべてのユーザー
バッファリングが必要になるため、
デフォルト。バッファリングが
望ましくない、ライブラリはメカニズムを提供できます
無効にします。バッファリングを無効にするための任意のメカニズム
インターフェイスできれいに分離する必要があります（
たとえば、別のコンストラクターford：\ work \ Kindle \ phil \ 071.png @@ FileInputStreamを提供するか、無効にするメソッドを使用します
またはバッファリングメカニズムを置き換えます）、
開発者はそのことを意識する必要さえありません
存在。

対照的に、Unixシステムの設計者
呼び出しにより、一般的なケースが単純になりました。例えば、
彼らはシーケンシャルI/Oが最も多いことを認識しました
共通なので、彼らはそれをデフォルトの振る舞いにしました。
ランダムアクセスは、次を使用して、まだ比較的簡単に実行できます
Iseekシステムコールですが、開発者は
シーケンシャルアクセスのみがそれを認識する必要はありません
機構。インターフェイスに多くの機能があるが、
ほとんどの開発者は、いくつかのことを知っておく必要があります
それら、そのインターフェースの効果的な複雑さは
一般的に使用される機能の複雑さだけです。

4.8結論

モジュールのインターフェースをそのインターフェースから分離することによって
実装では、複雑さを隠すことができます
システムの残りの部分からの実装。ユーザー
モジュールの抽象化を理解するだけでよい
そのインターフェイスによって提供されます。最も重要な問題
クラスや他のモジュールを設計する際に
それらは深く、そのためそれらはのための単純なインターフェースを持っています

一般的なユースケースですが、それでも重要な機能を提供します：\ work \ Kindle \ phil \072.png@@機能。これにより、
隠されている複雑さ。

1主に研究に言語が存在します
コミュニティ、メソッドの全体的な動作または
関数は仕様を使用して正式に記述できます
言語。仕様は自動的に確認できます
実装と一致していることを確認してください。面白い
問題は、そのような正式な仕様が置き換えられるかどうかです
インターフェイスの非公式な部分。私の現在の意見は
英語で記述されたインターフェースは、より直感的である可能性があります
書かれたものよりも開発者にとって理解しやすい

形式仕様言語.d：\ work \ Kindle \ phil \073.png@@第5章

情報隠蔽（および漏洩）

第4章では、モジュールは深くする必要があると主張しました。
この章とそれに続く次のいくつかの章では、
ディープモジュールを作成するためのテクニック。

5.1情報の隠蔽
のための最も重要なテクニックの1つ
深いモジュールを実現することは情報隠蔽です。これ
技術は最初に古典的な論文で説明されました
デビッドパーナス}。基本的な考え方は、各モジュールが
いくつかの知識をカプセル化する必要があります、
これは設計上の決定を表しています。知識
モジュールの実装に組み込まれていますが
インターフェースに表示されないため、
他のモジュール。

モジュール内に隠された情報
通常、実装方法に関する詳細で構成されています：\ work \ Kindle \ phil \074.png@@何らかのメカニズム。ここにいくつかの例があります
モジュール内に隠されている可能性のある情報：

+情報をBツリーに保存する方法、および
効率的にアクセスする方法。

+物理ディスクブロックを識別する方法
内の各論理ブロックに対応
ファイル。

+TCPネットワークプロトコルを実装する方法。

-マルチコアでスレッドをスケジュールする方法
プロセッサ。

+JSONドキュメントを解析する方法。

隠された情報を含む

esデータ
に関連する構造とアルゴリズム
機構。下位レベルの詳細を含めることもできます
ページのサイズなど、より高いサイズを含めることができます-
たとえば、より抽象的なレベルの概念
ほとんどのファイルが小さいという仮定。

情報隠蔽は複雑さを軽減します
ふたつのやり方。まず、インターフェースを簡素化します
モジュール。インターフェースは、よりシンプルでより多くを反映しています
モジュールの機能の抽象的なビューと
詳細を非表示にします。これにより、認知的負荷が軽減されます
モジュールを使用する開発者向け。たとえば、
Bツリークラスを使用する開発者は心配する必要はありません
ツリー内のノードの理想的なファンアウトまたはその方法
ツリーのバランスを保ちます。第二に、隠された情報：\ work \ Kindle \ phil \ 075.png @@は、システムの進化を容易にします。の一部の場合
情報は隠されており、依存関係はありません
を含むモジュール外のその情報について
情報なので、それに関連する設計変更
情報は1つのモジュールにのみ影響します。にとって
たとえば、TCPプロトコルが変更された場合（導入するため
輻輳制御の新しいメカニズム、
インスタンス）、プロトコルの実装には
変更する必要がありますが、変更は必要ありません
TCPを使用して送受信する高レベルのコード
データ。

新しいモジュールを設計するときは、
情報が何であるかを慎重に考えてください
そのモジュールに隠されています。もっと隠すことができれば
情報、あなたはまた単純化することができるはずです
モジュールのインターフェースであり、これによりモジュールが作成されます
もっと深く。

注：クラス内の変数とメソッドを非表示にする
それらをプライベートと宣言することは、
情報隠蔽。プライベート要素は
彼らはそれを不可能にするので、情報隠蔽
外部から直接アクセスするアイテムの場合
クラス。ただし、プライベートに関する情報
アイテムは引き続きパブリックメソッドを介して公開できます
getterメソッドやsetterメソッドなど。 thisd：\ work \ Kindle \ phil \ 076.png @@が発生すると、変数の性質と使用法は次のようになります。
変数が公開されているかのように公開されます。

情報隠蔽の最良の形態は、
情報はモジュール内に完全に隠されていますが、
そのため、それは無関係であり、のユーザーには見えません
モジュール。ただし、部分的な情報隠蔽も
価値があります。たとえば、特定の機能または
情報の一部は、少数の人だけが必要とします
クラスのユーザーであり、個別にアクセスします
最も一般的に表示されないようにする方法
ユースケースでは、その情報はほとんど隠されています。
このような情報により、依存関係が少なくなります
のすべてのユーザーに表示される情報よりも
クラス。

5.2情報漏えい

情報隠蔽の反対は情報です
漏れ。情報漏えいは

設計上の決定は複数のモジュールに反映されます。
これにより、モジュール間に依存関係が作成されます。
その設計上の決定を変更するには、
関連するすべてのモジュールへの変更。ピースの場合

情報の
モジュール、それから定義上、それはリークされました。したがって、
より単純なインターフェースは、betterd：\ work \ Kindle \ phil \077.png@@情報隠蔽と相関する傾向があります。ただし、情報は

モジュールに表示されていなくてもリークされる
インターフェース。 2つのクラスの両方に知識があるとします
特定のファイル形式（おそらく1つのクラス
その形式および他のクラスのファイルを読み取ります
それらを書き込みます）。どちらのクラスもそれを公開していなくても
そのインターフェースの情報、それらは両方とも依存しています
ファイル形式：形式が変更された場合、両方のクラス
変更する必要があります。のような裏口漏れ
これは、
明らかではないので、インターフェース。

情報漏えいは最も多いものの1つです
ソフトウェア設計における重要な危険信号。一つ
ソフトウェアデザイナーとして学ぶことができる最高のスキルは
情報漏えいに対する高レベルの感度。
間で情報漏えいが発生した場合
クラスでは、「どうすればこれらを再編成できますか？
この特定の知識の一部が
単一のクラスにのみ影響しますか？」影響を受けるクラスの場合
比較的小さく、漏れたものと密接に結びついています
情報、それらをマージすることは理にかなっているかもしれません
単一のクラスに。別の可能なアプローチは
影響を受けるすべての情報から情報を引き出す
クラスを作成し、カプセル化する新しいクラスを作成します
その情報だけです。ただし、このアプローチは
詳細から抽象化された単純なインターフェイス：\ work \ Kindle \ phil \078.png@@が見つかった場合にのみ効果的です。新しい場合
クラスは、そのを通じて知識のほとんどを公開します
インターフェース、それからそれは多くの価値を提供しません（あなたは
単にバックドアの漏れを漏れに置き換えた
インターフェイスを介して）。

5.3時間的分解

情報漏えいの一般的な原因の1つは

私が時間分解と呼ぶデザインスタイル。の
時間的分解、システムの構造
操作が行われる時間順序に対応します
発生します。を読み取るアプリケーションを考えてみましょう

特定の形式のファイル、内容を変更します
ファイルの、そしてファイルを再び書き出す。と
時間的分解、このアプリケーションは
に侵入される

3つのクラス：1つはファイルを読み取るため、
もう1つは変更を実行し、3つ目は変更を実行します
新しいバージョンを書き出す。両方のファイル読み取り
およびファイルの書き込み手順には、
情報漏えいの原因となるファイル形式。
解決策は、コアメカニズムを組み合わせることです
ファイルを単一のクラスに読み書きするため。これ
クラスは読書と読書の両方で使用されます
アプリケーションの書き込みフェーズ。落ちやすい
なぜなら、時間的分解の罠に陥るからです。
あなたがコーディングするときあなたの心に。ただし、ほとんどの
設計上の決定は、いくつかの点で明らかになります
アプリケーションの存続期間中のさまざまな時間。なので
結果として、時間的分解はしばしば結果として
情報漏えい。

 危険信号：情報漏えい

同じときに情報漏えいが発生する
知識は、次のような複数の場所で使用されます
両方が理解する2つの異なるクラス
特定の種類のファイルの形式。

通常、順序は重要なので、
アプリケーションのどこかに反映されます。
ただし、モジュールに反映されるべきではありません
その構造がと一致しない限り、構造
情報隠蔽（おそらくさまざまな段階
まったく異なる情報を使用してください）。設計時
モジュール、必要な知識に焦点を当てる
タスクの順序ではなく、各タスクを実行します

occur.d：\ work \ Kindle \ phil \ 080.png @@ 5.4例：HTTPサーバー

情報隠蔽の問題を説明するために、
学生による設計上の決定を検討する
ソフトウェアでのHTTPプロトコルの実装
デザインコース。それらの両方を見ると便利です
うまくいったし、彼らが問題を抱えていた分野。
HTTPは、Webブラウザで使用されるメカニズムです。
Webサーバーと通信します。ユーザーが
Webブラウザでリンクをクリックするか、
フォームの場合、ブラウザはHTTPを使用してリクエストを送信します
Webサーバーへのネットワーク。サーバーが
リクエストを処理し、レスポンスをに送り返します
ブラウザ;通常、応答には新たに含まれます
表示するWebページ。 HTTPプロトコルは指定します
リクエストとレスポンスのフォーマット、どちらも
テキストで表されます。図5.1にサンプルを示します
フォーム送信を説明するHTTPリクエスト。 The
コースの学生は実装するように求められました
Webサーバーを簡単にするための1つ以上のクラス
着信HTTPリクエストを受信して​​送信する

反応。

 赤旗：一時的

分解：\ work \ Kindle \ phil \ 081.png @@時間分解では、実行順序
コード構造に反映されます：操作
異なる時間に発生することは異なる
メソッドまたはクラス。同じ知識なら

実行のさまざまなポイントで使用されます。
複数の場所でエンコードされ、結果として

情報漏えい。
mopパラメータプロトコルバージョン

POST / conments / create？photo_id = 246 HTTP / 1.1
ホスト：www.exampTe .. com

ユーザーエージェント：Mozilia / 5.0
‘text / html、

承認：
受け入れる-言語：。 \ヘッダー
Accept-charset：1s0-8859-1、utf-8

コンテンツの長さ：40

conment = what + a +cute + baby％21priority =low<ボディ

図5.1：HTTPプロトコルのPOSTリクエストは
TCPソケットを介して送信されるテキスト。各リクエストにはイニシャルが含まれています
line、空の行で終了するヘッダーのコレクション、
とオプションのボディ。最初の行にはリクエストが含まれています
タイプ（投稿はフォームデータの送信に使用されます）、URLを示す
操作（/ comments / create）およびオプションのパラメーター
（photo_idの値は246）、およびHTTPプロトコルバージョン
送信者が使用します。各ヘッダー行は、次のような名前で構成されます
Content-Lengthの後にその値が続きます。このリクエストの場合、

本文には追加のパラメーター（コメントと優先度）が含まれています。d：\ work \ Kindle \ phil \ 082.png @@ 5.5例：クラスが多すぎます
学生が犯した最も一般的な間違いは
彼らのコードを多数の浅いものに分割する
クラス間の情報漏えいにつながった
クラス。 1つのチームが2つの異なるクラスを使用しました
HTTPリクエストを受信するため。ファーストクラスは
ネットワーク接続から文字列への要求、
2番目のクラスは文字列を解析しました。これは
時間的分解の例（「最初に
リクエストを読んでから、それを解析します」）。情報
HTTPリクエストができないためにリークが発生しました
メッセージの多くを解析せずに読む。にとって
たとえば、Content-Lengthヘッダーは
リクエスト本文の長さであるため、ヘッダーは
リクエストの合計の長さを計算するために解析されます。
その結果、両方のクラスがほとんどを理解する必要がありました
HTTPリクエストの構造の分析、および解析
コードは両方のクラスで複製されました。このアプローチ
また、
異なるクラスの2つのメソッドを呼び出すには、ina
特定の注文、リクエストを受け取るため。

クラスはたくさんの情報を共有していたので、
それらをマージして
リクエストの読み取りとリクエストの読み取りの両方を処理する単一のクラス
構文解析。これにより、より良い情報隠蔽が提供されます。
formated：\ work \ Kindle \ phil \ 083.png @@のリクエストに関するすべての知識を1つのクラスに分離し、よりシンプルなインターフェースを提供するためです。
に

呼び出し元（呼び出すメソッドは1つだけ）。

この例は、の一般的なテーマを示しています
ソフトウェア設計：情報隠蔽はしばしば
クラスを少し大きくすることで改善されます。
これを行う理由の1つは、すべてをまとめることです。
特定の機能に関連するコードの
HTTPリクエストの解析として）、結果として
クラスには、その機能に関連するすべてのものが含まれています。
クラスのサイズを増やす2番目の理由
インターフェイスのレベルを上げることです。例えば、
それぞれに個別のメソッドを使用するのではなく
計算の3つのステップ、単一の方法があります
計算全体を実行します。これはできます
よりシンプルなインターフェースになります。これらの両方の利点
前の段落の例に適用します。
クラスを組み合わせると、すべての
HTTPリクエストの解析に関連するコードと
2つの外部から見えるメソッドを1つに置き換えます。
結合されたクラスは元のクラスよりも深い
クラス。

もちろん、の概念を取ることは可能です
大きすぎるクラス（単一のクラスなど
アプリケーション全体）。第9章で説明します
分離することが理にかなっている条件
複数の小さなクラスにコードを記述します。d：\ work \ kindle \ phil \ 084.png @@ 5.6例：HTTPパラメーターの処理
によってHTTPリクエストが受信された後
サーバー、サーバーはいくつかにアクセスする必要があります
リクエストからの情報。そのコード
図5.1のリクエストを処理する必要があるかもしれません

photo_idパラメータの値を知るため。
パラメータは、の最初の行で指定できます。
リクエスト（photo_idin図5.1）または場合によっては
本文（図5.1のコメントと優先順位）。各
パラメータには名前と値があります。その価値

パラメータの多くはURLと呼ばれる特別なエンコーディングを使用します
エンコーディング;たとえば、コメントの値で
図5.1「+」はスペース文字を表すために使用されます。
「！」の代わりに「％21」が使用されます。処理するために
リクエストの場合、サーバーは次の値を必要とします

いくつかのパラメータ、そしてそれはそれらを必要とするでしょう
エンコードされていないフォーム。

学生プロジェクトのほとんどは2つの良いものになりました
パラメータ処理に関する選択。初め、
彼らはサーバーアプリケーションが気にしないことを認識しました
ヘッダーにパラメーターが指定されているかどうか
行またはリクエストの本文なので、これを非表示にしました
発信者との区別とパラメータのマージ
両方の場所から一緒に。第二に、彼らは隠れました
URLエンコーディングの知識：HTTPパーサー
md：\ work \ Kindle \ phil \ 085.png @@をWebサーバーに返す前にパラメーター値をデコードして、コメントの値が
図5.1のパラメータは「What
「Whattatcutetbaby％21」ではなく、「急性の赤ちゃん！」）。の
これらの両方の場合、情報隠蔽は結果として
HTTPモジュールを使用するコード用のより単純なAPI。
しかし、ほとんどの学生はインターフェースを使用していました
浅すぎるパラメータを返すため、および
その結果、情報の機会が失われました
隠蔽。ほとんどのプロジェクトはタイプのオブジェクトを使用していました
解析されたHTTPリクエストを保持するHTTPRequest、および
HTTPRequestクラスには、次のような単一のメソッドがありました。

パラメータを返すために次の1つ：
public Map <String、String> getParams（）{

this.paramsを返します。

}
単一のパラメータを返すのではなく、

メソッドは、使用されたマップへの参照を返します
すべてのパラメータを内部的に保存します。これ
メソッドは浅く、内部を公開します
HTTPRequestクラスが格納するために使用する表現
パラメーター。その表現への変更

インターフェースが変更され、

すべての発信者に変更を加える必要があります。いつ
実装は変更され、頻繁に変更されます
重要なデータの表現の変更を伴う
構造（たとえば、パフォーマンスを向上させるため）。
したがって、内部datad：\ work \ Kindle \ phil \086.png@@構造をできるだけ公開しないようにすることが重要です。このアプローチも
発信者のためにより多くの仕事をします：発信者は最初にしなければなりません
getParamsを呼び出すと、別のメソッドを呼び出す必要があります
マップから特定のパラメータを取得します。ついに、
発信者は、変更してはならないことを認識している必要があります
getParamsによって返されるマップ。これは、
HTTPRequestの内部状態。

これは、取得するためのより良いインターフェースです

パラメータ値：
public String getParameter（String name）{...}
public int getIntParameter（文字列名）{...}

getParameterは、パラメータ値を文字列として返します。それ
getParamsよりもわずかに深いインターフェイスを提供します
その上;さらに重要なことに、それは内部を隠します
パラメータの表現。 getIntParameter
パラメータの値をその文字列から変換します
整数へのHTTPリクエストの形式（例：
図5.1のphoto_idパラメータ）。これにより、
呼び出し元が文字列から整数を要求する必要がない
個別に変換し、そのメカニズムを非表示にします
発信者から。他のデータの追加メソッド
getDoubleParameterなどのタイプは、次の場合に定義できます。
必要です。 （これらのメソッドはすべて例外をスローします
目的のパラメータが存在しない場合、または存在しない場合
要求されたタイプに変換されます。例外
上記のコードでは宣言が省略されています）.d：\ work \ Kindle \ phil \ 0

87.png @@ 5.7例：HTTP応答のデフォルト

HTTPプロジェクトは、次のサポートも提供する必要がありました。
HTTP応答を生成します。最も一般的な
この分野で学生が犯した間違いは不十分でした
デフォルト。各HTTP応答は、
HTTPプロトコルバージョン。 1つのチームに発信者が必要
作成時にこのバージョンを明示的に指定するには
応答オブジェクト。ただし、応答バージョン
リクエストオブジェクトのそれに対応している必要があり、
リクエストはすでに引数として渡されている必要があります
応答を送信するとき（どこに送信するかを示します
応答を送信します）。したがって、それはより理にかなっています
応答バージョンを提供するHTTPクラス
自動的。発信者は何を知っている可能性が低いです
指定するバージョン、および呼び出し元が指定する場合
値、それはおそらく情報漏えいにつながる
HTTPライブラリと呼び出し元の間。 HTTP
応答には、を指定するDateヘッダーも含まれます
応答が送信された時刻。 HTTPライブラリ
これにも適切なデフォルトを提供する必要があります。
デフォルトは、インターフェースの原則を示しています
一般的なケースを次のように作成するように設計する必要があります
可能な限りシンプル。それらはまたの例です
部分的な情報隠蔽：通常の場合、
発信者は、の存在を認識する必要はありません
デフォルトのアイテム。 callerd：\ work \ Kindle \ phil \ 088.png @@がデフォルトを上書きする必要があるまれなケースでは、それを知る必要があります
値について、そしてそれは特別なメソッドを呼び出すことができます
それを変更します。

可能な限り、クラスは「正しく行う必要があります
明示的に尋ねられることなく」。デフォルトは
この例。ページのJavaI/Oの例
図２６は、この点を否定的に示している。バッファリング
ファイル内のI/Oは非常に普遍的に望ましいので、誰も
明示的に要求する必要があります。
その存在を認識しています。 I/Oクラスは
正しいこととそれを自動的に提供します。最高の
機能はあなたが知らなくても得るものです
それらは存在します。

 危険信号：露出オーバー

一般的に使用される機能のAPIが強制される場合
ユーザーは、他の機能について学ぶことができます
めったに使用されませんが、これにより認知的負荷が増加します
めったに使用されない機能を必要としないユーザー。

5.8クラス内に隠されている情報

この章の例では、d：\ work \ Kindle \ phil \089.png@@外部に関連する情報の隠蔽に焦点を当てています。
クラスのAPIは表示されますが、情報を隠すことはできます
システムの他のレベルにも適用されます。
クラス内のように。プライベートメソッドを設計してみてください
各メソッドがカプセル化するようにクラス内
いくつかの情報または機能とそれを隠す
クラスの残りの部分。さらに、最小化するようにしてください
各インスタンス変数が存在する場所の数
使用されている。一部の変数にアクセスする必要がある場合があります
クラス全体で広く、しかし他のものが必要になるかもしれません
ほんの数か所。あなたがの数を減らすことができれば
変数が使用されている場所では、
クラス内の依存関係を減らし、
複雑。

5.9行き過ぎ

情報の隠蔽は、
非表示になっている情報は、その外部では必要ありません
モジュール。情報が外部で必要な場合
モジュールの場合は、非表示にしないでください。仮定
モジュールのパフォーマンスは、特定の影響を受けます
構成パラメーター、およびそのさまざまな用途
モジュールの異なる設定が必要になります

パラメータ。この場合、次のことが重要です。
パラメータは、適切に調整できるように、thed：\ work \ Kindle \ phil \090.png@@モジュールのインターフェイスで公開されます。
ソフトウェア設計者としてのあなたの目標は、
必要な情報の量を最小限に抑える
モジュールの外;たとえば、モジュールが
構成を自動的に調整します。
構成パラメーターを公開するよりも優れています。
ただし、どの情報を認識することが重要です
モジュールの外部で必要であり、それが

露出。

5.10結論

情報隠蔽と深いモジュールは密接に関連しています
関連している。モジュールが多くの情報を隠している場合、
機能の量を増やす傾向があります
モジュールによって提供されると同時に削減

そのインターフェイス。これにより、モジュールがより深くなります。
逆に、モジュールがあまり隠れていない場合
情報、それからどちらかそれは多くを持っていません
機能、またはそれは複雑なインターフェースを持っています。また
ちなみに、モジュールは浅いです。

システムをモジュールに分解する場合、
順序に影響されないようにしてください
操作は実行時に発生します。それはあなたを導きます
時間的分解の道をたどります。
情報漏えいが発生し、浅くなります：\ work \ Kindle \ phil \091.png@@モジュール。代わりに、さまざまな部分について考えてください
を実行するために必要な知識の
アプリケーションのタスク、および各モジュールの設計
それらの断片の1つまたはいくつかをカプセル化する
知識。これにより、クリーンでシンプルなものが生成されます

深いモジュールを使用した設計。

4David Parnas、「で使用される基準について
システムをモジュールに分解する」、
ACM、1972年12月.d：\ work \ Kindle \ phil \092.png@@第6章

汎用モジュール
より深い

私のソフトウェアデザインコースを教えるプロセス、
の

私は常にそれを特定しようとしています
学生コードの複雑さの原因が変更されました
いくつかのソフトウェア設計についての私の考え
方法。これらの中で最も重要なのは
一般性と専門性。私は見つけました
そして、その専門化は複雑さにつながります。

私は今、過度の専門化が
ソフトウェアの複雑さの最大の原因。
逆に、より汎用的なコードは
よりシンプルで、よりクリーンで、理解しやすい。

この原則は、次の多くの異なるレベルに適用されます。
ソフトウェア設計。次のようなモジュールを設計する場合
クラスまたはメソッド、生成するための最良の方法の1つ
深いAPIは、それを汎用（汎用-
目的のAPIを使用すると、より多くの情報が非表示になります）.d：\ work \ Kindle \ phil \ 093.png @@詳細なコードを作成する場合、最も
コードを単純化する効果的な方法は、
特殊なケース、つまり一般的なケースのコード
エッジケースも処理します。特別なものを排除する
ケースは、コードをより効率的にすることもできます。
第20章を参照してください。

この章では、発生する問題について説明します
専門化と一般性の利点によって。
専門性を完全に排除することはできません、
そのため、この章では、
特殊目的のコードを一般的なコードから分離する-
目的コード。

6.1クラスをやや一般的にする-

目的

あなたがする最も一般的な決定の1つ
新しいクラスを設計するときに直面するのは、
汎用または特殊に実装する-
目的のファッション。一部の人はあなたが
汎用的なアプローチを取る必要があります
に使用できるメカニズムを実装します
だけでなく、幅広い問題に対処します
今日重要なもの。この場合、新しい
メカニズムは、で予期しない使用を見つける可能性があります
将来、それによって時間を節約します。汎用：\ work \ Kindle \ phil \ 094.png@@アプローチは、投資と一致しているようです
第3章で説明した考え方
後で時間を節約するために、前もってもう少し時間を取ってください。

一方で、難しいことはわかっています
ソフトウェアシステムの将来のニーズを予測する、SOA
汎用ソリューションには施設が含まれる場合があります
それは実際には必要ありません。さらに、
一般的すぎるものを実装します-
目的、それは解決の良い仕事をしないかもしれません
あなたが今日抱えている特定の問題。結果として、
今日のことに焦点を当てたほうがよいと主張する人もいるかもしれません
ニーズ、必要だとわかっているものだけを構築し、
あなたが今日それを使うことを計画している方法のためにそれを専門にします。もしも
あなたは特別な目的のアプローチを取り、発見します
後で追加使用する場合は、いつでもリファクタリングできます
それを汎用にするために。専用
アプローチはインクリメンタルと一致しているようです
ソフトウェア開発へのアプローチ。

私が最初にソフトウェアを教え始めたとき
デザインコース私は2番目のアプローチに傾倒しました
（そもそも特別な目的にする）しかしその後
コースを数回教えて、自分を変えました
マインド。学生のプロジェクトをレビューする際に私は気づきました
その汎用クラスはほとんど常にでした
特別な目的の選択肢よりも優れています。何
特に驚いたのは、汎用：\ work \ Kindle \ phil \095.png@@インターフェースが特別なものよりもシンプルで深いことです-
目的のもの、そしてそれらはより少ないコードをもたらします
実装。使っても
特別な目的でクラスを組むと、作業が減ります
汎用的な方法で構築します。そして、一般的な-
目的のアプローチはあなたをさらに多くの時間を節約することができます
将来、他の目的でクラスを再利用する場合。
ただし、そうでなくても汎用の方が優れています
クラスを再利用します。

私の経験では、スイートスポットは実装することです
やや汎用の新しいモジュール
ファッション。 「やや汎用」というフレーズ
モジュールの機能が必要であることを意味します
あなたの現在のニーズを反映しますが、そのインターフェースは
いいえ。代わりに、インターフェースは十分に一般的である必要があります
複数の用途をサポートします。インターフェイスは
することなく、今日のニーズに簡単に使用できます
それらに特に結びついています。 「やや」という言葉
重要です：夢中になって構築しないでください
非常に汎用的で、難しいもの
現在のニーズに合わせて使用​​してください。

6.2例：エディター用のテキストの保存

ソフトウェア設計の例を考えてみましょう
学生がsimpled：\ work \ Kindle \ phil \ 096.png@@GUIテキストエディタを作成するように求められたクラス。エディターはファイルを表示する必要がありました
ユーザーがポイント、クリック、入力して編集できるようにします
ファイル。また、複数の同時をサポートする必要がありました
異なるウィンドウでの同じファイルのビュー、および

マルチレベルの元に戻すとやり直しをサポートする必要がありました
ファイルへの変更。

各学生プロジェクトには、次のようなクラスが含まれていました。
ファイルの基になるテキストを管理しました。テキスト
クラスは通常、
ファイルをメモリに入れ、のテキストを読み取って変更します
ファイル、および変更されたテキストをファイルに書き戻します。
学生チームの多くは特別に実装しました-
テキストクラスの目的API。

彼らはクラスが使われることを知っていました
インタラクティブエディタで、彼らは考えました
その機能
編集者は提供しなければならなかった
テキストクラスのAPIを特定のものに合わせて調整
特徴。たとえば、エディタのユーザーの場合
バックスペースキーを入力すると、エディタは
カーソルのすぐ左にある文字。もしも
ユーザーが削除キーを入力すると、エディターが削除しました
カーソルのすぐ右側の文字。
これを知って、いくつかのチームはそれを作成しました
これらのそれぞれをサポートするためのテキストクラスのメソッド
特定の機能：

void backspace（カーソルカーソル）; d：\ work \ kindle \ phil \ 097.png @@ void delete（カーソルカーソル）;

これらの各メソッドはカーソル位置を取ります
その議論として;特別なタイプのカーソルは
この位置。編集者はまた、
コピーまたは削除できる選択。 The
学生は選択クラスを定義することによってこれを処理しました
このクラスのオブジェクトをテキストクラスに渡します

削除中：

void deleteSelection（選択選択）;

学生たちはおそらくそれが
次の場合、ユーザーインターフェイスの実装が簡単になります
テキストクラスのメソッドは、
ユーザーに表示される機能。しかし実際には、これは
専門化はユーザーにほとんど利益をもたらさなかった
インターフェースコード、そしてそれは高い認知的負荷を生み出しました
いずれかのユーザーインターフェイスで作業している開発者向け
またはテキストクラス。テキストクラスは最終的に
多数の浅いメソッド、それぞれ
1つのユーザーインターフェイス操作にのみ適していました。
削除などのメソッドの多くは、
1か所で呼び出されます。その結果、開発者
ユーザーインターフェイスでの作業は、
テキストクラスの多数のメソッド。

このアプローチは情報漏えいを引き起こしました
ユーザーインターフェイスとテキストクラスの間。
d：\ work \ Kindle \ phil \098.png@@選択やバックスペースキーなどのユーザーインターフェイスに関連する抽象化が反映されました
テキストクラスで;これは認知的負荷を増加させました
テキストクラスに取り組んでいる開発者向け。それぞれの新しい
ユーザーインターフェイスの操作には新しい方法が必要でした

テキストクラスで定義されるので、開発者
ユーザーインターフェイスでの作業は、最終的には
テキストクラスにも取り組んでいます。目標の1つ
クラスの設計では、各クラスを開発できるようにすることです
独立して、しかし専門的なアプローチは結びついた
ユーザーインターフェイスとテキストクラスを一緒に。

6.3より汎用的なAPI

より良いアプローチは、テキストクラスをより多くすることです
ジェネリック。そのAPIは、次の観点からのみ定義する必要があります。
より高いものを反映せずに、基本的なテキスト機能-
で実装されるレベルの操作

それ。たとえば、必要なメソッドは2つだけです。
テキストの変更：

void insert（Position position、String newText）;

void delete（Position start、Position end）;

最初のメソッドは、任意の文字列を
テキスト内の任意の位置、および2番目
メソッドは、位置にあるすべての文字を削除します
開始以上で終了未満。これ
APIは、代わりに、より一般的なタイプのPositionも使用します
特定のユーザーインターフェイスを反映するカーソルの。d：\ work \ Kindle \ phil \099.png@@テキストクラスも汎用を提供する必要があります
内の位置を操作するための設備
次のようなテキスト：

位置変更Position（位置位置、int

numChars）;

このメソッドは、指定された新しい位置を返します
特定の位置から離れた文字数。
numchars引数が正の場合、新しい
位置は、ファイル内で位置よりも後です。 numcharsの場合
が負の場合、新しい位置は位置の前にあります。 The
メソッドは自動的に次または前にスキップします
必要に応じて線を引きます。これらの方法では、
削除キーは、次のように実装できます
コード（カーソル変数が
現在のカーソル位置）：

text.delete（cursor、text.changePosition（cursor、1））;
同様に、バックスペースキーは次のように実装できます。
次のとおりです。

text.delete（text.changePosition（cursor、-1）、cursor）;

汎用テキストAPIを使用すると、
削除などのユーザーインターフェイス機能を実装する
バックスペースは元のスペースよりも少し長くなります
特殊なテキストAPIを使用したアプローチ。でも、
新しいコードは古いコードよりも明白です。

ユーザーインターフェイスモジュールで作業している開発者
おそらくどの文字が削除されるかを気にします
バックスペースキーで。新しいコードでは、これはisd：\ work \ Kindle \ phil \100.png@@明らかです。古いコードでは、開発者は行かなければなりませんでした
テキストクラスに移動し、ドキュメントを読んだり、
動作を検証するためのバックスペースメソッドのコード。
さらに、汎用アプローチには
特殊なアプローチよりも全体的に少ないコード、
それは多くの特別な目的に取って代わるので
数が少ないテキストクラスのメソッド
汎用のもの。

一般的に実装されたAtextクラス-
目的のインターフェースは、
インタラクティブエディタ以外の目的。一つとして
たとえば、アプリケーションを構築していると仮定します
すべてを置き換えることによって指定されたファイルを変更した
特定の文字列と別の文字列の出現
ストリング。特殊なテキストクラスのメソッドなど
バックスペースとdeleとしてte、
このアプリケーション。 ただし、汎用テキスト
クラスにはすでにほとんどの機能があります
新しいアプリケーションに必要です。 欠けているものすべて
の次の出現を検索する方法です

次のような指定された文字列：

位置findNext（位置開始、文字列文字列）;

もちろん、インタラクティブなテキストエディタは

で、検索と置換のためのメカニズムを持っています
この場合、テキストクラスにはすでにこれが含まれています
方法。




