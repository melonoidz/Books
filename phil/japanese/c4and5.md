d：\ work \ Kindle \ phil \201.png@@それらを書くことに取り掛かる。幸いなことに、多くの
開発チームは、
ドキュメント、そしてそれはの普及のように感じます
これらのチームは徐々に増えています。しかし、
ドキュメント、コメントを奨励するチームで
多くの場合、恨みの仕事と見なされ、多くの
開発者はそれらの書き方を理解していません、

そのため、結果として得られるドキュメントは平凡なものになることがよくあります。
不十分なドキュメントは巨大な
ソフトウェア開発の不必要なドラッグ。

この章では、言い訳について説明します
開発者はコメントを書かないようにするために使用し、
コメントが本当に重要である理由。章
13はそれから良いコメントを書く方法を説明します
その後の次の数章で説明します
変数名の選択や
ドキュメントを使用してシステムを改善する方法
設計。これらの章があなたを納得させることを願っています
3つのことの：良いコメントは大きなものになる可能性があります
ソフトウェアの全体的な品質の違い。そうではありません
良いコメントを書くのは難しい。および（これは
信じがたい）コメントを書くことは実際にすることができます
楽しい。

開発者がコメントを書かないとき、彼らは
通常、1つまたは複数の

次の言い訳：d：\ work \ kindle \ phil \ 202.png@@+「良いコードは自己文書化です。」
-「コメントを書く時間がありません。」
-「コメントは古くなり、
誤解を招く。」
-「私が見たコメントはすべて価値がありません。
なぜわざわざ？」
以下のセクションでは、これらのそれぞれについて説明します

順番に言い訳。

12.1優れたコードは自己文書化です

一部の人々は、コードがうまく書かれていれば、

コメントは必要ないほど明白です。これ

アイスクリームが
あなたの健康に良い：私たちは本当にそれを信じたいです！
残念ながら、それは単に真実ではありません。確かに、そこに
削減するコードを書くときにできることです
良いものを選ぶなどのコメントの必要性
変数名（第14章を参照）。それにもかかわらず、そこに
まだかなりの量の設計情報です
コードで表現することはできません。例えば、

クラスのインターフェースのごく一部、たとえば
そのメソッドのシグネチャは、正式に指定できます
コードで。インターフェイスの非公式な側面、
それぞれの内容の概要など
メソッドが行うか、その結果の意味は、コメントでのみ記述できます：\ work \ Kindle \ phil \203.png@@。他にもたくさんあります
で説明できないことの例
特定の設計の理論的根拠などのコード
決定、またはそれが行う条件
特定のメソッドを呼び出す意味。

一部の開発者は、他の開発者が
メソッドが何をするかを知っている、彼らはただ読むべきです
メソッドのコード：これはより正確になります
どんなコメントより。読者ができる可能性があります
次の方法でメソッドの抽象インターフェイスを推測します
そのコードを読むが、それは時間がかかるだろう
と痛い。さらに、でコードを書く場合
ユーザーがメソッドを読むことへの期待
実装では、各メソッドを作成しようとします
読みやすいように、できるだけ短くします。の場合
メソッドは重要なことを何でもします、あなたはそれを壊します
いくつかの小さな方法に。これにより、
多数の浅い方法。さらに、それは
コードを実際に読みやすくするわけではありません。
トップレベルのメソッドの動作を理解するには、
読者はおそらく理解する必要があります
ネストされたメソッドの動作。大規模システムの場合
ユーザーがコードを読んで学習するのは現実的ではありません
動作。

さらに、コメントは
抽象化。第4章から、d：\ work \ Kindle \ phil \ 204.png @@抽象化の目標は、複雑さを隠すことであるということを思い出してください。抽象化
エンティティの簡略化されたビューであり、
重要な情報ですが、できる詳細は省略しています
安全に無視されます。ユーザーがコードを読む必要がある場合

それを使用するためのメソッドの場合、
抽象化：メソッドの複雑さはすべて
露出。コメントなしで、唯一の抽象化
メソッドの宣言は、その宣言です。
名前とその引数の名前とタイプ
と結果。宣言もありません

有用な情報を提供するための多くの重要な情報
抽象化自体。たとえば、
サブストリングの抽出には2つの引数があります。
開始と終了、文字の範囲を示します
エキス。宣言だけでは不可能です
抽出された部分文字列に含まれるかどうかを確認する
終わりで示される文字、または何が起こるか

開始>終了の場合。コメントにより、
発信者が必要とする追加情報、それによって
非表示にしながら簡略化されたビューを完成させる
実装の詳細。また、
コメントはそのような人間の言語で書かれています
英語として;これにより、コードよりも精度が低くなります。
しかし、それはより表現力を提供するので、
シンプルで直感的な説明を作成します。 tod：\ work \ Kindle \ phil \ 205.png @@抽象化を使用して複雑さを隠す場合、コメントは次のとおりです。
必要不可欠。

12.2コメントを書く時間がない

コメントを優先するのは魅力的です

よりも
その他の開発タスク。からの選択を与えられた
新しい機能を追加し、既存の機能を文書化する
機能、新しい機能を選択するのは理にかなっているようです。
ただし、ソフトウェアプロジェクトはほとんどの場合
時間のプレッシャー、そして常に
コメントを書くよりも優先度が高いようです。したがって、
ドキュメントの優先順位を下げることを許可した場合、
ドキュメントがなくなるでしょう。

この言い訳に対する反論は、
15ページで説明されている投資の考え方。
クリーンなソフトウェア構造が必要です。
長期にわたって効率的に作業できるようにし、
それからあなたは前もって少し余分な時間をとらなければなりません
その構造を作成するため。良いコメント
の保守性に大きな違いをもたらす
ソフトウェアなので、それらに費やされた努力はお金を払うでしょう
すぐにそれ自体。さらに、コメントを書く
多くの時間をかける必要はありません。いくらか自問してみてください
入力に費やす開発時間の
コメントを含めないことを前提としたコード（設計、コンパイル、テスト、d：\ work \ Kindle \ phil \ 206.png @@などとは対照的）。
答えが10％以上だとは思えません。今
タイピングに同じくらいの時間を費やしているとしましょう
入力コードとしてのコメント。これは安全なはずです
上界。これらの仮定で、書く
良いコメントは約10％以上追加されません
あなたの開発時間に。持つことの利点
優れたドキュメントは、このコストをすぐに相殺します。
さらに、最も重要なものの多く
コメントは抽象化に関連するものです、
クラスのトップレベルのドキュメントなど
とメソッド。第15章はこれらが
コメントは、の一部として書く必要があります
デザインプロセス、そしてそれを書く行為は
ドキュメントは重要な設計ツールとして機能します
それは全体的なデザインを改善します。これらのコメント

すぐに自分で支払います。

12.3コメントが古くなり、
誤解を招くようになる

コメントは古くなることがありますが、

これは実際には大きな問題である必要はありません。
ドキュメントを最新の状態に保つことはしません
多大な努力が必要です。に大きな変更
ドキュメントは、次の場合にのみ必要です。\ work \ Kindle \ phil \ 207.png @@コードに大幅な変更があり、コードが変更された場合
ドキュメントよりも時間がかかります
変更します。第16章では、整理する方法について説明します
可能な限り簡単にできるようにドキュメント
コード変更後も最新の状態に保つ（キー
アイデアは、ドキュメントの重複を避けることであり、
ドキュメントを対応するものに近づけてください
コード）。コードレビューは、
古いコメントの検出と修正。

12.4私が見たすべてのコメントは

価値がない

4つの言い訳のうち、これはおそらく
最もメリット。すべてのソフトウェア開発者は見た
有用な情報を提供しないコメント、

そして、ほとんどの既存のドキュメントは、せいぜいまあまあです。
幸い、この問題は解決可能です。しっかりと書く
方法がわかれば、ドキュメントは難しくありません。
次の章では、そのためのフレームワークについて説明します。
優れたドキュメントを作成し、それを維持する
時間。

12.5よく書かれたコメントの利点
これで、書くことに対する議論について話し合った（そして、うまくいけば、d：\ work \ Kindle \ phil \ 208.png @@ debunked）
コメント、あなたがもたらすメリットについて考えてみましょう
良いコメントから得られます。全体的なアイデア
コメントの背後にあるのは、
デザイナーの頭の中にありましたが、できませんでした
コードで表されます。この情報の範囲
ハードウェアの癖などの低レベルの詳細から
これは、特にトリッキーなコードを動機付けます。
理論的根拠などの高レベルの概念まで

クラスのために。他の開発者がやってくるとき
後で変更を加えるために、コメントは
彼らがより迅速かつ正確に働くことを可能にします。
ドキュメントなしで、将来の開発者

開発者を再検討または推測する必要があります
独自の知識;これにはさらに時間がかかりますが、
新しい開発者がいる場合、バグのリスクがあります
元の設計者の意図を誤解しています。
オリジナルの場合でもコメントは貴重です
変更を行うのはデザイナーです。
あなたが最後に働いてから数週間以上経ちました
コードの一部で、あなたは多くのことを忘れているでしょう
オリジナルデザインの詳細。

第2章では、3つの方法について説明しました
複雑さはソフトウェアシステムに現れます。
変化の増幅：一見単純な変化
多くの場所でコードの変更が必要です。d：\ work \ kindle \ phil \ 209.png @@認知的負荷：変更を加えるには、
開発者は大量に蓄積する必要があります
情報。

不明な不明：どのコードかは不明です
変更する必要がある、またはどのような情報である必要があります
それらの変更を行うために考慮されます。

優れたドキュメントは、最後の2つに役立ちます
これらの問題。ドキュメントは認知を減らすことができます
開発者に情報を提供してロードする
彼らは変更を加える必要があり、それを行うことによって
開発者がその情報を無視しやすい
無関係です。適切なドキュメントがなければ、
開発者は大量のコードを読まなければならない場合があります
デザイナーの心にあったものを再構築します。
ドキュメントは未知のものを減らすこともできます
u

の構造を明確にすることで既知
システム、どのような情報と
コードは、特定の変更に関連しています。

第2章では、
複雑さは依存関係とあいまいさです。良い
ドキュメントは依存関係を明確にすることができ、それは満たされます
あいまいさを排除するためにギャップで。

次のいくつかの章では、その方法を説明します
良いドキュメントを書いてください。彼らはまた議論します
ドキュメントの作成をthed：\ work \ Kindle \ phil \ 210.png @@デザインプロセスに統合して、
あなたのソフトウェア。

12.6別の意見：コメントは
失敗

彼の著書「CleanCode」では、RobertMartinがさらに多くのことを取り上げています。
コメントの否定的な見方：

..コメントはせいぜい必要な悪です。もしも
私たちのプログラミング言語は表現力豊かでした
十分、または微妙に才能がある場合
私たちの意図を表現するためにそれらの言語を振るう、
コメントはあまり必要ありません
おそらくまったくないでしょう。

コメントの適切な使用法は次のとおりです。
表現の失敗を補う
私たち自身のコード....コメントは常に
失敗。できないので持っていなければなりません
常に自分を表現する方法を理解する
それらなしで、しかしそれらの使用はのための原因ではありません
お祝い。

私は、優れたソフトウェア設計が
コメントの必要性（特にメソッドのコメント）
体）。ただし、コメントは失敗を表すものではありません。d：\ work \ kindle \ phil \211.png@@コメントが提供する情報はまったく異なります。
コードによって提供されるものから、そしてこの情報
今日のコードでは表現できません。コードと
コメントはそれぞれ物事に適しています
それらは代表し、それぞれが重要なものを提供します
利点;コメントの情報があっても
どういうわけかコードにキャプチャされる可能性がありますが、不明です
これは改善になるだろうと。

コメントの目的の1つは、
コードを読む必要はありません。たとえば、
メソッドの全体を読み取る代わりに、

開発者は短いインターフェースコメントを読むことができます
するために必要なすべての情報を取得する
メソッドを呼び出します。マーティンは反対を取ります
タック：彼はコメントを次のように置き換えることを提唱しています
コード。説明するコメントを書く代わりに
メソッドのコードブロックで何が起こっているのか、
マーティンは、そのブロックを引き出して
別の方法（コメントなし）と使用
の代わりとしてのメソッドの名前
コメント。これにより、次のような長い名前になります
isLeastRelevantMultipleOfNextLargerPrimeFactor。
これらすべての言葉があっても、このような名前は
不可解であり、井戸よりも少ない情報を提供します-
書かれたコメント。そして、このアプローチでは、
開発者は、メソッドのthed：\ work \ Kindle \ phil \212.png@@ドキュメントを毎回効果的に再入力することになります。
それを呼び出します！

マーティンの哲学が奨励しているのではないかと心配しています
プログラマーの悪い態度、彼らは避けます
失敗のように見えないようにコメントします。これは可能性があります
優れた設計者が虚偽に陥ることさえあります
批判：「コードの何が問題になっていますか？
コメントが必要ですか？」

よく書かれたコメントは失敗ではありません。彼ら
コードの価値を高め、基本的なサービスを提供する
抽象化の定義とシステムの管理における役割

Complexity.d:\work\kindle\phil\213.png@@第13章

コメントは説明する必要があります
自明ではないこと
コードから

コメントを書く理由は
プログラミング言語のステートメントはできません
だったすべての重要な情報をキャプチャします
コードがあったときに開発者の心の中で
書かれました。コメントはこの情報を記録するので
後でやってくる開発者は簡単に
コードを理解して変更します。ガイド
コメントの原則は、コメントは
から明らかではないことを説明する
コード。はっきりしないことがたくさんあります
コードから。時々それは低レベルの詳細です
明らかではありません。たとえば、インデックスのペアが
範囲を説明しますが、
インデックスで指定された要素は、ranged：\ work \ Kindle \ phil \214.png@@またはoutの範囲内にあります。コードが必要な理由が明確でない場合がありますが、
または、なぜそれが特定の方法で実装されたのか。
開発者が従ったルールがある場合がありますが、
「常にbの前にaを呼び出す」など。あなたはできるかもしれません
すべてのコードを見てルールを推測しますが、これは
痛みを伴い、エラーが発生しやすい。コメントはすることができます
明確で明確なルール。

の最も重要な理由の1つ
コメントは抽象化であり、多くの
コードからは明らかではない情報。 The
抽象化のアイデアは、次の簡単な方法を提供することです。
何かを考えていますが、コードはとても詳細です
からの抽象化を見るのは難しいかもしれません
コードを読む。コメントは、より単純な、
上位レベルのビュー（「このメソッドが呼び出された後、
ネットワークトラフィックはmaxBandwidthに制限されます
1秒あたりのバイト数」）。この情報ができるとしても
コードを読んで推測されるので、
モジュールのユーザーにそれを強制する：コードを読む
時間がかかり、検討を余儀なくされます
を使用するために必要ではない多くの情報
モジュール。開発者は理解できる必要があります
モジュールによって提供される抽象化なし
以外のコードを読み取る

その外部的に
目に見える宣言。これを行う唯一の方法は
コメントで宣言を補足します。d：\ work \ Kindle \ phil \ 215.png @@この章では、必要な情報について説明します。
コメントと書き方で説明する
良いコメント。ご覧のとおり、良いコメント
通常、さまざまな詳細レベルで物事を説明します
いくつかでより詳細なコードよりも
状況と詳細度が低い（より抽象的な）
その他。

13.1選択規則

コメントを書くための最初のステップは決定することです

コメントの慣習について
コメントし、使用する形式
コメント。言語でプログラミングしている場合
ドキュメントの編集が存在する
JavaのJavadoc、C ++のDoxygen、または
Go！のgodocは、ツールの規則に従ってください。
これらの規則はどれも完璧ではありませんが、ツールは
それを補うのに十分な利益を提供します。もしも
あなたは次のような環境でプログラミングしています
従うべき既存の規則はありません。
他の言語の規則を採用する
または類似したプロジェクト。これにより、
他の開発者があなたを理解し、遵守する
Conventions.d：\ work \ Kindle \ phil \216.png@@コンベンションには2つの目的があります。まず、彼らは
一貫性を確保し、コメントを容易にします
読んで理解する。第二に、彼らは確実にするのに役立ちます
あなたが実際にコメントを書くこと。お持ちでない場合
コメントする内容を明確にし、
どのように、コメントをまったく書かないことになりがちです。

ほとんどのコメントは次のいずれかに該当します
カテゴリ：

インターフェース：すぐにコメントブロック
クラスなどのモジュールの宣言に先行し、
データ構造、関数、またはメソッド。コメント
モジュールのインターフェースについて説明します。クラスの場合、

コメントは全体的な抽象化について説明しています
クラスによって提供されます。メソッドまたは関数の場合、
コメントは、その全体的な動作、
引数と戻り値（ある場合）、いずれかの側

それが生成する効果または例外、および
発信者が前に満たさなければならないその他の要件
メソッドを呼び出します。

データ構造メンバー：横のコメント
次のようなデータ構造内のフィールドの宣言
クラスのインスタンス変数または静的変数。
実装コメント：内部のコメント
メソッドまたは関数のコード。
コードは内部で機能します。d：\ work \ Kindle \ phil \ 217.png @@クロスモジュールコメント：説明するコメント
モジュールの境界を越える依存関係。

最も重要なコメントは、
最初の2つのカテゴリ。すべてのクラスには
インターフェイスコメント、すべてのクラス変数は
コメントがあり、すべてのメソッドには
インターフェイスコメント。時折、宣言
変数またはメソッドの場合、
コメントに追加するのに役立つものは何もありません（ゲッターと
セッターは時々このカテゴリーに分類されます）、しかしこれは

まれです。むしろすべてにコメントする方が簡単です
かどうかを心配してエネルギーを費やすよりも
コメントが必要です。実装コメントは
多くの場合不要です（以下のセクション13.6を参照）。クロス-
モジュールのコメントはすべての中で最もまれであり、
書くのは難しいですが、必要なとき
それらは非常に重要です。セクション13.7で説明します
それらをより詳細に。

13.2コードを繰り返さないでください
残念ながら、多くのコメントはそうではありません
特に役に立ちました。最も一般的な理由
コメントがコードを繰り返すということです：すべての

コメント内の情報は、コメントの横のコードから簡単に推測できます：\ work \ Kindle \ phil \218.png@@。これがコードです

最近の研究論文に登場したサンプル：
ptr_copy = get_copy（obj）＃ポインタコピーを取得
もしも

＃objは無料ですか？
‘is_unlocked（ptr_copy）：

return obj＃現在のobjを返す
if is_copy（ptr_copy）：＃すでにコピーですか？
return obj＃return obj

thread_id = get_thread_id（ptr_copy）

thread_id==の場合

＃現在のctxによってロックされています
ctx。 thread_id：

return ptr_copy＃コピーを返す

これらのいずれにも有用な情報はありません
「Lockedby」コメント以外のコメント、
これは、スレッドについて何かを示唆しています
コードからは明らかではないかもしれません。注意してください
これらのコメントはほぼ同じレベルです
コードとしての詳細：1行に1つのコメントがあります
その行を説明するコード。このようなコメント
めったに役に立ちません。

コメントの例は次のとおりです
コードを繰り返します：

//水平scro1]バーを追加します
hScrol1Bar = new JScro11Bar（JScrol1Bar.HORIZONTAL）;
add（hScrol1Bar、BorderLayout.SOUTH）;

//垂直scro1]バーを追加します
vScrol1Bar = new JScro11Bar（JScro11Bar.VERTICAL）;
add（vScrol1Bar、BorderLayout.EAST）; d：\ work \ Kindle \ phil \ 219.png@@//キャレット位置に関連する値を初期化します

caretX = 0;

caretY = 0;

caretMemX = null;

これらのコメントはどれも価値を提供しません。にとって
最初の2つのコメント、コードはすでに明確です
コメントは必要ありません。の
3番目のケースでは、コメントが役立つ場合がありますが、
現在のコメントでは、
役に立ちます。

コメントを書いたら、自問してみてください
次の質問：
コードを見たことがないw

コメントを書くだけで
コメントの横のコードを見ていますか？の場合
上記の例のように、答えは「はい」です。
コメントはコードを簡単にするものではありません
理解する。このようなコメントが理由
人々はコメントは無価値だと思います。

もう1つのよくある間違いは、同じものを使用することです
の名前で表示されるコメント内の単語

文書化されているエンティティ：
yp
*REQから正規化されたリソース名を取得します。
* /
private static String [] getNormalizedResourceNames（

HTTPRequest req）..。
あなたがたは
*パラメータをTYPEにダウンキャストします。
* / d：\ work \ Kindle \ phil \ 220.png @@ private static Object downCastParameter（String
パラメータ、

文字列型）..。

あなたがたは

*テキストの各行の水平方向のパディング。

* /
private static final int textHorizo​​ntalPadding = 4;

 赤旗：コメント
コードWSを繰り返します

コメントの情報がすでにある場合
コメントの横のコードから明らかなように、
その場合、コメントは役に立ちません。一例
これはコメントが同じものを使用している場合です
それが物の名前を構成する言葉

記述。

これらのコメントは、
メソッドまたは変数名、おそらくいくつかの単語を追加します
引数の名前と型から、それらを形成します
文に。たとえば、
コードにない2番目のコメントは単語です
"に"！もう一度、これらのコメントを書くことができます
宣言を見るだけで、何もしません：\ work \ Kindle \ phil \221.png@@変数のメソッドを理解します。結果として、
それらには価値がありません。

同時に、重要なことがあります
コメントから欠落している情報：
たとえば、「正規化されたリソース名」とは何ですか。
によって返される配列の要素は何ですか
getNormalizedResourceNames？ 「ダウンキャスト」とは
平均？パディングの単位は何ですか、そして
各行の片側または両方にパディング？記述
コメントのこれらのことは役に立ちます。

良いコメントを書くための最初のステップは
コメントにそれらとは異なる単語を使用する
説明されているエンティティの名前で。選ぶ
追加を提供するコメントの言葉
むしろ実体の意味についての情報
その名前を繰り返すだけではありません。たとえば、ここにあります

textHori zontal Paddingのより良いコメント：
y *

*左側に残す空白の量と

*テキストの各行の右側（ピクセル単位）。
* /

private static final int textHorizo​​ntalPadding = 4;

このコメントは追加情報を提供します
それは宣言自体からは明らかではありませんが、
単位（ピクセル）やパディングなど
各行の両側に適用されます。使用する代わりに
「パディング」という用語のコメントは、whatd：\ work \ Kindle \ phil \ 222.png @@パディングについて説明しています。読者がまだ慣れていない場合は、
用語で。

13.3下位レベルのコメントは精度を追加します
してはいけないことがわかったので、話し合いましょう
コメントにどのような情報を入れるべきか。
コメントは、提供することによってコードを補強します
異なる詳細レベルの情報。いくつかの
コメントは、より低い、より多くの情報を提供します
詳細、コードよりもレベル。これらのコメントは追加します
の正確な意味を明確にすることによる精度
コード。他のコメントはで情報を提供します
コードよりも高く、より抽象的なレベル。これらは
コメントは、推論などの直感を提供します
コードの背後、またはより単純でより抽象的な方法
コードについて考えること。同時にコメント
コードがコードを繰り返す可能性が高いため、レベル。これ
セクションでは、より低いレベルのアプローチについて詳しく説明します
詳細、および次のセクションでは、より高い-
レベルのアプローチ。

精度はコメントするときに最も役立ちます
クラスインスタンスなどの変数宣言
変数、メソッド引数、および戻り値。
変数宣言の名前とタイプは次のとおりです。\work\ Kindle \ phil \ 223.png @@通常、あまり正確ではありません。コメントは記入できます
次のような詳細が欠落しています：

+この変数の単位は何ですか？

+境界条件は包括的ですか？
エクスクルーシブ？

-null値が許可されている場合、それは何をしますか
意味する？

+ Ifa変数は、必要なリソースを参照します
最終的には解放または閉鎖されます
それを解放または閉じる責任がありますか？

+常にある特定のプロパティはありますか
次のような変数（不変量）の場合はtrue
「このリストには常に少なくとも1つのエントリが含まれています」？

この情報の一部は潜在的に
すべてのコードを調べて理解しました
変数が使用されます。ただし、これには時間がかかります
エラーが発生しやすい。宣言のコメント
明確で完全なものにする必要があります
これは不要です。ちなみに、
宣言のコメントは物事を説明する必要があります
コードからは明らかではありませんが、「コード」とは
コメント（宣言）の横のコードに、
「アプリケーション内のすべてのコード」ではありません。

コメントに関する最も一般的な問題

変数は、コメントがあいまいすぎることです。 Hered：\ work \ Kindle \ phil \ 224.png @@は、正確ではないコメントの2つの例です

足りる：

//応答バッファの現在のオフセット
uint32_tオフセット;

//ドキュメント内のすべての線幅と
//出現数。

プライベートTreeMap<整数、整数

ger>線幅;

最初の例では、「現在」が何であるかが明確ではありません
意味。 2番目の例では、
TreeMapのキーは線幅で、値は
発生回数。また、幅はで測定されます
ピクセルまたは文字？以下の改訂されたコメント
追加の詳細を提供します。

//最初のオブジェクトのこのバッファに配置します
していません
//クライアントに返されます。

uint32_tオフセット;

//フォームの行の長さに関する統計を保持します
<長さ、カウント>

//ここで、lengthは1行の文字数です
含む

//改行）、countは次の行の数です
//まさにその数の文字。行がない場合
と

// @特定の長さの場合、そのエントリはありません
強さ。

プライベートTreeMap<整数、整数> numLinesWithLength;

2番目の宣言では、より長い名前を使用しています。
より多くの情報を伝えます。また、「width」d：\ work \ kindle \ phil \ 225.png @@を「length」に変更します。これは、この用語が
ユニットはキャラクターだと人々に思わせる
ピクセルではなく。 2番目のコメントに注意してください
各エントリの詳細だけでなく、
また、エントリが欠落している場合の意味もあります。

変数を文書化するときは、名詞ではなく名詞を考えてください
動詞。言い換えれば、変数が何であるかに焦点を当てる
それがどのように操作されるかではなく、を表します。考えます

次のコメント：
/ * FOLLOWER VARIABLE：を可能にするインジケーター変数

レシーバーと

かどうかについて通信するPeriodicTasksスレッド

ハートビートはされています

フォロワーの選挙タイムアウト内に受信

窓。

有効なハートビートが受信されると、TRUEに切り替えられます。

選挙タイムアウトウィンドウが
リセットします。 * /

プライベートブールreceivedValidHeartbeat;

このドキュメントでは、変数がどのようになっているのかを説明しています

クラス内のいくつかのコードによって変更されました。 The
コメントは短くなり、より便利になります
変数ではなく、変数が何を表すかを説明します

コード構造のミラーリング：
/ * Trueは、それ以降にハートビートが受信されたことを意味します

前回

選挙タイマーがリセットされました。通信に使用

間に

*ReceiverおよびPeriodicTasksスレッド。 *

private boolean receiveValidHeartbeat; d：\ work \ Kindle \ phil \ 226.png @@このドキュメントがあれば、簡単に推測できます。
ハートビートが
受信し、選択タイマーがリセットされるとfalseになります。

13.4上位レベルのコメントは強化します
直感

コメントを増やすことができる2番目の方法

コードは直感を提供することによるものです。これらのコメント

コードよりも高いレベルで書かれています。彼ら

詳細を省略し、読者が理解できるようにする

コードの全体的な意図と構造。これ

アプローチは、内部のコメントに一般的に使用されます

メソッドとインターフェースコメント用。例えば、

次のコードを検討してください。
//同じセッションを使用しているLOADINGreadRpcがある場合
// PKHashがassignPosによってポイントされ、最後の
PKHash
//そのreadRPCは現在の割り当てよりも小さい
// PKHash、次にPKHashの割り当てをその中に入れます
readRPC。
int readActiveRpcId = RPC_ID_NOT_ASSIGNED;
for（int i 0; i <NUM_READ_RPC; i ++）{

if（session == readRpc [i] .session

&& readRpc [i] .status == LOADING

&& readRpc [i] .maxPos <assignPos

&& readRpc [i] .numHashes <MAX_PKHASHES_PERRPC）{

readActiveRpcld =

break; d：\ work \ Kindle \ phil \ 227.png @@}
コメントは低レベルで詳細すぎます。に

一方では、コードを部分的に繰り返します。
はLOADINGreadRPCです」は、テストを複製するだけです。
readRpc [i] .status==LOADING。一方、
コメントはこれの全体的な目的を説明していません
コード、またはそれを含むメソッドにどのように適合するか。
結果として、コメントは読者がするのを助けません
コードを理解します。

ここにもっと良いコメントがあります：

//現在のキーハッシュを既存のキーハッシュに追加してみます

//まだ送信されていない目的のサーバーへのRPC。

このコメントには詳細は含まれていません。代わりは、
コードの全体的な機能をより高いレベルで記述します
レベル。この高レベルの情報で、読者
で起こるほとんどすべてを説明することができます

コード：ループはすべての
既存のリモートプロシージャコール（RPC）。セッション
テストは、特定のRPCかどうかを確認するために使用される可能性があります

適切なサーバーに向けられています。負荷テスト
RPCが複数の状態を持つことができることを示唆し、
一部の州では、ハッシュを追加するのは安全ではありません。 the
MAX_PKHASHES_PERRPCテストは、
1回に送信できるハッシュの数に制限
RPC。コメントで説明されていない唯一のこと
maxPosテストです。さらに、新しいコメント：\ work \ Kindle \ phil \ 228.png @@は、読者がコードを判断するための基礎を提供します。
キーハッシュを追加するために必要なすべてを実行します
既存のRPCに？元のコメントはしませんでした
コードの全体的な意図を説明するので、難しい
読者がコードが動作しているかどうかを判断するため
正しく。

上位レベルのコメントはより困難です
あなたのために低レベルのコメントよりも書く
別の方法でコードについて考える必要があります。聞く
あなた自身：このコードは何をしようとしていますか？何ですか
あなたができる最も簡単なこと

それがすべてを説明すると言う
コードで？最も重要なことは何ですか
このコードについて？

エンジニアは非常に詳細を重視する傾向があります。我々
詳細が大好きで、それらの多くを管理するのが得意です。
これは、優れたエンジニアになるために不可欠です。しかし、素晴らしい
ソフトウェア設計者は、
詳細を確認し、より高いレベルのシステムについて考えます。
これは、システムのどの側面を決定することを意味します
最も重要であり、無視することができます
低レベルの詳細とシステムのみについて考える
その最も基本的な特性の観点から。
これが抽象化の本質です（単純なものを見つける
複雑な実体について考える方法）、そしてそれは
また、より高いレベルを書くときにあなたがしなければならないこと

コメント。優れた上位レベルのコメントは次のように表現されます：\ work \ Kindle \ phil \229.png@@概念を提供する1つまたはいくつかの簡単なアイデア
「既存のRPCに追加する」などのフレームワーク。
フレームワークを考えると、どのように理解するのが簡単になります
特定のコードステートメントは、全体的な目標に関連しています。

これは別のコードサンプルです。
上位レベルのコメント：

if（numProcessedPkHashes <readRpc [i] .numHashes）{
//キーハッシュの一部を検索できませんでした
//このリクエスト（保存されていないため）
//サーバー上で、サーバーがクラッシュしたか、
//応答メッセージに十分なスペースがありませんでした）。
//未処理のハッシュにマークを付けて、
//新しいRPCに再割り当てされます。
for（size_t p = removePos; p <insertPos; p ++）{
if（activeRpcld [p] == i）{
if（numProcessedPkKHashes> 0）{
numProcessedPkHashes--;
} そうしないと {
if（p <assignPos）
assignPos = p;

activeRpcId [p] = RPC_ID_NOT_ASSIGNED;

}
このコメントは2つのことを行います。二番目

文は何の抽象的な説明を提供します
コードはそうします。最初の文は異なります：それ
コードがなぜであるかを（高レベルの用語で）説明します
実行されました。 「どうやってここにたどり着くか」というフォームのコメントd：\ work \ Kindle \ phil \ 230.png @@は、人々が理解するのを助けるのに非常に役立ちます
コード。たとえば、メソッドを文書化する場合、
以下の条件を説明するのに非常に役立ちます
メソッドが呼び出される可能性が最も高いのはどれですか
（特に、メソッドが通常とは異なる場合にのみ呼び出される場合
状況）。

13.5インターフェースのドキュメント

コメントの最も重要な役割の1つは、
抽象化を定義します。第4章から、
抽象化は、エンティティの簡略化されたビューです。
重要な情報を保持しますが、詳細は省略します
それは安全に無視できます。コードはに適していません
抽象化を説明する。レベルが低すぎて
すべきではない実装の詳細が含まれています
抽象化で表示されます。説明する唯一の方法
抽象化にはコメントが付いています。お望みならば
優れた抽象化を提示するコード、あなたはしなければなりません
それらの抽象化をコメントで文書化します。
抽象化を文書化する最初のステップは、
実装からの個別のインターフェースコメント
コメント。インターフェイスコメントは提供します
誰かが知る必要のある情報
クラスまたはメソッドを使用するため。彼らは定義します
抽象化。実装コメントの説明：\ work \ Kindle \ phil \231.png@@クラスまたはメソッドが内部でどのように機能するか
抽象化を実装します。重要なのは
これらの2種類のコメントを分離して、ユーザーが
インターフェイスのは実装に公開されていません
詳細。さらに、これらの2つの形式の方が優れていました
異なる。インターフェイスのコメントも必要な場合
実装を説明し、次にクラスまたは
方法は浅い。これは、
コメントを書くことはについての手がかりを提供することができます
デザインの品質;第15章はこれに戻ります
アイディア。

クラスのインターフェイスコメントは、
提供される抽象化の高レベルの説明

次のようなクラスによって：
ype

*このクラスは単純なサーバー側インターフェースを実装します

HTTPに

プロトコル：このクラスを使用することにより、アプリケーションは

HTTPを受信する

要求し、それらを処理し、応答を返します。各

‘のインスタンス

このクラスは、

受け取る

リクエスト。現在の実装は単一です-
スレッドと

*一度に1つのリクエストを処理します。
* /

public class Http {... d：\ work \ Kindle \ phil \ 232.png @@このコメントは、全体的な機能について説明しています
クラスの、実装の詳細なし
または特定の方法の詳細ですら。それ
クラスの各インスタンスについても説明します
を表します。最後に、コメントは
クラスの制限（サポートしていません
複数のスレッドからの同時アクセス）、
検討している開発者にとって重要かもしれません
それを使用するかどうか。

メソッドのインターフェースコメントには次のものが含まれます
抽象化のための高レベルの情報と
精度のための低レベルの詳細：

+コメントは通常文で始まります
メソッドの動作を説明する1つまたは2つ
発信者によって認識されるように;これは高いです-
レベルの抽象化。

+コメントは各引数を説明する必要があります
および戻り値（存在する場合）。これらは
コメントは非常に正確である必要があり、
引数値の制約を説明する
引数間の依存関係も同様です。

-メソッドに副作用がある場合、これらは
インテで文書化される

rfaceコメント。 A
副作用はメソッドの結果です
システムの将来の動作に影響を与える
しかし、結果の一部ではありません。たとえば、ifd：\ work \ Kindle \ phil \233.png@@メソッドは内部データに値を追加します
将来的に取得できる構造
メソッド呼び出し、これは副作用です。に書く
ファイルシステムも副作用です。

-メソッドのインターフェースコメントは
発生する可能性のある例外について説明する
メソッドから。

-必要な前提条件がある場合
メソッドが呼び出される前に満たされる、これら
説明する必要があります（おそらく他のいくつか
メソッドを最初に呼び出す必要があります。バイナリの場合
検索方法、検索されるリストは
ソートされます）。最小化することをお勧めします
前提条件ですが、残っているものはすべて
文書化。

これは、メソッドのインターフェースコメントです。

Bufferオブジェクトからデータをコピーします。
あなたがたは

ある範囲のバイトをバッファから外部にコピーします

位置。

\paramオフセット
コピーする最初のバイトのバッファ内のインデックス。

\ param length

コピーするバイト数。

\ param dest

バイトをコピーする場所：でのスペースが必要です
トースト

* Tength bytes.d：\ work \ Kindle \ phil \ 234.png @@ \ return

戻り値は実際のバイト数です

コピー、

要求された場合、長さより短い場合があります

の範囲

バイトはバッファの終わりを超えて拡張されます。 0は

戻ってきた

要求された範囲の間に重複がない場合

と

実際のバッファ。
* /

uint32_t

バッファ::copy（uint32_t offset、uint32_t length、void *
dest）

このコメントの構文（例：\ return）は次のとおりです。
Doxygenの慣習、
C / C ++コードからコメントを抽出し、コンパイルします
それらをWebページに入れます。コメントの目的

開発者にすべての情報を提供することです
メソッドを呼び出すために必要です。
特殊なケースの処理方法（これに注意してください）
方法は第10章のアドバイスに従います
関連するエラーが存在しないことを定義します
範囲指定付き）。開発者
メソッドの本文を読む必要はありません
それを呼び出すために、そしてインターフェースコメント

内部データのスキャン方法など、メソッドがどのように実装されているかについての情報は提供されません：\ work \ Kindle \ phil \ 235.png @@
目的のデータを見つけるための構造。

より拡張された例として、考えてみましょう
IndexLookupと呼ばれるクラス。これは
分散ストレージシステム。ストレージシステム
テーブルのコレクションを保持し、各テーブルには
多くのオブジェクト。さらに、各テーブルには1つ持つことができます
以上のインデックス。各インデックスは効率的に提供します
特定に基づくテーブル内のオブジェクトへのアクセス
オブジェクトのフィールド。たとえば、1つのインデックスが
名前に基づいてオブジェクトを検索するために使用されます
フィールド、および別のインデックスが検索に使用される可能性があります
年齢フィールドに基づくオブジェクト。これらのインデックスを使用すると、
アプリケーションはすべてのオブジェクトをすばやく抽出できます
特定の名前、または年齢のある人全員
与えられた範囲。

IndexLookupクラスは便利なものを提供します
インデックス付きルックアップを実行するためのインターフェイス。ここ
で使用される方法の例です

応用：
query = new IndexLookup（table、index、keyl、key2）;
while（true）{
object = query.getNextQ）;
if（object == NULL）{

壊す;

。プロセスオブジェクト...d：\ work \ Kindle \ phil \ 236.png @@アプリケーションは、最初にタイプのオブジェクトを作成します
IndexLookup、を選択する引数を提供します
テーブル、インデックス、およびインデックス内の範囲（
たとえば、インデックスが年齢フィールドに基づいている場合、key1
key2は21および65として指定して選択できます
これらの値の間に年齢があるすべてのオブジェクト）。それで
アプリケーションはgetNextメソッドを繰り返し呼び出します。
各呼び出しは、該当する1つのオブジェクトを返します
望ましい範囲内;一度すべてのマッチング
オブジェクトが返されました。getNextはNULLを返します。
ストレージシステムが分散されているため、
このクラスの実装はやや複雑です。
テーブル内のオブジェクトは、複数に分散している場合があります
サーバー、および各インデックスも配布される場合があります
サーバーの異なるセット間。のコード
IndexLookupクラスは、最初にすべての人と通信する必要があります
情報を収集するための関連するインデックスサーバーの
範囲内のオブジェクトについては、
実際に保存しているサーバーと通信します
値を取得するためのオブジェクト。

それでは、どのような情報が必要かを考えてみましょう
このクラスのインターフェースコメントに含まれます。
以下に示す情報ごとに、質問してください
開発者がそれを知る必要があるかどうかを自分で
クラスを使用するための情報（私の答えは
質問は章の終わりにあります）：d：\ work \ Kindle \ phil \ 237.png @@1.IndexLookupが送信するメッセージの形式
クラスはインデックスを保持しているサーバーに送信します
とオブジェクト。

2.決定に使用される比較関数
特定のオブジェクトがに該当するかどうか
望ましい範囲（比較はを使用して行われます
整数、浮動小数点数、または
文字列？）。

3.インデックスを格納するために使用されるデータ構造
サーバー。

4.IndexLookupが複数を発行するかどうか
同時に異なるサーバーへのリクエスト。

5.サーバーのクラッシュを処理するためのメカニズム。

これが起源です

lバージョンのインターフェース
IndexLookupクラスへのコメント。抜粋
クラスの定義からの数行も含まれています。

コメントで参照されているもの：
yp

このクラスは、次のクライアント側フレームワークを実装します。

インデックス範囲

ジョークアップ。単一のLookupIndexKeysRPCと

多数

IndexedReadRPC。クライアント側には

の「IndexLookup.h」

IndexLookupクラスを使用するためのヘッダー。いくつかの

パラメータを設定できます

以下の構成で：d：\ work \ kindle \ phil \ 238.png@@*-同時インデックス付き読み取りRPCの数
*-indexedReadRPCが実行できるPKHashの最大数

一度に保持

-アクティブなPKHashesのサイズ

* IndexLookupを使用するために、クライアントは次のオブジェクトを作成します

このクラスによる

必要なすべての情報を提供します。後

の建設

IndexLookup、クライアントはgetNext（）関数を呼び出して

次へ移動

利用可能なオブジェクト。 getNext（）がNULLを返す場合、それは

我々が到達しました

最後のオブジェクト。クライアントはgetKey、getKeyLength、

getValue、

およびgetValueLengthを使用して、現在のオブジェクトデータを取得します
物体。
* /

クラスIndexLookup{

プライベート：
///同時indexedReadRPCの最大数
static const uint8_t NUM_READ_RPC = 10;
///1つで送信できるPKHashの最大数
/// indexedRead RPC
static const uint32_t MAX_PKHASHES_PERRPC = 256;
///activeHashesが実行できるPKHashの最大数
///一度に保持します。
static const size_t MAX_NUM_PK =（1 <<
LG_BUFFER_SIZE）; d：\ work \ Kindle \ phil \ 239.png @@さらに読む前に、識別できるかどうかを確認してください
このコメントの問題。これが
私が見つけた問題：

+最初の段落のほとんどは
インターフェイスではなく、実装。一つとして
たとえば、ユーザーは
特定のリモートプロシージャの名前
サーバーとの通信に使用される呼び出し。
で参照される構成パラメーター
最初の段落の後半はすべてです
にのみ関連するプライベート変数
そのユーザーではなく、クラスのメンテナ。すべての
この実装情報は次のようになります
コメントから省略。

+コメントにはいくつかのものも含まれています
それは明らかです。たとえば、
IndexLookup.hを含めるようにユーザーに指示する必要があります。
C++コードを書く人は誰でもできるようになります
これが必要だと思います。加えて
「必要なすべての情報を提供することによって」というテキスト
何も言わないので省略できます。

このクラスの短いコメントで十分です

（そして望ましい）：
y *
*このクラスは、クライアントアプリケーションが作成するために使用されます

クエリされた範囲：\ work \ Kindle \ phil \240.png@@インデックスを使用します。各インスタンスは単一の範囲を表します

クエリ。

範囲クエリを開始するには、クライアントがインスタンスを作成します

これの

クラス。その後、クライアントはgetNext（）を呼び出して取得できます

オブジェクト

希望の範囲で。によって返されるオブジェクトごとに

getNext（）、

呼び出し元はgetkey（）、getKeyLength（）、
getValue（）、および

getValueLengthは、そのオブジェクトに関する情報を取得します。
* /
このコメントの最後の段落は厳密にはありません
ほとんど情報が重複しているため、必要です
個々のメソッドのコメントで。でも、
クラスに例があると便利です
その方法を説明するドキュメント
特に深いクラスの場合は、一緒に作業します
自明ではない使用パターン。ご了承ください
新しいコメントはNULLリターンについて言及していません
getNextからの値。このコメントは意図されていません
各メソッドのすべての詳細を文書化する。それだけ
読者を支援するための高レベルの情報を提供します
メソッドがどのように連携するかを理解し、
各メソッドが呼び出される可能性があるとき。詳細については、
読者は、インターフェースのコメントを参照できます。
個々の方法。このコメントもしません
サーバーのクラッシュについて言及します。これは、serverd：\ work \ Kindle \ phil \ 241.png @@クラッシュが、このクラスのユーザーには表示されないためです（
システムはそれらから自動的に回復します）。

 危険信号：実装
ドキュメントが汚染する
インターフェース

この危険信号は、インターフェイス時に発生します
メソッドのドキュメントなどのドキュメント、
実装の詳細を説明します
存在するものを使用するために必要ではありません

文書化。

ここで、次のコードについて考えてみます。
のドキュメントの最初のバージョン

IndexLookupのiisReadyメソッド：

*次のオブジェクトがRESULT_READYであるかどうかを確認します。これ

機能は

‘DCFTモジュールに実装され、

isReady（）は試行します

smal]を進行させ、getNext（）を呼び出します

isReady（）

whileループ、isReady（）がtrueを返すまで。d：\ work \ Kindle \ phil \ 242.png @@ isReady（）はルールベースのアプローチで実装されます。我々

小切手

特定の順序に従うことによる異なるルール、および
実行

いくつかのルールが満たされた場合の特定のアクション。

\戻る
* Trueは、次のオブジェクトが使用可能であることを意味します。さもないと、

戻る

false。
* /
bool IndexLookup :: isReady（）{...}
繰り返しになりますが、このドキュメントのほとんどは、

DCFTおよび秒全体への参照として
段落、実装に関するので、

ここには属していません。これは最も
インターフェイスコメントの一般的なエラー。いくつかの
実装ドキュメントは便利ですが、
メソッド内に入る必要があります。
明確に分離

インターフェイスのドキュメントから。の
さらに、ドキュメントの最初の文は
不可解な（RESULT_READYはどういう意味ですか？）
重要な情報が欠落しています。最後に、そうではありません
getNextの実装を説明するために必要

ここ。コメントのより良いバージョンは次のとおりです。
yp

インデックス付きの読み取りが十分に行われたかどうかを示します

の進捗状況

getNextは、ブロックせずにすぐに戻ります。の

さらに、thisd：\ work \ Kindle \ phil \ 243.png @@メソッドは、インデックス付き読み取りの実際の作業のほとんどを実行します。

だからそれはしなければならない

呼び出される（直接、または呼び出すことによって間接的に）

getNext）で

インデックス付き読み取りが進行するための順序。

\戻る

Trueは、getNextの次の呼び出しが

ブロックしない

（少なくとも1つのオブジェクトを返すことができます。

の終わり

ルックアップに達しました）; falseは、getNextが可能性があることを意味します
ブロック。

* /
このバージョンのコメントは、より正確なものを提供します
「準備完了」の意味に関する情報、およびそれ
これが重要な情報を提供します
インデックスが作成されている場合は、最終的にメソッドを呼び出す必要があります

検索は進歩することです。

13.6実装コメント：何と
なぜ、どのようにではない

実装コメントは、
読者が理解するのを助けるためにメソッドの中に現れる
それらが内部でどのように機能するか。ほとんどの方法は

とても短くてシンプルなので、何も必要ありません
実装コメント：コードとthed：\ work \ Kindle \ phil \ 244.png @@インターフェースのコメントがあれば、どのように
メソッドは機能します。

実装コメントの主な目的は
読者がコードが何をしているのかを理解するのを助けるため
（それがどのように行われるかではありません）。読者が何を知ったら
コードがやろうとしているのですが、通常は理解しやすいです
コードがどのように機能するか。短いメソッドの場合、コード
すでに説明されている1つのことだけを行います
そのインターフェースコメントにあるので、実装はありません
コメントが必要です。より長い方法は
として異なることを行うコードのいくつかのブロック
メソッドの全体的なタスクの一部。コメントを追加
主要なブロックのそれぞれの前に、
そのブロックのレベル（より抽象的な）の説明
します。次に例を示します。

//フェーズ1：アクティブなRPCをスキャンして、

完了しました。

これらのようなコメントは、読者がナビゲートするのに役立ちます
それらに重要な部分を見つけるためのコード。にとって
ループ、ループの前にコメントがあると便利です
これは、各反復で何が起こるかを説明しています。

//次のループの各反復は、1つを抽出します
からのリクエスト
//リクエストメッセージは、対応するものをインクリメントします
オブジェクト、および

//応答メッセージに応答を追加します。d：\ work \ Kindle \ phil \245.png@@このコメントがループをどのように説明しているかに注意してください。
より抽象的で直感的なレベル。行きません
リクエストがどのように抽出されるかについての詳細に
リクエストメッセージまたはオブジェクトの状態から
インクリメント。ループコメントは次の場合にのみ必要です
より長いまたはより複雑なループ、そうでない場合があります
ループが何をしているのかを明確にします。多くのループは
彼らの行動が
すでに明らかです。

コードが何であるかを説明することに加えて
実行すると、実装コメントも役立ちます
理由を説明します。トリッキーな側面がある場合
それを読んでも明らかではないコード、あなた
それらを文書化する必要があります。たとえば、バグ修正の場合
目的が目的ではないコードを追加する必要があります
完全に明白です、理由を説明するコメントを追加してください
コードが必要です。よくあるバグ修正のために-
問題を説明する書面によるバグレポート、
コメントはバグ追跡の問題を参照できます
すべての詳細を繰り返すのではなく、データベース（「修正
Linuxでのデバイスドライバのクラッシュに関連するRAM-436
2.4.x」）。開発者はバグデータベースを調べることができます
詳細については（これは回避の例です
コメントの重複、これは議論されます

第16章）.d：\ work \ Kindle \ phil \ 246.png @@長いメソッドの場合は、次のように書くと便利です。
最も重要な地元のいくつかのコメント
変数。ただし、ほとんどのローカル変数は必要ありません
彼らが良い名前を持っている場合はドキュメント。すべての場合
変数の使用法は数行以内に表示されます
お互いのことを理解するのは通常簡単です
コメントなしの変数の目的。これで
読者にコードを読んで理解させても大丈夫な場合
変数の意味を理解します。ただし、
変数がコードの広い範囲で使用されている場合、
説明するコメントを追加することを検討する必要があります
変数。変数を文書化するときは、焦点を合わせます
それがどのようであるかではなく、変数が何を表すかについて

コードで操作されます。

13.7クロスモジュール設計の決定

完璧な世界では、すべての重要な設計上の決定
単一のクラス内にカプセル化されます。
残念ながら、実際のシステムは必然的に終わります
複数のクラスに影響を与える設計上の決定を伴います。
たとえば、ネットワークプロトコルの設計

送信者と受信者の両方に影響し、
これらはさまざまな場所で実装できます。
モジュール間の決定は複雑であることが多く、d：\ work \ Kindle \ phil \ 247.png @@微妙であり、多くのバグの原因となるため、非常に優れています。
それらのドキュメントは非常に重要です。

クロスモジュールの最大の課題
ドキュメントはそれを置く場所を見つけています
そうなる

当然、開発者によって発見されます。
時々置くべき明白な中心的な場所があります
そのような文書。たとえば、RAMCloud
ストレージシステムはステータス値を定義します。これは
成功または
失敗。新しいエラー状態のステータスを追加する
多くの異なるファイル（1つのファイル）を変更する必要があります
ステータス値を例外にマップし、別の値を提供します
各ステータスの人間が読めるメッセージ、および
すぐ）。幸いなことに、明らかな場所が1つあります
追加するときに開発者が行かなければならない場所
新しいステータス値。これは、
ステータス列挙型。これを利用して追加しました
他のすべてを識別するためのその列挙型のコメント
変更が必要な場所：

typedef列挙型ステータス{

STATUS_OK = 0、
STATUS_UNKNOWN_TABLET = 1、
STATUS_WRONG_VERSION = 2、
STATUS_INDEX_DOESNT_EXIST = 29、
STATUS_INVALID_PARAMETER = 30

STATUS_MAX_VALUE = 30、d：\ work \ Kindle \ phil \ 248.png @@ //注：新しいステータス値を追加する場合は、次のようにする必要があります

the

//追加の更新に続いて：

//（1）STATUS_MAX_VALUEを変更して値が等しくなるようにします
に

//‘最大の定義済みステータス値。

意味

//リストの最後です。 STATUS_MAX_VALUE
使用されている
//主にテスト用。

//（2）テーブル"messages"に新しいエントリを追加します
の「記号」

//Status.cc。

//（3）ClientException.hに新しい例外クラスを追加します

//（4）新しい「ケース」をに追加します

ClientException::throwExceptionをマップします

//ステータス値からステータス固有へ
ClientException
//サブクラス。

//（3）Javaバインディングで、次の静的クラスを追加します
例外

//ClientExceptionに。 java

//（6）例外のステータスのケースをに追加します
投げる

//ClientExceptionの例外。 java

//（7）のステータス列挙型に例外を追加します
状態。 java、作成

//ステータスが正しい位置にあることを確認します
対応する

//そのステータスコード.d：\ work \ Kindle \ phil \249.png@@新しいステータス値が最後に追加されます
既存のリストなので、コメントも
終わり、彼らが見られる可能性が最も高い場所。

残念ながら、多くの場合、
クロスモジュールを配置するための明らかな中心的な場所
ドキュメンテーション。 RAMCloudからの一例
ストレージシステムは、処理するためのコードでした
ゾンビサーバー、これはシステムが
クラッシュしたと信じていますが、実際にはまだ実行中です。
ゾンビサーバーを中和するには、次のコードが必要です
いくつかの異なるモジュール、およびこれらのコード
すべてが互いに依存しています。コードのどの部分も
ドキュメントを配置するための明らかな中心的な場所です。
1つの可能性は、の一部を複製することです。
に依存する各場所のドキュメント
それ。しかし、これは厄介であり、
システムとしてそのようなドキュメントを最新の状態に保つ
進化します。または、ドキュメントは次のようになります。
必要な場所の1つにありますが、
この場合、開発者が
ドキュメントまたはそれを探す場所を知っています。

私は最近実験しています
クロスモジュールの問題があるアプローチ
designNotesと呼ばれる中央ファイルに文書化されています。 The
ファイルは明確にラベル付けされたセクションに分割され、主要なトピックごとにoned：\ work \ Kindle \ phil \250.png@@になります。たとえば、ここに抜粋があります
ファイルから：

ゾンビ
ゾンビは、残りの人によって死んだと見なされるサーバーです
クラスターの;サーバーに保存されているデータはすべて
回復され、他のサーバーによって管理されます。でも、
ゾンビが実際に死んでいない場合（たとえば、
しばらくの間他のサーバーから切断されました）2
不整合の形式が発生する可能性があります。
*ゾンビサーバーは一度読み取り要求を処理してはなりません
交換用サーバーが引き継ぎました。そうでなければそれ
書き込みを反映していない古いデータを返す可能性があります

交換用サーバーによって受け入れられます。

ゾンビサーバーは書き込み要求を受け入れてはなりません
交換用サーバーがログの再生を開始すると
回復中;もしそうなら、これらの書き込みは失われる可能性があります
（新しい値は置換に保存されない場合があります

サーバーであるため、読み取りによって返されることはありません）。

RAMCloudは、ゾンビを無力化するために2つの手法を使用します。

初め、

次に、次のいずれかに関連するコードのいずれかで
これらの問題については、短いコメントがあります。
designNotesファイル：

//designNotesの「ゾンビ」を参照してください。

このアプローチでは、コピーは1つだけです。
ドキュメントのとそれは比較的簡単です
開発者は必要なときにそれを見つけることができます。でも、

d：\ work \ kindle \ phil \ 251.png @@これには、ドキュメントの欠点があります
に依存するコードのどの部分にも近くありません
そのため、最新の状態に保つのは難しいかもしれません。
システムは進化します。

13.8結論

コメントの目的は、
システムの構造と動作は明らかです
読者は、情報をすばやく見つけることができます
彼らはシステムを必要とし、修正を加えます
彼らが働くという自信を持って。これのいくつか
情報は、ある方法でコードで表すことができます
それはすでに読者には明らかですが、
簡単にはできない大量の情報
コードから推測されます。コメントはこれに記入します
情報。

コメントがすべきであるという規則に従うとき
コードから明らかではないことを説明し、
「自明」とは誰かの視点から
初めてコードを読む（あなたではない）。

コメントを書くときは、
読者の考え方と自分自身に何であるかを自問してください
彼または彼女が知る必要がある重要なこと。もしあなたの
コードはレビュー中です、そしてレビューアはあなたに言います
何かが明らかではないことを主張しないでください：\ work \ Kindle \ phil \ 252.png @@ them;読者がそれが明白ではないと思うなら、それはそうではありません
明らか。議論する代わりに、何を理解するようにしてください
彼らは混乱していることに気づき、あなたがそれを明確にできるかどうかを確認します、
より良いコメントまたはより良いコードのいずれかで。

13.9セクションからの質問への回答
13.5

開発者はそれぞれを知る必要がありますか
を使用するための以下の情報

IndexLookupクラス？

1.IndexLookupが送信するメッセージの形式
クラスはインデックスを保持しているサーバーに送信し、
オブジェクト。いいえ：これは実装の詳細です
それはクラス内に隠されている必要があります。

2.決定に使用される比較関数
特定のオブジェクトが目的に該当するかどうか
範囲（整数を使用して比較が行われ、
浮動小数点数、または文字列？）。はい：ユーザー
クラスのメンバーはこの情報を知る必要があります。

3.インデックスを格納するために使用されるデータ構造
サーバー。いいえ：この情報は
サーバーにカプセル化されています。でもない
IndexLookupの実装には必要があります
this.d:\work\kindle\phil\253.png @@4.IndexLookupが複数を発行するかどうか
同時に異なるサーバーへのリクエスト。
おそらく：IndexLookupが特別なものを使用する場合
パフォーマンスを改善するためのテクニック、そして
ドキュメントはいくつかを提供する必要があります
以来、これに関する高レベルの情報
ユーザーはパフォーマンスを気にするかもしれません。

5.サーバーのクラッシュを処理するためのメカニズム。
いいえ：RAMCloudはから自動的に回復します
サーバーがクラッシュするため、クラッシュはに表示されません
アプリケーションレベルのソフトウェア。したがって、
インターフェイスのクラッシュについて言及する必要があります
IndexLookupのドキュメント。クラッシュした場合
アプリケーションに反映され、その後
インターフェイスのドキュメントは
それらがどのように現れるかを説明します（しかし

クラッシュリカバリの仕組みの詳細ではありません）.d：\ work \ Kindle \ phil \254.png@@第14章

名前の選択

変数、メソッド、およびの名前の選択
他のエンティティは最も過小評価されているものの1つです
ソフトウェア設計の側面。良い名前は
ドキュメントの形式：コードを簡単にします
理解する。彼らは他の必要性を減らします
ドキュメントを作成し、検出を容易にします
エラー。逆に、貧弱な名前の選択は増加します
コードの複雑さとあいまいさの作成
バグにつながる可能性のある誤解。
名前の選択は、次の原則の例です。
複雑さは段階的です。平凡なものを選ぶ
とは対照的に、特定の変数の名前
可能な限り最高の名前、おそらく多くはないでしょう
システムの全体的な複雑さへの影響。
ただし、ソフトウェアシステムには何千ものソフトウェアがあります
変数;これらすべてに適切な名前を選択する
複雑さに大きな影響を与え、
manageability.d：\ work \ Kindle \ phil \ 255.png @@ 14.1例：名前が間違っているとバグが発生する

時々、名前の悪い変数が1つでも
深刻な結果をもたらします。最も挑戦的な
私が今まで修正したバグは貧しい人々のために起こりました
名前の選択。 1980年代後半から1990年代初頭に
私の大学院生と私は分散型を作成しました
Spriteと呼ばれるオペレーティングシステム。ある時点で私たちは
ファイルが時々データを失うことに気づきました：1つ
データブロックの一部が突然すべてゼロになりました
ただし、ファイルはユーザーによって変更されていません。
問題はあまり起こらなかったので、
追跡するのは非常に困難です。のいくつか
大学院生はバグを見つけようとしましたが、彼らは
進歩することができず、最終的に与えた
上。ただし、未解決のバグはすべて
耐え難い個人的な侮辱なので、追跡することにしました
下。

半年かかりましたが、やがて見つけて
バグを修正しました。問題は実際にはかなりでした
単純です（ほとんどのバグと同様に、一度理解すると）。
ファイルシステムコードは変数名ブロックを使用しました
2つの異なる目的のために。状況によっては、ブロックする
ディスク上の物理ブロック番号を参照。他で
状況では、ブロックは論理ブロック番号を参照します
ファイル内。残念ながら、コードのある時点で
論理を含むブロック変数がありました

blocked：\ work \ Kindle \ phil \ 256.png @@番号ですが、コンテキストで誤って使用されました
物理ブロック番号が必要な場合。として
その結果、ディスク上の無関係なブロックが上書きされました
ゼロで。

バグを追跡している間、何人かの人々、
私を含めて、欠陥のあるコードを読んで、
しかし、私たちはその問題に気づきませんでした。私たちが
物理ブロックとして使用される可変ブロックを見た
数、私たちはそれが本当に
物理ブロック番号を保持しました。時間がかかりました
計装のプロセス、最終的には
腐敗が起こっているに違いないことを示した
特定の声明で、私が得ることができる前に
名前によって作成されたメンタルブロックを過ぎて
その値がどこから来たのかを正確に確認してください。
に異なる変数名が使用されていた場合
fileBlockや
diskBlock、エラーが発生する可能性は低いです
起こりました;プログラマーは知っていただろう
そのfileBlockはその状況では使用できませんでした。
さらに良いのは、
2種類のブロック、
おそらく交換されます。

残念ながら、ほとんどの開発者は支出しません
名前について考えるのに多くの時間がかかります。彼らは使用する傾向があります
頭に浮かぶ最初の名前。
たとえば、ブロックは両方にかなり近い一致です
ディスク上の物理ブロックとその中の論理ブロック

ファイル;確かに恐ろしい名前ではありません。たとえそうであっても、

その結果、追跡に膨大な時間が費やされました
微妙なバグをダウンします。したがって、あなたは落ち着くべきではありません
「適度に近い」名前。少し取って
正確な素晴らしい名前を選ぶための余分な時間、
明確で直感的です。特別な注意
すぐにお金を払うでしょう、そして時間とともにあなたは学ぶでしょう
すぐに良い名前を選ぶために。

14.2画像を作成する

名前を選択するときの目標は、
自然についての読者の心のイメージ
名前が付けられているものの。良い名前は伝えます

根底にあるものについての多くの情報
実体は、そして、同じように重要なことですが、そうではありません。
特定の名前を検討するときは、次のことを自問してください。
「誰かがこの名前を単独で見た場合、
その宣言、その文書、または
名前を使用するコード、それらはどれくらい密接になりますか
名前が何を指しているのか推測できますか？ありますか
より鮮明な絵を描く他の名前？」の
もちろん、情報量には制限があります：\ work \ Kindle \ phil \258.png@@単一の名前に入れることができます。名前は
2つまたは3つ以上含まれていると扱いにくい
言葉。したがって、課題はほんの少しを見つけることです
の最も重要な側面を捉えた言葉
エンティティ。

名前は抽象化の一形態です：それらは
より複雑なことについての単純化された考え方
基礎となるエンティティ。他の形式の抽象化と同様に、
最高の名前は注目を集めるものです
基礎となるエンティティについて最も重要なこと
重要度の低い詳細は省略します。

14.3名前は正確である必要があります

良い名前には2つの特性があります：精度と
一貫性。精度から始めましょう。最も
名前に関する一般的な問題は、名前もそうだということです
一般的または漠然とした;結果として、読者にとっては難しい

名前が何を指しているかを伝えるため。読者はかもしれません
名前が別の何かを指していると仮定します
上記のブロックバグのように、現実から。考えます

次のメソッド宣言：
あなたがたは
*このオブジェクトのインデックスレットの総数を返します
管理します。
* /
int IndexletManager :: getCount（）{...} d：\ work \ Kindle \ phil \ 259.png @@「カウント」という用語は一般的すぎます：何をカウントしますか？
誰かがこのメソッドの呼び出しを見た場合、
彼らはそれが何をするのかを知らないでしょう
彼らはそのドキュメントを読みました。より正確
numActiveIndexletsのような名前の方が良いでしょう：
多くの読者はおそらく何を推測することができるでしょう
メソッドは、そのメソッドを見なくても戻ります

ドキュメンテーション。

 危険信号：あいまいな名前WS

変数またはメソッド名が十分に広い場合
多くの異なるものを参照するために、それはしません
開発者に多くの情報を伝える

基礎となるエンティティは
誤用。

これが他の名前の例です
さまざまな学生から取った、十分に正確ではありません
プロジェクト：

+使用されるGUIテキストエディタを構築するプロジェクト
位置を参照するための名前xおよびy
ファイル内の文字の。これらの名前は
あまりにも一般的です。それらは多くのことを意味する可能性があります;d：\ work \ kindle \ phil \ 260.png @@たとえば、それらはまた、
上の文字の座標（ピクセル単位）
スクリーン。で名前xを見ている人
分離はそれが参照しているとは思わない
行内の文字の位置に
テキストの。使用するとコードがより明確になります
charIndexや1ineIndexなどの名前。
コードが特定の抽象化を反映する
実装します。

-別のエディタープロジェクトには、
次のコード：

//点滅状態：カーソルが表示されている場合はtrue。

プライベートブールblinkStatus=true;

b1inkStatusという名前は十分に伝えられていません
情報。 「ステータス」という言葉は曖昧すぎます
ブール値の場合：手がかりはありません

試合
真または偽の値の意味。言葉
「点滅」もあいまいです。
何が点滅しているのか。次の選択肢は
より良い：

//カーソルの点滅を制御します：trueは
カーソルが表示されます、
// falseは、カーソルが表示されないことを意味します。

プライベートブールcursorVisible=true;

cursorVisibleという名前はより多くのことを伝えます
情報;たとえば、読者は次のことができます。
真の値が何を意味するかを推測します（一般的な：\ work \ Kindle \ phil \ 261.png @@ルールとして、ブール変数の名前は
常に述語である）。 「点滅」という言葉はありません
名前が長くなるので、読者は
必要に応じてドキュメントを参照してください
カーソルが常に表示されるとは限らない理由を理解してください。これ
情報はそれほど重要ではありません。

+コンセンサスプロトコルを実装するプロジェクト
次のコードが含まれています。

//サーバーが持っていないことを表す値
（まだ）投票しました

//現在の選挙期間の誰でも。
プライベート静的最終文字列

VOTED_FOR_SENTINEL_VALUE =“ nu11”;
この値の名前は、それが

特別ですが何が特別なのかはわかりません
意味はです。などのより具体的な名前
NOT_YET_VOTEDの方が良いでしょう。

-resultという名前の変数が使用されました
戻り値のないメソッド。この名前
複数の問題があります。まず、作成します
それがなるという誤解を招く印象
メソッドの戻り値。第二に、それ
に関する情報は基本的に提供されません
それがいくつかあることを除いて、それが実際に保持しているもの
計算値。名前は提供する必要があります
結果が実際に何であるかについての情報

は、mergedLineやtotalCharsなどです。 Ind：\ work \ Kindle \ phil \ 262.png @@実際に戻り値を持つメソッド、
その場合、名前の結果を使用するのが妥当です。
この名前はまだ少し一般的ですが、読者
メソッドのドキュメントを見ることができます
その意味を見てください、そしてそれを知ることは役に立ちます
値は最終的にリターンになります
価値。

+Linuxカーネルには2つの構造が含まれています
ネットワークソケットの説明：struct socket
と構造体靴下。 Astructソックスには
最初の要素としてソケットを構築します。これは
事実上、構造体ソケットのサブクラス。これらは
名前がとても似ているので難しい
どれがどれか覚えておいてください。それが良いだろう
区別しやすい名前を選択する
2つの関係を明確にします
structsock_baseやstructなどのタイプ
inet_sock。

すべてのルールと同様に、正確な選択に関するルール
名前にはいくつかの例外があります。たとえば、それは大丈夫です
ループの反復としてiやjなどの一般的な名前を使用する
ループが数行にしか及ばない限り、変数
コードの。使用法の全範囲を見ることができれば
変数の、そして変数の意味
おそらくコードから明らかなので、youd：\ work \ Kindle \ phil \263.png@@長い名前は必要ありません。たとえば、
次のコード：

for（i = 0; i <numlines; i ++）{

}
このコードから、私が慣れていることは明らかです

一部のエンティティの各行を繰り返し処理します。の場合
ループが長くなりすぎて、一度にすべてを見ることができない、または
反復変数の意味が難しい場合
コードから理解し、より説明的な
名前は正しいです。

名前が具体的すぎる可能性もありますが、
を削除するメソッドのこの宣言のように

テキストの範囲：

void delete（範囲選択）{...}

引数名の選択は具体的すぎます。
削除されるテキストがテキストであることを示唆しています
現在、ユーザーインターフェイスで選択されています。でも、
このメソッドは、任意の範囲のテキストで呼び出すことができます。
選択されているかどうか。したがって、引数名は次のようになります。
範囲など、より一般的なもの。

あなたがのための名前を思い付くのが難しいと思うなら
正確で直感的で、
それほど長くはありませんが、これは危険信号です。それは
変数には明確な定義や目的がない場合があります。
これが発生した場合は、代替のファクタリングを検討してください。
たとえば、singled：\ work \ Kindle \ phil \264.png@@変数を使用していくつかのことを表現しようとしている可能性があります。もしそうなら、分離
複数の変数への表現は
その結果、各変数の定義が簡単になります。 The
良い名前を選ぶプロセスはあなたを改善することができます
弱点を特定して設計します。

 危険信号：名前WSを選ぶのは難しい

変数の簡単な名前を見つけるのが難しい場合
またはの鮮明な画像を作成する方法
基になるオブジェクト、それは
基になるオブジェクトのデザインがきれいでない場合があります。

14.4一貫して名前を使用する

良い名前の2番目に重要な特性

一貫性です。どのプログラムでも特定の
何度も使用される変数。にとって
たとえば、ファイルシステムはブロック番号を操作します
繰り返し。これらの一般的な使用法のそれぞれについて、

その目的で使用する名前を選択し、
どこでも同じ名前。たとえば、ファイルシステム
のインデックスを保持するために常にfileBlockを使用する可能性があります

ファイル内のブロック。一貫した命名が削減されました：\ work \ Kindle \ phil \ 265.png @@認知的負荷は、再利用とほぼ同じ方法で
一般的なクラス：読者が名前を見たら
ある文脈では、彼らは知識を再利用でき、
彼らが見たときに即座に仮定を立てる
別の名前

コンテクスト。

一貫性には3つの要件があります。
与えられたものには常に共通の名前を使用してください
目的;第二に、一般名を使用しないでください
与えられた目的以外のもの;第三に、作る
目的が十分に狭いことを確認してください
名前の付いた変数は同じ動作をします。
この3番目の要件はファイルで違反されました
章の冒頭にあるシステムのバグ。ファイル
システムは、2つの異なる変数にブロックを使用しました
動作（ファイルブロックとディスクブロック）;これはにつながった
変数の意味についての誤った仮定、
その結果、バグが発生しました。

場合によっては、複数の変数が必要になります。
同じ一般的な種類のものを参照してください。例えば、
ファイルデータをコピーする方法には2つのブロックが必要です
番号、1つはソース用、もう1つは
行き先。これが発生した場合は、共通を使用してください
各変数の名前ですが、区別できる名前を追加します
srcFileBlockやdstFileBlockなどのプレフィックス。

ループは、一貫した命名が行われるもう1つの領域です
助けられる。 looped：\ work \ Kindle \ phil \ 266.png @@変数にiやjなどの名前を使用する場合は、常に最も外側のループでiを使用し、
ネストされたループ。これにより、読者は即座に作成できます
で何が起こっているかについての（安全な）仮定

彼らが与えられた名前を見たときのコード。

14.5余分な単語を避ける
名前のすべての単語は有用なものを提供する必要があります
情報;明確にするのに役立たない言葉
変数の意味は、混乱を加えるだけです（たとえば、
より多くの行を折り返す）。よくある間違いの1つ
フィールドやオブジェクトなどの一般名詞をに追加することです
fileObjectなどの名前。この場合、単語
オブジェクトはおそらく有用な情報を提供しません
（オブジェクトではないファイルもありますか？）
名前から省略してください。

一部のコーディングスタイルには、タイプ情報が含まれています
である変数のfilePtrなどの名前で
ファイルオブジェクトへのポインタ。の極端な例
これはハンガリアン記法で、
Cプログラミングのためにマイクロソフトで長年働いています。の
ハンガリアン記法、すべての変数名には
フルタイプを示すプレフィックス。たとえば、
名前arrusNumberListは、変数が
符号なし8ビット整数の配列。私は持っていますが
変数名に型情報が含まれていますind：\ work \ kindle \ phil \ 267.png @@過去、私はもうお勧めしません。モダンで
IDE変数名からその変数名にクリックするのは簡単です
宣言（または、IDEはタイプを表示することもあります
情報を自動的に）、したがって、する必要はありません
この情報を変数名に含めます。

無関係な言葉の別の例は、
クラスのインスタンス変数がクラスを繰り返します
インスタンス変数fileBlockinaなどの名前
Fileという名前のクラス。それはから明らかなはずです
変数がFileクラスの一部であるというコンテキスト、つまり
変数名にクラス名を組み込む
有用な情報を提供していません。名前を付けるだけです
可変ブロック（クラスに複数が含まれている場合を除く）
さまざまなタイプのブロック）。

14.6別の意見：Goスタイルガイド

ネーミングについての私の見解を誰もが共有しているわけではありません。いくつかの
Go言語の開発者の
名前は非常に短くする必要があり、多くの場合、単一の名前のみです
キャラクター。 Goの名前の選択に関するプレゼンテーションでは、
Andrew Gerrandは、次のように述べています。
コードは何をしますか。」！彼はこのコードサンプルを提示し、

1文字の変数名を使用します。
func RuneCount（b [] byte）int {
i、n：=0,0
for i <len（b）{d：\ work \ Kindle \ phil \ 268.png @@ if bli] <RuneSelf {
iH

} そうしないと {
_、サイズ：= DecodeRune（bLi：1）

it=サイズ
ニー

nを返す

}
そしてそれはより読みやすいと主張します

長い名前を使用する次のバージョン：
func RuneCount（buffer [] byte）int {
インデックス、カウント：= 0、0
インデックスの場合<len（buffer）{
if buffer [index] <RuneSelf {
インデックス++
} そうしないと {
、size：= DecodeRune（buffer [index：]）
インデックス+=サイズ

3

カウント++

3
返品数

}
個人的には、2番目のバージョンはもう見つかりません

最初より読みにくい。どちらかといえば、名前
countは、の動作にわずかに良い手がかりを与えます
nよりも変数。最初のバージョンで私は終わりました
理解しようとしているコードを読んで
nが何を意味するのか、私はその必要性を感じませんでした：\ work \ Kindle \ phil \ 269.png@@2番目のバージョン。しかし、ifnは一貫して使用されます
カウントを参照するためのシステム全体（および
他には何もありません）、短い名前はおそらく
他の開発者には明らかです。

囲碁文化は同じものの使用を奨励しています
複数の異なるものの短縮名：ch for
文字またはチャネル、データの場合はd、差異、または
距離など。私にとって、次のようなあいまいな名前
これらは混乱とエラーを引き起こす可能性がありますが、
ブロックの例のように。

全体として、読みやすさは
ライターではなく、リーダーによって決定されます。あなたが書くなら
短い変数名と人々を含むコード
それを読んだ人は理解しやすいと思いますそしてそれは
大丈夫。あなたがあなたのコードが
不可解である場合は、より長い使用を検討する必要があります
名前（「golanguageshortnames」のWeb検索
いくつかのそのような苦情を特定します）。同様に、
変数名が長いという苦情が出始めます
私のコードをharにする

読んで、それから私は検討します
短いものを使用します。

Gerrandは私が同意する1つのコメントをします
と：「名前の間の距離が大きいほど
宣言とその使用法、名前が長いほど
あるべきです。」ループの使用に関する以前の説明

iおよびjという名前の変数は、このルールの例です。d：\ work \ Kindle \ phil \ 270.png@@14.7結論

適切に選択された名前は、コードをより多く作成するのに役立ちます
明らか;誰かが変数に遭遇したとき
初めて、彼らの最初の推測
あまり考えずに作られた行動は、
正しい。良い名前を選ぶことは一例です
第3章で説明した投資の考え方：if
あなたは良いものを選ぶために前もって少し余分な時間を取ります
名前、コードでの作業が簡単になります
将来。さらに、あなたは可能性が低くなります

バグを紹介します。ネーミングのスキルを伸ばす

投資でもあります。あなたが最初にすることを決めたとき
平凡な名前に落ち着くのをやめなさい、あなたはそれを見つけるかもしれない
思いつくのにイライラして時間がかかる
良い名前。ただし、経験を積むにつれて
あなたはそれがより簡単になることがわかるでしょう。最終的に、あなたは
余分な時間がほとんどかからないポイントに到達します
良い名前を選ぶので、あなたは利益を得るでしょう
ほとんど無料です。

Ahttps：//talks.golang.org/2014/names.slide#1d：\ work \ Kindle \ phil \271.png@@第15章

最初にコメントを書く

（デザインの一部としてコメントを使用する
プロセス）

多くの開発者はドキュメントの作成を延期しました
開発プロセスが終了するまで、その後
コーディングと単体テストが完了しました。これは

低品質を生み出す最も確実な方法の1つ
ドキュメンテーション。コメントを書くのに最適な時期
あなたが書いているように、プロセスの始めにあります

コード。最初にコメントを書くと
設計プロセスのドキュメント部分。だけでなく
これにより、より優れたドキュメントが作成されますが、
より良いデザインを生み出し、それは
ドキュメントを書くのがもっと楽しくなります。

15.1遅延コメントは悪いコメントです

私が今まで会ったほとんどすべての開発者はoffd：\ work \ Kindle \ phil \272.png@@コメントを書いています。なぜそうしないのかと聞かれたとき
以前にドキュメントを書いてください、彼らはコードが
まだ変化しています。彼らが早期にドキュメントを書く場合、
彼らは、コードがコードのときにそれを書き直さなければならないと言います
変更;コードが安定するまで待つ方がよいでしょう。
しかし、別の理由もあるのではないかと思います。
それは彼らがドキュメンテーションを恨みとして見ているということです
仕事;したがって、彼らはそれを可能な限り延期しました。
残念ながら、このアプローチにはいくつかあります
否定的な結果。まず、遅らせる
ドキュメントはしばしばそれが決して得られないことを意味します
まったく書かれていません。遅延を開始すると、簡単です
もう少し遅らせるために;結局のところ、コードは均等になります
あと数週間でより安定します。その時までに
コードは間違いなく安定しています、それはたくさんあります、
これは、ドキュメントを作成するタスクを意味します
巨大になり、魅力がさらに低下しました。あります
数日間停止するのに便利な時間は決してありません
不足しているコメントをすべて入力すると、簡単に入力できます
プロジェクトにとって最良のことは
先に進んでバグを修正するか、次の新機能を作成してください。
これにより、文書化されていないコードがさらに作成されます。
たとえあなたが戻るための自己規律を持っていても
コメントを書いてください（そして自分をだましてはいけません：
あなたはおそらくそうではありません）、コメントはあまりありません
良い。プロセスのこの時点で、あなたは精神的にチェックアウトしました：\ work \ Kindle \ phil \273.png@@。あなたの心の中で、このコードは
終わり;あなたは次のプロジェクトに進んでいきたいと思っています。
あなたはコメントを書くことが正しいことであることを知っています
することですが、それは楽しいことではありません。あなたはそれを乗り越えたいだけです
できるだけ早く。したがって、クイックパスを作成します
コード上に、十分なコメントを追加します
立派に見えます。今では、あなたからしばらく経ちます
コードを設計したので、設計の思い出
プロセスがあいまいになっています。あなたはコードを次のように見ます
あなたはコメントを書いているので、コメント
コードを繰り返します。あなたが再構築しようとしても
コードからは明らかではないデザインのアイデア、
覚えていないことがあるでしょう。したがって、
コメントには、最も重要なもののいくつかが欠けています
彼らが説明すべきこと。

15.2最初にコメントを書く

コメントを書くための別のアプローチを使用して、
最初にコメントを書くところ：

-新しいクラスの場合、私はクラスを書くことから始めます
インターフェイスコメント。

-次に、インターフェースのコメントを書き、
最も重要な公衆のための署名
メソッドですが、メソッド本体はそのままにしておきます
empty.d：\ work \ Kindle \ phil \ 274.png @@-これらのコメントについて、
基本的な構造はほぼ正しいと感じています。

+この時点で、私は宣言を書き、
最も重要なクラスへのコメント
クラス内のインスタンス変数。

+最後に、メソッドの本文を入力します。
として実装コメントを追加
必要です。

+メソッド本体を書いている間、私は通常
追加の方法の必要性を発見する
およびインスタンス変数。新しいメソッドごとに
の前にインターフェースコメントを書きます
メソッドの本体。たとえば変数
コメントと同時にコメントを記入します
変数宣言を記述します。

コードが完成したら、

コメントは
また、行われました。未書き込みのバックログはありません
コメント。

コメントファーストのアプローチには3つの利点があります。
まず、より良いコメントが生成されます。あなたが書く場合
クラスを設計する際のコメント、キー
デザインの問題は頭の中で新鮮になるので、簡単です
それらを記録します。インターフェイスを作成することをお勧めします
各メソッドの本文の前にコメントするので、
メソッドの抽象化とインターフェースに焦点を当てることができます

その実装に気を取られることなく。d：\ work \ Kindle \ phil \ 275.png @@コーディングとテストのプロセス中に、
コメントの問題に気づき、修正します。として
結果として、コメントはの過程で改善されます

発達。

15.3コメントはデザインツールです

書くことの2番目のそして最も重要な利点
最初のコメントはそれが改善するということです
システム設計。コメントは唯一の方法を提供します
抽象化と優れた抽象化を完全にキャプチャする
優れたシステム設計の基本です。もし、あんたが
で抽象化を説明するコメントを書く

最初に、それらを確認して調整できます
実装コードを書く前に。書くには
良いコメント、あなたは本質を特定する必要があります

変数またはコードの一部：最も多いもの
このことの重要な側面？することが重要です
これは設計プロセスの早い段階です。そうでなければあなたは
コードをハッキングするだけです。

コメントは、の炭鉱のカナリアとして機能します
複雑。メソッドまたは変数に長い時間が必要な場合
コメント、それはあなたが良いものを持っていないという危険信号です
抽象化。第4章から、クラスが
深くする必要があります：最高のクラスは非常にシンプルです
インターフェイスはまだ強力な機能を実装しています。 Thed：\ work \ Kindle \ phil \276.png@@インターフェースの複雑さを判断する最良の方法

それを説明するコメントからです。の場合
メソッドのインターフェイスコメントは、すべての
メソッドを使用するために必要な情報であり、
短くてシンプル、それはその方法が
シンプルなインターフェースを備えています。逆に、方法がない場合
長いことなく完全に方法を説明する
複雑なコメント、そしてメソッドは

複雑なインターフェース。メソッドを比較できます
取得する実装とのインターフェイスコメント
メソッドの深さの感覚：インターフェースの場合
コメントは、のすべての主要な機能を説明する必要があります
実装すると、メソッドは浅くなります。
同じ考え方が変数にも当てはまります。
変数を完全に説明する長いコメント、それは

あなたが選択していない可能性があることを示唆する赤い旗

正しい変数分解。全体的に、行為
コメントを書くことであなたはあなたを評価することができます
意思決定を早期に設計して、発見して修正できるようにします
問題。

 危険信号：PSを説明するのは難しい

メソッドを説明するコメントまたは

変数は単純でありながら完全である必要があります。 Ifd：\ work \ Kindle \ phil \ 277.png @@このようなコメントを書くのは難しいと思いますが、
これは問題がある可能性があることを示しています
あなたが説明しているもののデザインで。

もちろん、コメントは良い指標にすぎません
それらが完全で明確である場合、複雑さのもし、あんたが
しないメソッドインターフェースコメントを書く
を呼び出すために必要なすべての情報を提供する
方法、または非常に不可解な方法で、
理解してください、そしてそのコメントは
メソッドの深さの適切な尺度。

15.4初期のコメントは楽しいコメントです

コメントを書くことの3番目で最後の利点
早い段階でコメントを書くことが多くなります
楽しい。私にとって、の最も楽しい部分の1つ
プログラミングは、新たな設計段階です。
クラスでは、抽象化と
クラスの構造。私のコメントのほとんどは
このフェーズで書かれ、コメントは
デザインの品質を記録してテストする方法
決定。できるデザインを探しています
最小限で完全かつ明確に表現された
言葉。コメントが単純であるほど、Id：\ work \ Kindle \ phil \ 278.png @@は私のデザインについてより良く感じられるので、単純なコメントを見つける
誇りの源です。プログラミングしている場合
戦略的に、あなたの主な目標は素晴らしいデザインです
動作するコードを書くだけでなく、
コメントを書くのは楽しいはずです。
最高のデザインを特定します。

15.5初期のコメントは高額ですか？
それでは、遅延の議論をもう一度見てみましょう。
コメント、それはそれがのコストを回避するということです
コードが進化するにつれてコメントを作り直します。 A
単純な封筒裏の計算では、
これはあまり節約できません。まず、合計を見積もります
タイピングに費やす開発時間の一部
コードとコメントで一緒に
コードとコメントを改訂します。これはありそうもない
すべての開発の約10％以上になります
時間。たとえあなたの総コード行の半分が
コメント、コメントを書くことはおそらくしません
全体の約5％以上を占める
開発時間。コメントをまで遅らせる
最後はこれのほんの一部しか節約できませんが、そうではありません
とても。

最初にコメントを書くことは、
抽象化は、開始する前により安定します：\ work \ Kindle \ phil \279.png@@コードの記述。これはおそらく中の時間を節約します
コーディング。対照的に

、最初にコードを書く場合、

抽象化は、コーディングするにつれておそらく進化します。
これは、より多くのコードリビジョンを必要とします
コメント-最初のアプローチ。あなたがすべてを考えるとき
これらの要因のうち、より高速である可能性があります
全体的に最初にコメントを書きます。

15.6結論

最初にコメントを書いてみたことがない場合は、
試してみる。慣れるのに十分な長さでそれを固執する

それに。次に、それが品質にどのように影響するかを考えます

あなたのコメント、あなたのデザインの質、そして
ソフトウェア開発の全体的な楽しみ。
あなたがこれをしばらく試した後、私に知らせてください
あなたの経験が私のものと一致するかどうか、そしてその理由
またはなぜnot.d：\ work \ Kindle \ phil \280.png@@第16章

既存のコードの変更

第1章では、ソフトウェア開発の方法について説明しました

反復型および増分型です。大きなソフトウェア
システムは一連の進化を通じて発展します
各ステージが新しい機能を追加するステージ

既存のモジュールを変更します。この意味は

システムの設計は常に進化しています。そうではありません
システムの適切な設計を考案することが可能
最初に;成熟したシステムの設計は
の間に行われた変更によってさらに決定されます
最初の構想よりもシステムの進化。
前の章では、絞る方法について説明しました

初期設計時の複雑さを排除し、
実装;この章では、維持する方法について説明します
システムが進化するにつれて忍び寄ることによる複雑さ。

16.1戦略を維持する
第3章では、.d：\ work \ Kindle \ phil \281.png@@戦術プログラミングと戦略プログラミングの違いを紹介しました。
戦術プログラミングでは、主な目標は取得することです
たとえそれが結果として生じたとしても、何かが素早く機能する
追加の複雑さ;戦略的プログラミングでは、
最も重要な目標は、素晴らしいものを生み出すことです
システム設計。非常に迅速な戦術的アプローチ
厄介なシステム設計につながります。あなたがしたい場合
保守と拡張が容易なシステム、そして
「働く」というのは十分に高い基準ではありません。必ず
デザインを優先し、戦略的に考えます。この考え
既存のコードを変更する場合にも適用されます。
残念ながら、開発者が既存のものに入るとき
バグ修正や新規などの変更を行うためのコード
機能、彼らは通常戦略的に考えていません。 A
典型的な考え方は「可能な限り最小のものは何ですか
必要なことを実行できる変更を加えることができますか？」
開発者がこれを正当化するのは、
変更されるコードに慣れていない。
彼らは、より大きな変化がより大きな変化をもたらすことを心配しています
新しいバグを導入するリスク。しかし、これは
戦術的なプログラミングになります。これらのそれぞれ
最小限の変更で、いくつかの特殊なケースが発生します。
依存関係、または他の形式の複雑さ。として
その結果、システム設計が少し悪化し、
問題は、の各ステップで蓄積されます
システムのevolution.d:\work\kindle\phil\282.png@@クリーンなデザインを維持したい場合
システムでは、次の場合に戦略的アプローチをとる必要があります
既存のコードを変更します。理想的には、
変更のたびに、システムは
あなたが持っていたらそれが持っていたであろう構造を持っている
その変更で最初からそれを設計しました
マインド。この目標を達成するには、抵抗する必要があります
迅速な修正をしたいという誘惑。代わりに、
現在のシステム設計がまだ最高かどうか
1つは、目的の変更に照らしてです。そうでない場合は、リファクタリングします
あなたが可能な限り最高のもので終わるようにシステム
設計。このアプローチでは、システム設計
変更するたびに改善されます。

これも投資の一例です
15ページで紹介された考え方：投資する場合
システムをリファクタリングして改善するための余分な時間はほとんどありません
デザイン、あなたはよりクリーンなシステムになってしまうでしょう。これ
開発をスピードアップし、あなたは回復します
リファクタリングに投資した努力。もしそれでも
特定の変更にはリファクタリングは必要ありません。
あなたはまだデザインに目を光らせているべきです
中にいる間に修正できる欠陥
コード。コードを変更するときはいつでも、見つけてみてください
システム設計を少なくとも少し改善する方法
プロセスのビット。デザインを作成していない場合

良くなると、おそらく悪化しているでしょう。d：\ work \ Kindle \ phil \ 283.png @@第3章で説明したように、投資
考え方は時々の現実と衝突します
商用ソフトウェア開発。リファクタリングの場合
システムの「正しい方法」には3つかかります
数ヶ月ですが、迅速で汚い修正は
2時間、あなたは速くて汚いものを取る必要があるかもしれません
アプローチ、特にあなたが
厳しい締め切り。または、システムをリファクタリングする場合
他の多くに影響を与える非互換性を作成します
人とチームの場合、リファクタリングは
実用的。

それにもかかわらず、あなたはこれらに抵抗する必要があります
可能な限り妥協します。自問してみてください
「これは、クリーンを作成するために私ができる最善の方法ですか
現在の制約を考慮して、システム設計？」
おそらく、別のアプローチがあります
3か月のリファクタリングとほぼ同じくらいきれいですが
数日でできるでしょうか？または、できない場合
今すぐ大規模なリファクタリングを行う余裕があり、上司を取得します
あなたがtの後にそれに戻るための時間を割り当てるために

彼
現在の締め切り。すべての開発組織
その合計のごく一部を使うことを計画する必要があります
クリーンアップとリファクタリングの取り組み。この仕事は支払う
長期的にはそれ自体のために。d：\ work \ Kindle \ phil \ 284.png @@ 16.2コメントの維持：
コードの近くのコメント

既存のコードを変更すると、良いものがあります

変更によって一部が無効になる可能性

既存のコメント。更新するのを忘れがちです

コードを変更するとコメントが表示されます。

もはや正確ではないコメントで。古い

コメントは読者を苛立たせます、そしてもしあれば

それらの非常に多く、読者は不信を始めます

すべてのコメント。幸いなことに、少しで

規律といくつかの指導ルール、それは可能です

多大な労力をかけずにコメントを最新の状態に保つため。

このセクションと次のセクションはいくつかを出しました

特定のテクニック。

コメントを確実に取得するための最良の方法
更新されたのは、それらをコードの近くに配置することです
説明するので、開発者はそれらを見るときにそれらを見るでしょう
コードを変更します。コメントが遠い
関連するコードであるほど、その可能性は低くなります
正しく更新されました。たとえば、
メソッドのインターフェースコメントは、コードファイルにあります。
メソッドの本体の横。への変更
メソッドにはこのコードが含まれるため、開発者は
インターフェイスのコメントと更新が表示される可能性があります
必要に応じてそれらを.d：\ work \ Kindle \ phil \285.png@@個別のコードとヘッダーを持つ言語
CやC++などのファイルの代わりに
メソッドの横にインターフェースコメントを配置します
.hファイルでの宣言。しかし、これは長いです
コードからの道;開発者はそれらを見ることはありません
メソッドの本体を変更するときのコメント、および
別のファイルを開くには追加の作業が必要です
それらを更新するためのインターフェースコメントを見つけてください。いくつかの
インターフェイスのコメントを入力する必要があると主張する可能性があります
ユーザーが使用方法を学ぶことができるようにヘッダーファイル
コードファイルを見なくても抽象化できます。
ただし、ユーザーはどちらのコードも読む必要はありません
またはヘッダーファイル。彼らは彼らの情報を取得する必要があります
などのツールによってコンパイルされたドキュメントから
DoxygenまたはJavadoc。さらに、多くのIDEは
ドキュメントを抽出してユーザーに提示する
メソッドのドキュメントを表示する場合など
メソッドの名前が入力されます。次のような特定のツール
これらの場合、ドキュメントは次の場所にあります。
開発者にとって最も便利な場所
コードに取り組んでいます。

実装コメントを書くとき、
メソッド全体のすべてのコメントをに入れないでください
メソッドのトップ。それらを広げて、押します
それぞれのコメントは、その最も狭い範囲にまで下がります
コメントで参照されるすべてのコードが含まれます。d：\ work \ Kindle \ phil \ 286.png @@たとえば、メソッドに3つの主要なフェーズがある場合、
メソッドの上部にコメントを1つ書かないでください
すべてのフェーズを詳細に説明しています。その代わり、
フェーズごとに個別のコメントを書き、
そのコメントをの最初の行のすぐ上に配置します
そのフェーズのコード。一方で、それはまた可能性があります
メソッドの上部にコメントを付けると便利です
全体的な戦略を説明する実装、
このような：

//次の3つのフェーズに進みます。

//フェーズ1：実行可能な候補を見つける

//フェーズ2：各候補者にスコアを割り当てます

//フェーズ3：最適なものを選択し、削除します

追加の詳細は、すぐ上に文書化できます
各フェーズのコード。

一般的に、コメントが遠いほど
それが説明するコードは、より抽象的なものでなければなりません
（これにより、コメントが
コードの変更によって無効になります）。

16.3コメントはコードに属し、
コミットログ

コードを変更する際のよくある間違いは
変更に関する詳細情報を
ソースコードリポジトリのコミットメッセージ、
しかし、それをコードに文書化しないでください。ただし、\ work \ Kindle \ phil \287.png@@コミットメッセージは将来閲覧できます
リポジトリのログをスキャンすることにより、開発者は
情報が考えにくい必要があります
リポジトリログをスキャンします。彼らがスキャンしたとしても
ログ、正しいログメッセージを見つけるのは面倒です。
コミットメッセージを書くときは、
開発者がそれを使用する必要があるかどうかを自分で
将来の情報。もしそうなら、文書化
コード内のこの情報。例は
微妙な問題を説明するメッセージをコミットする
コード変更の動機。これが文書化されていない場合
コードでは、開発者がやってくるかもしれません
後で気付かずに変更を元に戻す
彼らはバグを再現しました。含めたい場合
コミットメッセージ内のこの情報のコピー
同様に、それは問題ありませんが、最も重要なこと
コードでそれを取得することです。これは原理を示しています
の場所にドキュメントを配置する
開発者はそれを見る可能性が最も高いです。コミットログ
その場所はめったにありません。

16.4コメントの維持：避ける
複製

コメントを維持するための2番目のテクニック
これまでのところ、重複を避けることです。ドキュメント：\ work \ Kindle \ phil \ 288.png @@が重複している場合、開発者はそれを行うのがより困難になります
関連するすべてのコピーを見つけて更新します。その代わり、
文書化してみてください

各設計決定を1回だけ入力します。
コード内に複数の場所がある場合
特定の決定の影響を受けますが、繰り返さないでください
これらの各ポイントでのドキュメント。その代わり、
置くための最も明白な単一の場所を見つける
ドキュメンテーション。たとえば、
影響を与える変数に関連するトリッキーな動作
変数が使用されるいくつかの異なる場所。
コメントでその動作を文書化できます
変数の宣言の横。これは自然なことです
開発者がチェックする可能性が高い場所
を使用するコードを理解するのに問題がある
変数。

置くべき「明白な」単一の場所がない場合
特定のドキュメント
開発者はそれを見つけ、designNotesファイルを次のように作成します
セクション13.7で説明されています。または、最高のものを選んでください
利用可能な場所とそこにドキュメントを置きます。
さらに、他の場所に短いコメントを追加します
中央の場所を参照しています：「コメントを参照してください
以下のコードの説明については、xyzで。」の場合
マスターが
コメントが移動または削除されました、この矛盾
開発者は次のことを見つけられないため、自明です：\ work \ Kindle \ phil \289.png@@指定された場所のコメント。彼らは使用することができます
何が起こったのかを知るための改訂管理履歴
コメントに移動してから、参照を更新します。の
対照的に、ドキュメントが複製されている場合
一部のコピーは更新されません。
開発者が古いものを使用していることを示すものはありません
情報。

1つのモジュールの設計上の決定を再文書化しないでください
別のモジュールで。たとえば、入れないでください
メソッド呼び出しの前に、何を説明するコメント
呼び出されたメソッドで発生します。読者がしたい場合
知っている、彼らはインターフェースのコメントを見る必要があります
メソッドのために。優れた開発ツールは
通常、この情報は自動的に提供されます。
たとえば、次のインターフェイスコメントを表示します
メソッドの名前を選択するか、ホバーすると、メソッド
その上にマウスを置きます。開発者が簡単にできるようにしてください
適切なドキュメントを見つけるために、しかしそれをしないでください
ドキュメントを繰り返すことによって。

情報がすでに文書化されている場合
プログラム外のどこか、繰り返さないでください
プログラム内のドキュメント。ただ
外部ドキュメントを参照してください。にとって
たとえば、を実装するクラスを作成する場合
HTTPプロトコル、説明する必要はありません
コード内のHTTPプロトコル。あります：\ work \ Kindle \ phil \290.png@@このドキュメントのソースはすでに多数あります
ウェブ上で;短いコメントを追加するだけです

これらのソースの1つのURLを含むコード。別
例は、すでに文書化されている機能です
ユーザーマニュアル。プログラムを書いているとしましょう
コマンドのコレクションを実装します。
それぞれの実装を担当する1つの方法
指図。説明するユーザーマニュアルがある場合
これらのコマンド、これを複製する必要はありません
コード内の情報。代わりに、短い
のインターフェースコメントに次のように注意してください
各コマンドメソッド：

//Fooコマンドを実装します;のユーザーマニュアルを参照してください

詳細。
読者がすべてを簡単に見つけることができることが重要です
コードを理解するために必要なドキュメント、
でもそれはあなたがそのすべてを書かなければならないという意味ではありません
ドキュメンテーション。

16.5コメントの維持：
差分

ドキュメントが最新の状態に保たれていることを確認する1つの良い方法

現在までは、コミットする前に数分かかることです

スキャンするリビジョン管理システムへの変更
そのコミットのすべての変更について。確認してください：\ work \ Kindle \ phil \291.png@@各変更が適切に反映されていること
ドキュメンテーション。これらの事前コミットスキャンも
誤ってなど、他のいくつかの問題を検出する
デバッグコードをシステムに残すか、失敗する
TODOアイテムを修正します。

16.6上位レベルのコメントは簡単です
維持
ドキュメントの維持に関する最後の考え：
コメントが高いほど、維持しやすくなります-
レベルとコードよりも抽象的な。これらは
コメントはコードの詳細を反映していないため、
マイナーなコード変更の影響を受けません。
全体的な動作の変更のみがこれらに影響します
コメント。もちろん、第13章で説明したように
一部のコメントは、詳細かつ正確である必要があります。
しかし、一般的に、最も有用なコメント
（単にコードを繰り返すのではありません）も最も簡単です
維持する.d：\ work \ Kindle \ phil \292.png@@第17章

一貫性

一貫性は、
システムの複雑さとその振る舞い
より明白。システムに一貫性がある場合、それは
同様のことが同様の方法で行われること、
異なることは異なる方法で行われます。
一貫性は認知的レバレッジを生み出します：1回
あなたは何かが1つでどのように行われるかを学びました
場所、あなたはすぐにその知識を使用することができます
同じを使用する他の場所を理解する
アプローチ。システムがに実装されていない場合
一貫したファッション、開発者はについて学ぶ必要があります
それぞれの状況を別々に。これにはもっと時間がかかります。
一貫性は間違いを減らします。システムがそうでない場合
一貫して、2つの状況が同じように見える場合があります
実際にはそれらが異なる場合。

開発者は
見慣れたパターンを見て、正しくない
との以前の出会いに基づく仮定
そのパターン。一方、システムがisd：\ work \ Kindle \ phil \ 293.png @@一貫している場合、慣れ親しんだものに基づいて仮定が行われます-
見ている状況は安全です。一貫性により
開発者はより少ない労力でより迅速に作業できます
間違い。

17.1一貫性の例

一貫性は、多くのレベルで適用できます。
システム;ここにいくつかの例があります。

名前。第14章ではすでに
一貫した方法で名前を使用することの利点。
コーディングスタイル。今日では一般的です
スタイルガイドを持つ開発組織
ルールを超えてプログラム構造を制限する
コンパイラによって強制されます。モダンスタイルガイドのアドレス
インデント、カーリーなどのさまざまな問題-

ブレースの配置、宣言の順序、命名、
コメント、および言語機能の制限
危険だと考えられています。スタイルガイドラインはコードを作成します
読みやすく、ある種のエラーを減らすことができます。
インターフェース。複数のインターフェース
実装はの別の例です
一貫性。理解したら
インターフェイスの実装、その他
実装が理解しやすくなります：\ work \ Kindle \ phil \ 294.png @@実装の機能をすでに知っているので、
提供する。

デザインパターン。デザインパターンは一般的に-
特定の一般的な問題に対する受け入れられた解決策、
ユーザーへのmodel-view-controllerアプローチなど
インターフェイスデザイン。既存のデザインを使用できる場合
問題を解決するためのパターン、実装
より迅速に進行し、機能する可能性が高くなります、
そしてあなたのコードは読者にとってより明白になるでしょう。
デザインパターンについては、
セクション19.5。

不変量。不変量は変数のプロパティです
または常に真である構造。たとえば、データ
テキストの行を格納する構造は、
各行が改行で終了することは不変
キャラクター。不変量は特別な数を減らします
コードで考慮し、それを作成する必要があるケース
コードの動作について推論するのは簡単です。

17.2一貫性の確保

特に一貫性を維持するのは難しい
多くの人がプロジェクトに取り組んでいるとき
長い時間。あるグループの人々は知らないかもしれません
別ので確立された規則について
グループ。新規参入者はルールを知らないので、theyd：\ work \ Kindle \ phil \295.png@@は意図せずに規約に違反して作成します
既存の規則と競合する新しい規則。
確立して維持するためのいくつかのヒントがあります
一貫性：

書類。最も多くリストされているドキュメントを作成する
コーディングなどの重要な全体的な規則

スタイルガイドライン。ドキュメントを特定の場所に配置します
開発者がそれを見る可能性が高い場所、たとえば
プロジェクトWikiの目立つ場所。奨励
ドキュメントを読むためにグループに参加する新しい人々、
そして、既存の人々にそれを毎回レビューするように勧めます
たまに。さまざまなからのいくつかのスタイルガイド
組織はWeb上で公開されています。
これらのいずれかから始めることを検討してください。

よりローカライズされたコンベンションの場合
不変条件、コード内の適切な場所を見つけて
それらを文書化します。規約を書かない場合
ダウン、他の人がフォローする可能性は低いです
彼ら。

施行する。優れたドキュメントがあっても、それは難しい
開発者がすべての規則を覚えておくため。
規則を適用する最良の方法は、次のように書くことです。

違反をチェックし、確認するツール
そのコードをリポジトリにコミットすることはできません
チェッカーを通過しない限り。自動チェッカーd：\ work \ Kindle \ phil \296.png@@は低レベルの構文に特に適しています
コンベンション。

最近のプロジェクトの1つで問題が発生しました
行終了文字。一部の開発者
行がで終了するUnixで動作しました
改行;他の人はWindowsで作業しました
通常、キャリッジリターンで終了します
改行が続きます。 1つのシステムの開発者の場合
以前に編集したファイルに小さな編集を加えました
他のシステムでは、エディタが置き換えられることがあります
適切なものを備えたすべてのラインターミネータ
そのシステムのために。これは、
ファイルのすべての行が変更されました。
意味のある変更を追跡するのが難しくなりました。

ファイルはすべきであるという規則を確立しました
改行のみが含まれていますが、確認するのは困難でした
すべての開発者が使用するすべてのツールが従ったこと
コンベンション。新しい開発者が毎回
プロジェクトに参加したとき、私たちは発疹を経験するでしょう
その開発者の間の回線終了の問題
コンベンションに合わせて調整。

私たちは最終的にこの問題を書くことで解決しました
自動的に実行された短いスクリプト
変更がソースコードにコミットされる前
リポジトリ。スクリプトは、次のすべてのファイルをチェックします。
変更されており、それらの@@にキャリッジリターンが含まれている場合は、コミットを中止します。スクリプトはできます
また、手動で実行して、破損したファイルを修復します。
キャリッジリターン/改行シーケンスを次のように置き換えます
改行。これにより、問題は即座に解消されました。
また、新しい開発者のトレーニングにも役立ちました。

コードレビューは別の機会を提供します
enforのために

コンベンションの開催と新しい教育のため
コンベンションについての開発者。より多くのnit-
コードレビュアーがうるさいほど、より迅速に
チームの全員がコンベンションを学びます、
コードがよりクリーンになります。
ローマにいるとき...最も重要な大会
何よりも、すべての開発者は古いものに従う必要があります
格言「ローマにいるときは、ローマ人と同じようにしてください。」いつ
新しいファイルで作業しているときは、周りを見回して、
既存のコードは構造化されています。すべてパブリック変数ですか
プライベートメソッドの前に宣言されたメソッド？ですか
アルファベット順のメソッド？変数は使用しますか
firstServerNameのような「キャメルケース」または「スネークケース」
first_server_nameのように？あなたが何かを見たとき
それはおそらく慣習かもしれないように見えます、
それに従います。設計を決定するときは、
同様の決定があった可能性が高い場合は自分で
プロジェクトの他の場所で作成されました。もしそうなら、既存のものを見つける
例とあなたの新しいで同じアプローチを使用してください
code.d：\ work \ Kindle \ phil \298.png@@既存の規則を変更しないでください。抵抗

既存の慣習を「改善」したいという衝動。
「より良いアイデア」を持つことは十分な言い訳ではありません
矛盾を導入します。あなたの新しいアイデアは
確かに良いですが、一貫性の価値

過度の不整合は、ほとんどの場合、
あるアプローチの別のアプローチに対する価値。前
一貫性のない行動を導入し、自問してください
2つの質問。まず、重要な新しいものがありますか
ではなかったあなたのアプローチを正当化する情報
古い大会が設立されたときに利用できますか？
第二に、新しいアプローチは非常に優れているので

古いものをすべて更新するのに時間をかける価値があります
使用しますか？組織がその答えに同意する場合
両方の質問に「はい」です、それから先に進んでください
アップグレード。あなたが終わったとき、あるべきではありません
古い慣習のサイン。ただし、まだ実行します
他の開発者が知らないリスク
新しいコンベンション、彼らは再導入するかもしれません
将来の古いアプローチ。全体的に、再考
確立された規則が使用されることはめったにありません
開発者の時間。

17.3行き過ぎ

一貫性とは、類似したことを意味するだけでなく、\ work \ Kindle \ phil \ 299.png @@も同様の方法で実行する必要があるだけでなく、異なることも意味します。
物事はさまざまな方法で行われるべきです。もし、あんたが
一貫性に熱心になり、
異なるものを同じアプローチに強制し、
物事に同じ変数名を使用するなど
本当に違う、または既存のデザインを使用している
パターンに合わないタスクのパターン、あなたは
複雑さと混乱を生み出します。一貫性のみ
開発者が自信を持っているときにメリットを提供します
「それがxのように見える場合、それは実際にはxです。」

17.4結論

一貫性は投資のもう1つの例です
考え方。確実にするために少し余分な作業が必要になります
一貫性：慣習を決定するための作業、作業
自動チェッカーを作成するには、探してください
新しいコードで模倣し、機能する同様の状況
チームを教育するためのコードレビューで。リターン
この投資であなたのコードはより多くなるということです
明らか。開発者は理解できるようになります
コードの動作をより迅速かつ正確に、そして
これにより、より少ない作業でより速く作業できるようになります
bugs.d：\ work \ Kindle \ phil \300.png@@第18章

コードは明白でなければなりません

あいまいさは、次の2つの主な原因の1つです。
セクション2.3で説明されている複雑さ。あいまいさ
システムに関する重要な情報が発生したときに発生します
新しい開発者には明らかではありません。の解決策
あいまいさの問題は、次のような方法でコードを書くことです。
それを明らかにします。この章では、
コードを多かれ少なかれ明白にする要因。

コードが明白な場合、それは誰かができることを意味します
あまり考えずにコードをすばやく読み、
行動や意味についての彼らの最初の推測
コードのが正しいでしょう。コードが明らかな場合、
読者は多くの時間や労力を費やす必要はありません
作業に必要なすべての情報を収集する
コード。コードが明確でない場合、読者は
それを理解するために多くの時間とエネルギーを費やします。
これは効率を低下させるだけでなく、
誤解の可能性を高め、