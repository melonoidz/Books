＃ソフトウェア設計の哲学
-ソフトウェア開発

＃本の

コンピュータソフトウェアを書くことは最も純粋なものの1つです
人類の歴史における創造的な活動。
プログラマーは実際的な制限に縛られません
物理法則など。エキサイティングなものを作ることができます


1.はじめに
ソフトウェア開発プロセスに関する議論はかなりあるが，ソフトウェア設計の中心的な問題は
まだほとんど手つかずです．デイビッドパーナスの古典的な論文「分解システムで使用される基準についてモジュールに」は1971年に登場しましたが、ソフトウェア設計の芸術はあまり進歩していません．

 -1.1 この本の使い方
  ここで説明する設計原則の多くやや抽象的なので、難しいかもしれません
    実際のコードを見ずに感謝します。それは持っています
    小さな例を見つけるのは困難でした
    本に含めるのに十分でありながら、十分な大きさ
    実際のシステムの問題を説明するため（
    良い例に出会ったら、私に送ってください）。
    したがって、この本だけでは十分ではないかもしれません
    原則を適用する方法を学びます。

2.複雑さの性質
この本はソフトウェアを設計する方法についてです
複雑さを最小限に抑えるシステム。最初
ステップは敵を理解することです。まさに何
「複雑さ」とは？システムが
不必要に複雑ですか？システムの原因
複雑になりますか？

複雑さを認識する能力は
重要な設計スキル。それはあなたが識別することを可能にします
あなたがそれらに多くの努力を投資する前に問題、
そしてそれはあなたが中から良い選択をすることを可能にします

複雑な場合は、別のアプローチを試して、それがどうかを確認してください
簡単です。時間が経つにつれて、あなたは特定のことに気付くでしょう
テクニックはよりシンプルなデザインになる傾向がありますが、
他のものは複雑さと相関しています。

これにより、よりシンプルなデザインをより迅速に作成できます。

この章では、いくつかの基本的な説明も行います
残りの基礎を提供する仮定。

 -2.1 複雑の定義


 -2.2 複雑さの症状
 cognitive load

 -2.3 複雑さの原因
 -2.4 複雑さは段階的
 -2.5 結論

3.作業コードだけでは不十分です
 -3.1戦術プログラミング
 -3.2戦略的プログラミング
 --3.3いくら投資しますか？
 -3.4スタートアップと投資
 -3.5結論

4.モジュールは深くする必要があります
 -4.1モジュラー設計
 --4.2インターフェースには何がありますか？
 -4.3抽象化
 -4.4ディープモジュール
 -4.5浅いモジュール
 -4.6分類炎
 -4.7例：JavaおよびUnix I / O
 -4.8結論

5.情報​​の隠蔽（および漏洩）
 -5.1情報隠蔽
 -5.2情報漏えい
 -5.3時間的分解
 -5.4例：HTTPサーバー
 -5.5例：クラスが多すぎます
 -5.6例：HTTPパラメータの処理
 -5.7例：HTTP応答のデフォルト
 -5.8クラス内に隠されている情報
 -5.9行き過ぎ
 -5.10結論

6.汎用モジュールはより深い
 -6.1クラスをやや汎用的にする
 -6.2例：エディター用のテキストの保存
 -6.3より汎用的なAPI
 -6.4一般性はより良い情報隠蔽につながります
 -6.5自分自身に尋ねる質問
 -6.6スペシャライゼーションを上向き（および下向き）にプッシュ
 -6.7例：エディターの元に戻すメカニズム
 -6.8コード内の特殊なケースを排除する
 -6.9結論

7.異なる層、異なる抽象化
 -7.1パススルー方法
 --7.2インターフェースの複製はOKですか？
 -7.3デコレータ
 -7.4インターフェースと実装

8.複雑さを下に引っ張る
 -8.1例：エディタテキストクラス
 -8.2例：構成パラメーター
 -8.3やりすぎ
 -8.4結論

9.一緒に、または離れて、より良いですか？
 -9.1情報が共有されている場合はまとめる
 -9.2インターフェースを簡素化する場合はまとめる
 -9.3重複を排除するためにまとめる
 -9.4汎用と特殊目的の分離
 -9.5例：挿入カーソルと選択
 -9.6例：ロギング用の個別のクラス
 -9.7分割と結合の方法
 -9.8別の意見：クリーンコード
 -9.9結論

10.存在しないエラーを定義する
 -10.1例外が複雑さを増す理由
 -10.2例外が多すぎます
 -10.3存在しないエラーを定義する
 -10.4例：Windowsでのファイルの選択
 -10.5例：Javaサブストリングメソッド
 -10.6マスクの例外
 -10.7例外の集約
 -10.8ただクラッシュしますか？
 -10.9やりすぎ
 -10.10結論

11.それを2回設計する
あなたは結局複数を考慮すると、はるかに良い結果が得られます

12.なぜコメントを書くのですか？ 4つの言い訳

 -12.1良いコードは自己文書化です
一部の人々は、コードがうまく書かれていれば、コメントは必要ないほど明白
GUIテキストエディタのファイルのテキストを管理します。 The
最初のステップは、クラスが使用するインターフェースを定義することです
 1つの選択肢は、回線指向のインターフェイスです。
全体を挿入、変更、削除する操作
テキストの行。別のオプションは、インターフェースベースです
個々の文字の挿入と削除について。


 -12.2コメントを書く時間がない
コメントを優先するのは魅力的ですよりもその他の開発タスク。からの選択を与えられた
新しい機能を追加し、既存の機能を文書化する
機能、新しい機能を選択するのは理にかなっているようです。
ただし、ソフトウェアプロジェクトはほとんどの場合
時間のプレッシャー、そして常に
コメントを書くよりも優先度が高いようです。したがって、
ドキュメントの優先順位を下げることを許可した場合、
ドキュメントがなくなるでしょう。

この言い訳に対する反論は、
15ページで説明されている投資の考え方。

優れたドキュメントは、このコストをすぐに相殺します。
さらに、最も重要なものの多く
コメントは抽象化に関連するものです

 -12.3コメントは古くなり、誤解を招くようになります

コメントは古くなることがありますが、

これは実際には大きな問題である必要はありません。

 -12.4私が見たすべてのコメントは価値がありません
 -12.5よく書かれたコメントの利点
 -12.6別の意見：コメントは失敗です

13.コメントは、コードから明らかではないことを説明する必要があります
 -13.1選択規則
 -13.2コードを繰り返さないでください
 -13.3下位レベルのコメントは精度を追加します
 -13.4高レベルのコメントは直感を強化します
 -13.5インターフェースのドキュメント
 -13.6実装コメント：方法ではなく、何を、なぜ
 -13.7クロスモジュール設計の決定
 -13.8結論
 -13.9セクション13.5からの質問への回答

14.名前の選択
 -14.1例：悪い名前はバグを引き起こします
 -14.2画像を作成する
 -14.3名前は正確である必要があります
 -14.4一貫して名前を使用する
 -14.5余分な単語を避ける
 -14.6別の意見：Goスタイルガイド
 -14.7結論

15.最初にコメントを書く
 -15.1Deleyedコメントは悪いコメントです
 -15.2最初にコメントを書く
 -15.3コメントは設計ツールです
 -15.4初期のコメントは楽しいコメントです
 -15.5初期のコメントは高価ですか？
 -15.6結論

16.既存のコードの変更
 -16.1戦略を維持する
 -16.2コメントの維持：コメントをコードの近くに置いてください
 -16.3コメントは、コミットログではなく、コードに属します
 -16.4コメントの維持：重複を避ける
 -16.5コメントの維持：相違点を確認してください
 -16.6上位レベルのコメントは保守が容易です

17.一貫性
 -17.1一貫性のあるEcamples
 -17.2一貫性の確保
 -17.3行き過ぎ
 -17.4結論

18.コードは明白でなければなりません
 -18.1コードをより明確にするもの
 -18.2コードをわかりにくくするもの

 -18.3結論
自明性について考える別の方法は，情報の観点である
コードを明確にするには、次のことを確認する必要があります
読者は常に必要な情報を持っています
それを理解します。これは3つの方法で行うことができます。 The
最善の方法は、情報量を減らすことです
それは、次のような設計手法を使用して必要です
抽象化と特殊なケースの排除。 2番、
あなたは読者が持っている情報を利用することができます
他のコンテキストですでに取得しています（
たとえば、規則に従い、準拠することによって
期待に応えて）読者が新しいことを学ぶ必要がないように
コードの情報。第三に、あなたは提示することができます
コード内の彼らにとって重要な情報

19.ソフトウェアのトレンド
議論された原則を説明する方法についてのいくつかの傾向について考察する
　ソフトウェアで人気のあるパターンや，過去数十年にわたる開発。それぞれについてトレンド、そのトレンドがどのように関連しているかを説明します

この本の原則と原則を使用するその傾向がレバレッジを提供するかどうかを評価するソフトウェアの複雑さに対して。

 -19.1オブジェクト指向プログラミングと継承
 オブジェクト指向プログラミングは最もソフトウェア開発における重要な新しいアイデア．それは次のような概念を導入しました：クラス、継承、プライベートメソッド、およびインスタンス

 -19.2アジャイル開発
アジャイル開発は1990年代後半に出現したソフトウェア開発のアプローチです
アジャイル開発は主にプロセスに関するものです

ソフトウェア開発の（チームの編成，スケジュールの管理、単体テストの役割、顧客との対話など）ではなく　ソフトウェア設計。それにもかかわらず、それはいくつかに関連しています
この本の設計原則。
アジャイルの最も重要な要素の1つ　開発は開発という概念です
増分的かつ反復的である必要があります。アジャイルでアプローチ、ソフトウェアシステムはシリーズで開発されます

アジャイル開発のリスクの1つはそれが戦術的なプログラミングにつながる可能性があること。アジャイル開発は開発者を機能に集中させる傾向がありますが、抽象化ではなく、開発者を奨励します

 -19.3ユニットテスト
以前は、開発者がテストを作成することはめったにありませんでした。もしも
テストはまったく書かれていませんでした
別のQAチーム。しかし、の信条の1つ
アジャイル開発とは、テストを厳しくする必要があるということです
開発、およびプログラマーと統合
独自のコードのテストを作成する必要があります。この練習
今では広く普及しています。テストは通常
ユニットテストとシステムの2種類に分けられます

UT：それらは小さく、集中しています：各テスト通常、単一のコードの小さなセクションを検証します　　方法。ユニットテストは、なしで単独で実行できます。

2番目の種類のテストは、システムテストで構成されます
（統合テストと呼ばれることもあります）、

 -19.4テスト駆動開発

テスト駆動開発はソフトウェアへのアプローチです
プログラマーが単体テストを書く開発
彼らがコードを書く前に。新しいクラスを作成するときは、
開発者は最初にクラスの単体テストを作成します。

私はユニットテストを強く支持していますが、
Iamはテスト駆動開発のファンではありません。 Theテスト駆動開発の問題はそれです
特定の機能を取得することに焦点を当てています
最高のデザインを見つけるのではなく、機能します(！！！)。

 -19.5デザインパターン
デザインパターンは、
設計：新しいメカニズムを設計するのではなく
ゼロから、よく知られているデザインを適用するだけです
パターン。ほとんどの場合、これは良いことです：デザイン
それらが共通を解決するためにパターンが生じた
問題、そして彼らは一般的に同意されているので
クリーンなソリューションを提供します。デザインパターンが機能する場合
特定の状況では、おそらく
別のアプローチを思い付くのは難しい
それのほうがいい。

デザインパターンの最大のリスクは過剰です
応用。すべての問題を解決できるわけではありません

(過剰にあてはめすぎる)

 -19.6ゲッターとセッター
Javaプログラミングコミュニティでは、getterとセッターメソッドは人気のあるデザインパターンです。
ゲッターとセッターは厳密には必要ありませんが、インスタンス変数を公開できるためです
デザインパターンを確立するリスクの1つ
開発者はパターンが良好であると想定し、
できるだけ使ってみてください。これはにつながっています
Javaでのゲッターとセッターの乱用。


 -19.7結論
新たな提案に出会ったときはいつでもソフトウェア開発パラダイム、
複雑さの観点：提案は
全体の複雑さを最小限に抑えるのに本当に役立ちます
ソフトウェアシステム？多くの提案は上手く聞こえます
表面ですが、もっと深く見ると
それらのいくつかは複雑さを悪化させるのではなく、
better.

20.パフォーマンスのための設計
この時点まで、ソフトウェアの議論デザインは複雑さに焦点を合わせています.目標はソフトウェアをできるだけシンプルで理解しやすいものにする可能。しかし、システムで作業している場合はどうなりますか
それは速くする必要がありますか？パフォーマンスはどのようにすべきか考慮事項は設計プロセスに影響しますか？
この章では、高性能を実現する方法について説明します
すっきりとしたデザインを犠牲にすることなく。最も重要なアイデアはまだシンプルです：だけでなく
シンプルさはシステムの設計を改善しますが、通常はシステムを高速化します。

 --20.1パフォーマンスについての考え方
 取り組むべき最初の質問は「いくら中のパフォーマンスについて心配する必要があります通常の開発プロセス？」

(パフォーマンスと実装の塩梅)

 --20.2変更前（および変更後）の測定
 しかし、システムがまだ遅すぎると仮定します。


 --20.3クリティカルパス周辺の設計

この時点で、慎重に
パフォーマンスを分析し、全体に影響を与えるのに十分遅いコードの断片を特定しました

 --20.4例：RAMCloudバッファー
 --20.5結論
これからの最も重要な全体的な教訓はそのすっきりとしたデザインと高性能です
互換性があります。 
複雑なコードは遅い傾向があります
無関係または冗長な作業。一方で、
クリーンでシンプルなコードを書くと、システムは
おそらく十分に速いので、
そもそもパフォーマンスについては心配する必要があります。

21.重要事項を決定する

善の最も重要な要素の1つ
ソフトウェア設計は、重要なものを分離しています

 --21.1重要なことを決定する方法は？
 --21.2重要なことを最小限に抑える
 できるだけ問題を少なくするようにしてください：これは
よりシンプルなシステムになります。たとえば、
必要なパラメータの数を最小限に抑える
オブジェクトを構築するため、またはデフォルトを提供するために指定
最も一般的な使用法を反映する値。物事のために
それは重要です、の数を最小限に抑えるようにしてください

 --21.3重要なことを強調する方法
重要なことを特定したら、
デザインでそれらを強調する必要があります。 1
強調する方法は目立つことです：重要

 --21.4間違い
重要なことを決定する際には、2種類あります
あなたが犯すことができる間違い。最初の間違いは
あまりにも多くのものを重要なものとして扱います。このとき
重要でないことがデザインを乱雑にし、
複雑さを増し、認知的負荷を増大させます。
2番目の種類の間違いは認識に失敗することです
その何かが重要です。この間違いは
重要な情報が隠されている状況、
または重要な機能が利用できないので
開発者は継続的にそれを再作成する必要があります。この種の間違いは、開発者の生産性を妨げ、未知の未知数につながります。

 -21.5より広く考える
最も重要なことに焦点を当てるという考え
ソフトウェア設計以外の他のドメインにも適用されます。
テクニカルライティングでも重要です


22.結論

この本は一つのことについてです：複雑さ。

優れたデザイナーになることの見返りは、あなたが
あなたの時間の大部分を
楽しいデザインフェーズ。貧しいデザイナーは費やします
彼らの時間のほとんどは、複雑でバグを追いかけています
もろいコード。あなたがあなたのデザインスキルを向上させるなら、
より高品質のソフトウェアをより多く生産するだけです
迅速に、しかしソフトウェア開発プロセスはもっと楽しくなる
