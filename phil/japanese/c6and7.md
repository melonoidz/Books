d：\ work \ Kindle \ phil \301.png@@バグ。明らかなコードは、より少ないコメントを必要とします
自明でないコード。

「明らか」は読者の心の中にあります：それはより簡単です
他人のコードが自明ではないことに気付く
自分のコードに問題があるのを見るよりも。したがって、
コードの自明性を判断するための最良の方法
コードレビューによるものです。誰かがあなたを読んでいるなら
コードはそれが明白ではないと言っていますそしてそれは明白ではありません
それがあなたにどれほど明確に見えるかもしれないかは関係ありません。しようとすることによって
何がコードを非自明にしたのか理解してください、あなた
将来、より良いコードを書く方法を学びます。

18.1コードをより明確にするもの

作るための最も重要なテクニックの2つ
明らかなコードはすでにで議論されています
前の章。最初は良い名前を選ぶことです
（第14章）。正確で意味のある名前は明確です
コードの振る舞いをし、必要性を減らします
ドキュメンテーション。名前があいまいまたはあいまいな場合は、
その後、読者はコードを読む必要があります

名前の意味を推測するために
実在物;これには時間がかかり、エラーが発生しやすくなります。
2番目の手法は一貫性です（第17章）。
同様のことが常に同様の方法で行われる場合、
そうすれば、読者は自分が見たパターンを認識できます：\ work \ Kindle \ phil \ 302.png @@前に、そしてすぐに（安全な）結論を導き出します
コードを詳細に分析せずに。

他のいくつかの汎用テクニックがあります
コードをより明確にするため：
ホワイトスペースの賢明な使用。方法コードは
フォーマットは、理解のしやすさに影響を与える可能性があります。
次のパラメータドキュメントを検討してください。

空白が絞り出されている：
あなたがたは

*@paramnumThreadsこれが行うスレッドの数

マネージャーは

進行中の接続を管理するためにスピンアップします。 The

MessageManager

開くたびに少なくとも1つのスレッドをスピンアップします

接続、だからこれ

少なくとも接続数と同じである必要があります

あなたが期待する

すぐに開く。これはその倍数である必要があります

番号の場合

あなたは少量でたくさんのメッセージを送ることを期待しています

時間の。

@paramhandlerを処理するためのコールバックとして使用されます

着信

このMessageManagerの開いている接続上のメッセージ。

見る

{@codeMessageHandler}および{@codehandleMessage}for
詳細。

* /
1つのドキュメントがどこにあるかを確認するのは難しいです

パラメータが終了し、次が始まります。均等ではありません：\ work \ kindle \ phil \ 303.png @@パラメータがいくつあるか、または何があるかは明らかです
彼らの名前は。少し空白を追加すると、
構造が突然明らかになり、

ドキュメントのスキャンが簡単です。

* @param numThreads
*このマネージャーが必要なスレッドの数

スピンアップ

進行中の接続を管理するため。 The

MessageManagerが回転します

開くたびに少なくとも1つのスレッドをアップ

接続、だからこれ

少なくともの数と等しくなければなりません

あなたとのつながり

すぐに開くことを期待してください。これは

その倍数

大量のメッセージを送信する予定の場合は番号

要するに

時間の長さ。

@paramハンドラー

着信を処理するためのコールバックとして使用されます

上のメッセージ

このMessageManagerの開いている接続。見る

{@codeMessageHandler}および{@code
詳細については、handleMessage}を参照してください。
* /
空白行は、メジャーを区切るのにも役立ちます
メソッド内のコードのブロック（

次の例：
void *バッファ::allocAux（size_t numBytes）

{d：\ work \ Kindle \ phil \ 304.png@@//長さを8バイトの倍数に切り上げて
位置合わせを確認してください。

uint32_t numBytes32 =（downCast <uint32_t>（numBytes）+
7）＆〜0x7;

assert（numBytes32！= 0）;

//最初に十分なメモリがある場合は、次を使用します
それ。仕事をする
//上から、このメモリは
整列する
//（下部のメモリは次の目的で使用された可能性があります
可変サイズのチャンク）。
if（availableLength> = numBytes32）{

availableLength-= numBytes32;

firstAvailable+availableLengthを返します。

//次に、最後に余分なスペースがあるかどうかを確認します
ジャストチャンク。
if（extraAppendBytes> = numBytes32）{
extraAppendBytes-= numBytes32;
lastChunk-> data + lastChunk->length+を返します

extraAppendBytes;
3

//新しいスペース割り当てを作成する必要があります;スペースを割り当てる
その中で。

uint32_tlocatedLength;

firstAvailable = getNewAllocation（numBytes32、
＆allocatedLength）;

availableLength =locatedLength-numBytes32;

return firstAvailable + availableLength; d：\ work \ Kindle \ phil \ 305.png @@このアプローチは、最初の場合に特に効果的です。
各空白行の後の行は、説明するコメントです
コードの次のブロック：空白行は
コメントがより見やすくなります。

ステートメント内の空白は、
ステートメントの構造を明確にします。比較
次の2つのステートメント、そのうちの1つは
空白とその1つはそうではありません：

for（int pass = 1; pass> = 0 &&！empty; pass--）{

for（int pass = 1; pass> = 0 &&！empty; pass--）{
コメント。回避できない場合もあります
自明でないコード。これが起こるとき、それは
コメントを使用して補うことが重要
不足している情報を提供します。これをうまく行うには、
あなたは読者の立場に身を置く必要があります
そして、彼らを混乱させる可能性のあるものを理解し、そして
どのような情報がその混乱を解消しますか。 The
次のセクション翔

いくつかの例があります。

18.2コードをわかりにくくするもの

コードを作ることができるものはたくさんあります
非自明;このセクションでは、いくつかの例を示します。
イベント駆動型プログラミングなど、これらのいくつかは、
状況によっては便利なので、最終的には
とにかくそれらを使用します。これが発生した場合、extrad：\ work \ Kindle \ phil \306.png@@ドキュメントは読者を最小限に抑えるのに役立ちます
錯乱。
イベント駆動型プログラミング。イベント駆動型の場合
プログラミング、アプリケーションは外部に応答します
ネットワークパケットの到着などの発生
またはマウスボタンを押します。 1つのモジュールは
着信イベントの報告を担当します。他の
アプリケーションの一部は、特定の関心を登録します
特定のイベントを呼び出すようにイベントモジュールに要求することによるイベント
これらのイベントが発生したときの関数またはメソッド。

イベント駆動型プログラミングはそれを難し​​くします
制御の流れに従うこと。イベントハンドラー
関数が直接呼び出されることはありません。彼らです
通常、イベントモジュールによって間接的に呼び出されます
関数ポインタまたはインターフェイスを使用します。たとえあなたが
イベントモジュールで呼び出しポイントを見つけ、
それでも、どの特定の機能かを判断することはできません
呼び出されます：これはどのハンドラーに依存します
実行時に登録されました。このため、
イベント駆動型コードについて推論したり、説得したりするのは難しい
それが機能することを自分で。

このあいまいさを補うために、
各ハンドラー関数のインターフェースコメント

この例のように、いつ呼び出されるかを示します。

*このメソッドは、ディスパッチスレッドで

トランスポートifad：\ work \ Kindle \ phil \ 307.png @@ *トランスポートレベルのエラーにより、RPCを完了できません。
* /
空所

トランスポート::RpcNotifier:: failed（）{

 危険信号：非自明なコードPS

コードの意味と動作ができない場合
簡単に読んで理解すると、それは赤です
国旗。多くの場合、これは重要なことがあることを意味します
すぐにはわからない情報

コードを読んでいる人。

汎用コンテナ。多くの言語が提供します
2つ以上のアイテムをグループ化するための汎用クラス
JavaのPairやstd::pairinCなどの単一のオブジェクト
++、これらのクラスは
1つで複数のオブジェクトを簡単に渡すことができます
変数。最も一般的な使用法の1つは、
このJavaのように、メソッドからの複数の値

例：

新しいPair<Integer、Boolean>（currentTerm、false）;を返します。

残念ながら、汎用コンテナは
グループ化されたelementsd：\ work \ Kindle \ phil \ 308.png @@には、その意味を曖昧にする一般的な名前があるため、わかりにくいコードです。
上記の例では、発信者は参照する必要があります
結果を伴う2つの戻り値。 getkeyQと
result.getValue（）は、
値の実際の意味。

したがって、汎用コンテナは使用しない方がよいでしょう。もしも
コンテナが必要で、新しいクラスまたは構造を定義します
それは特定の用途に特化しています。あなたはできる
次に、要素に意味のある名前を使用し、
で追加のドキュメントを提供できます
ジェネリックでは不可能な宣言
容器。

この例は、一般的なルールを示しています：ソフトウェア
読みやすくするために設計する必要があります
執筆の。一般的なコンテナは便利です
コードを書いている人のために、しかし彼らは作成します
続くすべての読者のための混乱。いいです
コードを書いている人が少し余分に費やすために
特定のコンテナ構造を定義するための分、
結果のコードがより明白であること。

宣言と割り当てのさまざまなタイプ。
次のJavaの例を考えてみましょう。

プライベートリスト<メッセージ>incomingMessageList;

着信メッセージリスト=新しいArrayList<メッセージ>（）;

変数はリストとして宣言されていますが、実際の

値はArrayListです。 Listed：\ work \ kindle \ phil \ 309.png @@はArrayListのスーパークラスであるため、このコードは合法ですが、誤解を招く可能性があります
宣言は見るが、
実際の割り当て。実際のタイプが影響する可能性があります
変数の使用方法（ArrayListsは異なります
よりもパフォーマンスとスレッドセーフのプロパティ
リストの他のサブクラス）、したがって、
割り当てを伴う宣言。

読者の期待に違反するコード。
メインである次のコードを検討してください
Javaアプリケーション用のプログラム

public static void main（String [] args）{

new RaftClient（myAddress、serverAddresses）;

}
ほとんどのアプリケーションは、メインプログラムが終了すると終了します

戻るので、読者はそれが
ここで起こります。ただし、そうではありません。 The
RaftClientのコンストラクターは追加を作成します
スレッドは、
アプリケーションのメインスレッドが終了します。この動作
インターフェイスのコメントに文書化する必要があります
RaftClientコンストラクターの場合、動作は
短くする価値があるほど自明ではない
メインの最後にもコメント。コメント
アプリケーションが続行することを示す必要があります
他のスレッドで実行しています。コードは最も明白です
読者が期待する規則に準拠している場合：\ work \ Kindle \ phil \310.png@@期待している;そうでない場合は、
読者が混乱しないように、動作を文書化します。

18.3結論

別の方法

自明性について考えることは
情報の条件。コードが自明でない場合、それは
通常、重要な情報があることを意味します
読者が持っていないコードについて：
RaftClientの例、読者はそれを知らないかもしれません
RaftClientコンストラクターは新しいスレッドを作成しました。の
ペアの例では、読者はそれを知らないかもしれません
結果。 getKey（）は、現在の番号を返します
期間。

コードを明確にするには、次のことを確認する必要があります
読者は常に必要な情報を持っています
それを理解します。これは3つの方法で行うことができます。 The
最善の方法は、情報量を減らすことです
それは、次のような設計手法を使用して必要です
抽象化と特殊なケースの排除。 2番、
あなたは読者が持っている情報を利用することができます
他のコンテキストですでに取得しています（
たとえば、規則に従い、準拠することによって
期待に応えて）読者が新しいことを学ぶ必要がないように
コードの情報。第三に、あなたは提示することができます
コード内の彼らにとって重要な情報、d：\ work \ Kindle \ phil \ 311.png @@良い名前や戦略的な手法などを使用して、
コメント.d：\ work \ Kindle \ phil \312.png@@第19章

ソフトウェアのトレンド

議論された原則を説明する方法として

この本では、この章ではいくつかの傾向について考察します
ソフトウェアで人気のあるパターン
過去数十年にわたる開発。それぞれについて
トレンド、そのトレンドがどのように関連しているかを説明します

この本の原則と原則を使用する
その傾向がレバレッジを提供するかどうかを評価する
ソフトウェアの複雑さに対して。

19.1オブジェクト指向プログラミングと
継承

オブジェクト指向プログラミングは最も

ソフトウェア開発における重要な新しいアイデア

過去30〜40年。それは次のような概念を導入しました

クラス、継承、プライベートメソッド、およびインスタンス

変数。注意深く使用すると、これらのメカニズム

より良いソフトウェア設計を作成するのに役立ちます。 Ford：\ work \ Kindle \ phil \ 313.png @@例、プライベートメソッドと変数は
情報を確実に隠すために使用されます：外部にコードはありません
aclassは、プライベートメソッドを呼び出したりアクセスしたりできます
プライベート変数なので、外部に存在することはできません
それらへの依存。

オブジェクト指向の重要な要素の1つ
プログラミングは継承です。継承が入ります
に異なる意味を持つ2つの形式
ソフトウェアの複雑さ。継承の最初の形式
親クラスがインターフェイスの継承です
1つ以上のメソッドのシグネチャを定義しますが、
メソッドを実装していません。各サブクラス
署名を実装する必要がありますが、異なる
サブクラスは、で同じメソッドを実装できます
違う方法。たとえば、インターフェースは
I/Oを実行するためのメソッドを定義します。 1つのサブクラス
ディスクファイルのI/O操作を実装する可能性があります。
別のサブクラスが同じものを実装する可能性があります
ネットワークソケットの操作。

インターフェイスの継承は、
同じインターフェースを再利用することによる複雑さ
複数の目的。習得した知識を可能にします
1つの問題（I/の使用方法など）を解決する際に

使用するディスクファイルの読み取りおよび書き込み用のOインターフェイス）
他の問題（通信など）を解決するため
ネットワークソケット経由）。別の考え方：\ work \ Kindle \ phil \ 314.png @@これについては、深さの観点からです。
インターフェースの実装、
インターフェイスが深くなります。のために
多くの実装を持つためのインターフェース、それはしなければなりません
基礎となるすべての基本的な機能をキャプチャします
詳細を明確にしながら実装
実装間で異なります。これ
概念は抽象化の中心です。

継承の2番目の形式は
実装の継承。この形式では、
親クラスは、1つまたはの署名だけでなく定義します
より多くのメソッドだけでなく、デフォルトの実装。
サブクラスは、親の継承を選択できます
メソッドの実装またはそれをオーバーライドする
同じシグニチャで新しいメソッドを定義します。
実装の継承がなければ、同じ
メソッドの実装は
いくつかのサブクラスで複製され、
それらのサブクラス間に依存関係を作成します
（変更はで複製する必要があります
メソッドのすべてのコピー）。したがって、実装
継承により、必要なコードの量が削減されます
システムの進化に合わせて変更する。他で
つまり、変化の増幅の問題を軽減します
第2章で説明されていますd：\ work \ Kindle \ phil \ 315.png @@ただし、実装の継承により、
親クラスとそれぞれの間の依存関係
そのサブクラスの。のクラスインスタンス変数
親クラスは、多くの場合、両方の親によってアクセスされます
と子クラス。これにより情報が得られます
継承のクラス間のリーク
階層があり、1つのクラスを変更するのが難しくなります
他を見ずに階層内で。にとって
たとえば、親に変更を加える開発者
クラスはすべてのサブクラスを調べる必要があるかもしれません
変更によって何も壊れないようにするためです。
同様に、サブクラスがのメソッドをオーバーライドする場合
親クラス、サブクラスの開発者
の実装を調べる必要があるかもしれません
親。最悪の場合、

プログラマーは
クラス階層全体の完全な知識
作るために親クラスの下に
いずれかのクラスへの変更。そのクラス階層
実装の継承を広く使用する傾向があります
非常に複雑です。

したがって、実装の継承は次のようになります。
注意して使用してください。実装を使用する前に
継承、アプローチベースかどうかを検討する
構成上で同じ利点を提供できます。にとって
たとえば、小さなヘルパーを使用できる場合があります
共有機能を実装するためのクラス。d：\ work \ kindle \ phil \ 316.png @@親から関数を継承するのではなく、
オリジナルのクラスはそれぞれ、の機能に基づいて構築できます
ヘルパークラス。

に実行可能な代替手段がない場合
実装の継承、分離してみてください
その中の親クラスによって管理される状態
サブクラスによって管理されます。これを行う1つの方法は
完全に管理される特定のインスタンス変数
親クラスのメソッドによって、サブクラスを使用
読み取り専用の方法でのみ、または
親クラスの他のメソッド。これが適用されます
クラス内に隠れている情報の概念
依存関係を減らすための階層。

オブジェクトによって提供されるメカニズムが-
オブジェクト指向プログラミングは、実装を支援できます
きれいなデザイン、彼らはそれ自体では、
良いデザインを保証します。たとえば、クラスが
浅い、または複雑なインターフェイスを持っている、または許可
内部状態への外部アクセス、次に
それでも非常に複雑になります。

19.2アジャイル開発

アジャイル開発はソフトウェアへのアプローチです
1990年代後半に出現した開発
作成方法に関するアイデアのコレクションから：\ work \ Kindle \ phil \ 317.png @@ソフトウェア開発をより軽量にし、

柔軟でインクリメンタル。正式に定義されました
2001年の開業医の会議中に。

アジャイル開発は主にプロセスに関するものです

ソフトウェア開発の（チームの編成、
スケジュールの管理、単体テストの役割、
顧客との対話など）ではなく
ソフトウェア設計。それにもかかわらず、それはいくつかに関連しています
この本の設計原則。

アジャイルの最も重要な要素の1つ
開発は開発という概念です
増分的かつ反復的である必要があります。アジャイルで
アプローチ、ソフトウェアシステムはシリーズで開発されます
それぞれが追加および評価する反復の
いくつかの新機能。各反復には次のものが含まれます
設計、テスト、および顧客からの入力。これは似ています
ここで提唱されているインクリメンタルアプローチに。として
第1章で述べたように、視覚化することはできません
の最初に十分に複雑なシステム
最良の設計を決定するためのプロジェクト。最高の
良いデザインに仕​​上げる方法は、開発することです
増分のシステム。各増分は
既存のいくつかの新しい抽象化とリファクタリングを追加します
経験に基づく抽象化。これはに似ています
アジャイル開発アプローチ。d：\ work \ kindle \ phil \318.png@@アジャイル開発のリスクの1つは
それが戦術的なプログラミングにつながる可能性があること。アジャイル
開発は開発者を機能に集中させる傾向がありますが、
抽象化ではなく、開発者を奨励します
生産するために設計上の決定を延期する
できるだけ早く動作するソフトウェア。例えば、
一部のアジャイル実践者は、あなたがすべきではないと主張します
汎用メカニズムを正しく実装する
あちらへ;最小限の特別な目的を実装する
最初にリファクタリングするメカニズム
後でもっと一般的なものを知ったら
必要だと。これらの議論は
ある程度の感覚で、彼らは投資に反対します
アプローチ、そして彼らはより戦術を奨励します
プログラミングのスタイル。これにより、急速に発生する可能性があります
複雑さの蓄積。

漸進的に開発することは一般的に良いことです
アイデアですが、開発の増分は
機能ではなく、抽象化する必要があります。すべて延期しても大丈夫です
特定の抽象化についての考え
機能に必要です。抽象化が必要になったら、
時間をかけてきれいに設計します。フォローする
第6章のアドバイスとそれをやや一般的にする-
Purpose.d：\ work \ Kindle \ phil \ 319.png@@19.3ユニットテスト

以前は、開発者がテストを作成することはめったにありませんでした。もしも
テストはまったく書かれていませんでした
別のQAチーム。しかし、の信条の1つ
アジャイル開発とは、テストを厳しくする必要があるということです
開発、およびプログラマーと統合
独自のコードのテストを作成する必要があります。この練習
今では広く普及しています。テストは通常
ユニットテストとシステムの2種類に分けられます

テスト。ユニットテストは、最も頻繁に作成されたものです。
開発者。それらは小さく、集中しています：各テスト
通常、単一のコードの小さなセクションを検証します
方法。ユニットテストは、なしで単独で実行できます。
の本番環境のセットアップ
システム。ユニットテストは、多くの場合、
コードのすべての行を確認するためのテストカバレッジツール
アプリケーションでテストされます。開発者がいつでも
新しいコードを書くか、既存のコードを変更します。
維持するためにユニットテストを更新する責任があります
適切なテストカバレッジ。

2番目の種類のテストは、システムテストで構成されます
（統合テストと呼ばれることもあります）、

確実にする
アプリケーションのさまざまな部分がすべて機能すること
適切に一緒に。彼らは通常、実行することを含みます
アプリケーション全体は、本番環境と同様の条件で：\ work \ Kindle \ phil \320.png@@。システムテストは
別のQAまたはテストチームによって作成されました。

テスト、特に単体テストは重要な役割を果たします
ソフトウェア設計における役割
リファクタリング。テストスイートがないと、
システムに主要な構造変更を加えます。あります
バグを見つける簡単な方法がないため、バグが発生する可能性があります
新しいコードがデプロイされるまで検出されません。
彼らが見つけるのにはるかに高価な場所
と修正します。その結果、開発者はリファクタリングを回避します
優れたテストスイートのないシステム。彼らはしようとします
新しいごとのコード変更の数を最小限に抑える
機能またはバグ修正、つまり複雑さ
蓄積し、設計ミスは発生しません
修正しました。優れた一連のテストにより、開発者は次のことができます。
リファクタリングの際に自信を持ってください。
テストスイートは、導入されたほとんどのバグを検出します。
これにより、開発者は構造化することができます
システムの改善。これにより、システムが改善されます。
設計。

ユニットテストは特に価値があります：それらは提供します
システムテストよりも高度なコードカバレッジ、
そのため、バグを発見する可能性が高くなります。

たとえば、の開発中に
Tclスクリプト言語、改善することにしました
Tclのインタプリタをad：\ work \ Kindle \ phil \321.png@@バイトコードコンパイラに置き換えることによるパフォーマンス。これは大きな変化でした
コアTclエンジンのほぼすべての部分に影響を与えました。
幸い、Tclには優れたユニットテストスイートがありました。
これを新しいバイトコードエンジンで実行しました。 The
既存のテストはバグを発見するのに非常に効果的でした
新しいエンジンでは、バグが1つだけ発生しました
バイトコードコンパイラのアルファリリース後。

19.4テスト駆動開発

テスト駆動開発はソフトウェアへのアプローチです
プログラマーが単体テストを書く開発
彼らがコードを書く前に。新しいクラスを作成するときは、
開発者は最初にクラスの単体テストを作成します。
その予想される動作に基づいています。テストはありません
クラスのコードがないため、合格します。そうして
開発者は、一度に1つずつテストを実行します。
そのテストに合格するのに十分なコードを書く。すべてのとき
テストに合格すると、クラスは終了します。

私はユニットテストを強く支持していますが、
Iamはテスト駆動開発のファンではありません。 The
テスト駆動開発の問題はそれです
特定の機能を取得することに焦点を当てています
最高のデザインを見つけるのではなく、機能します。これ
戦術的なプログラミングは純粋でシンプルで、
その不利な点の。テスト駆動開発はやっかいです：\ work \ kindle \ phil \ 322.png @@インクリメンタル：いつでも、
次の機能をハックして次のテストを行うだけです
パス。設計を行う明確な時期がないので、
混乱してしまうのは簡単です。

セクション19.2で述べたように、
開発は機能ではなく抽象化である必要があります。
抽象化の必要性を発見したら、
時間の経過とともに抽象化を分割して作成しないでください。
一度にすべてを設計する（または少なくとも提供するのに十分な）
適度に包括的なコア機能のセット）。
これにより、すっきりとしたデザインが生まれる可能性が高くなります。
ピースはうまく合います。

書くことが理にかなっている1つの場所
最初のテストは、バグを修正するときです。バグを修正する前に、
バグが原因で失敗する単体テストを作成します。それで
バグを修正し、ユニットテストを今すぐ確認してください
パスします。これはあなたが本当にあなたを確認するための最良の方法です
バグを修正しました。書く前にバグを修正した場合
テストでは、新しい単体テストが実行されない可能性があります
実際にバグを引き起こしますが、その場合はわかりません
あなたが本当に問題を解決したかどうか。

19.5デザインパターン

デザインパターンは一般的に使用されるアプローチです
d：\ work \ Kindle \ phil \323.png@@イテレータやオブザーバーなどの特定の種類の問題を解決するため。デザインの概念
パターンは本デザインによって普及しました
パターン：再利用可能なオブジェクト指向の要素
Gamma、Helm、Johnson、およびVlissidesによるソフトウェア
とデザインパターンは現在、オブジェクトで広く使用されています-
指向のソフトウェア開発。

デザインパターンは、
設計：新しいメカニズムを設計するのではなく
ゼロから、よく知られているデザインを適用するだけです
パターン。ほとんどの場合、これは良いことです：デザイン
それらが共通を解決するためにパターンが生じた
問題、そして彼らは一般的に同意されているので
クリーンなソリューションを提供します。デザインパターンが機能する場合
特定の状況では、おそらく
別のアプローチを思い付くのは難しい
それのほうがいい。

デザインパターンの最大のリスクは過剰です
応用。すべての問題を解決できるわけではありません
既存のデザインパターンできれいに;試さないでください
問題をデザインパターンに強制する場合
カスタムアプローチはよりクリーンになります。デザインを使用する
パターンはソフトウェアを自動的に改善しません
システム;デザインパターンが適合する場合にのみそうします。として
ソフトウェア設計の多くのアイデアで、その概念
デザインパターンが良いとは限らない
そのより多くのデザインパット

アジサシはより良いです。d：\ work \ Kindle \ phil \ 324.png@@19.6ゲッターとセッター

Javaプログラミングコミュニティでは、getterと
セッターメソッドは人気のあるデザインパターンです。 A
ゲッターとセッターはインスタンスに関連付けられています
クラスの変数。 getFooのような名前が付いています
setFoo。ここで、Fooは変数の名前です。
getterメソッドは、の現在の値を返します。
変数であり、setterメソッドは値を変更します。

ゲッターとセッターは厳密には必要ありませんが、
インスタンス変数を公開できるためです。 The
ゲッターとセッターの議論は、彼らが許可するということです
取得中に実行される追加機能
および設定、たとえば関連する値の更新
変数が変更され、リスナーに変更が通知されます。
または値に制約を適用します。これらがあったとしても
機能は最初は必要ありませんが、追加できます
後でインターフェースを変更せずに。

ゲッターとを使用することは理にかなっているかもしれませんが
セッターインスタンス変数を公開する必要がある場合は、
最初にインスタンス変数を公開しない方がよい
場所。公開されたインスタンス変数は、その部分を意味します
クラスの実装の一部が外部に表示されます。
これは情報隠蔽の考えに違反し、
クラスのインターフェースの複雑さが増します。
ゲッターとセッターは浅い方法です（通常は
1行のみ）、クラスのsd：\ work \ Kindle \ phil \ 325.png @@インターフェースに、多くの機能を提供せずに混乱を追加します。
ゲッターやセッター（または
実装データの公開）
可能。

デザインパターンを確立するリスクの1つ
開発者はパターンが良好であると想定し、
できるだけ使ってみてください。これはにつながっています
Javaでのゲッターとセッターの乱用。

19.7結論

新たな提案に出会ったときはいつでも
ソフトウェア開発パラダイム、
複雑さの観点：提案は
全体の複雑さを最小限に抑えるのに本当に役立ちます
ソフトウェアシステム？多くの提案は上手く聞こえます
表面ですが、もっと深く見ると
それらのいくつかは複雑さを悪化させるのではなく、
better.d：\ work \ Kindle \ phil \326.png@@第20章

パフォーマンスのための設計

この時点まで、ソフトウェアの議論
デザインは複雑さに焦点を合わせています。目標は
ソフトウェアをできるだけシンプルで理解しやすいものにする
可能。しかし、システムで作業している場合はどうなりますか
それは速くする必要がありますか？パフォーマンスはどのようにすべきか
考慮事項は設計プロセスに影響しますか？これ
この章では、高性能を実現する方法について説明します
すっきりとしたデザインを犠牲にすることなく。最も
重要なアイデアはまだシンプルです：だけでなく
シンプルさはシステムの設計を改善しますが、通常は
システムを高速化します。

20.1パフォーマンスの考え方

取り組むべき最初の質問は「いくら
中のパフォーマンスについて心配する必要があります

通常の開発プロセス？」あなたがしようとすると
すべてのステートメントを最大速度に最適化します。itd：\ work \ Kindle \ phil \ 327.png @@は開発を遅くし、多くのステートメントを作成します
不必要な複雑さ。さらに、多くの
「最適化」は実際にはパフォーマンスに役立ちません。
一方、完全に無視すると
パフォーマンスの問題、簡単に
多数の重大な非効率性が広がる
コード全体。結果として得られるシステムは
必要な速度よりも5〜10倍遅くなります。これで
「1000カットによる死」シナリオは難しい
後で戻ってパフォーマンスを向上させ、
単一の改善がないため
多くの影響があります。

最善のアプローチは、これらの間の何かです
極端な、あなたがの基本的な知識を使用する
設計の代替案を選択するためのパフォーマンス
「自然に効率的」でありながら、クリーンでシンプルです。 The
重要なのは、どの操作についての認識を高めることです
基本的に高価です。ここにいくつかあります
比較的高価な操作の例
今日：

+ネットワーク通信：
データセンター、往復メッセージ交換
10-50 usを取ることができます、これは数十です
何千もの指導時間。広い領域
ラウンドトリップには10〜100ミリ秒かかる場合があります。d：\ work \ Kindle \ phil \ 328.png @@ -1 / Oからセカンダリストレージ：ディスクI/O操作
通常、5〜10ミリ秒かかります。これは、数百万です。
指導時間。フラッシュストレージには10が必要です。
100年新たに出現した不揮発性メモリ
1 usと同じくらい速いかもしれませんが、これはまだ周りにあります
2000命令回。

+動的メモリ割り当て（Cでのmalloc、新規
C ++またはJavaの場合）通常、重要なものが含まれます
割り当て、解放、およびガベージのオーバーヘッド
コレクション。

+キャッシュミス：DRAMからのデータのフェッチ
オンチッププロセッサのキャッシュに
数百回の指導;の
多くのプログラム、全体的なパフォーマンスは
キャッシュミスによって決定されるのと同じくらい
計算コスト。

物事が何であるかを学ぶための最良の方法
高価なのはマイクロベンチマークを実行することです（小さい
単一のコストを測定するプログラム
単独での操作）。 RAMCloudプロジェクトでは、
を提供する簡単なプログラムを作成しました
マイクロベンチマークのフレームワーク。少し時間がかかりました
フレームワークを作成する日数が、フレームワーク
新しいマイクロベンチマークを追加することが可能になります
5分または10分で。

これにより、
数十のマイクロベンチマークを蓄積します。水：\ work \ Kindle \ phil \ 329.png @@これらの両方を使用して、
RAMCloudで使用されている既存のライブラリ、および
のために書かれた新しいクラスのパフォーマンスを測定する
RAMCloud。

あなたが何であるかについての一般的な感覚を持ったら
高価で何が安いのか、あなたはそれを使うことができます
いつでも安い操作を選択するための情報
可能。多くの場合、より効率的なアプローチ
遅いアプローチと同じくらい簡単になります。にとって
たとえば、オブジェクトの大規模なコレクションを保存する場合
キー値を使用して検索されます。
ハッシュテーブルまたは順序付きマップのいずれかを使用します。どちらも
ライブラリパッケージで一般的に利用可能であり、両方
シンプルでクリーンに使用できます。ただし、ハッシュテーブル
簡単に5〜10倍速くすることができます。したがって、を使用する必要があります
順序付けプロパティが必要でない限り、ハッシュテーブル
マップによって提供されます。

別の例として、
CやC++などの言語の構造体の配列。
これを行うには2つの方法があります。 1つの方法は
構造体へのポインタを保持する配列。
最初にアレイにスペースを割り当て、次にスペースを割り当てる必要がある場合
個々の構造ごとにスペースを割り当てます。です
構造を格納するのがはるかに効率的
配列自体なので、1つの大きなブロックのみを割り当てます
every.d：\ work \ Kindle \ phil \330.png@@効率を改善する唯一の方法が
複雑さを加えると、選択はより困難になります。
より効率的な設計でわずかなものしか追加されない場合
複雑さの量、および複雑さが
非表示なので、インターフェースには影響しません。
それは価値があるかもしれません（しかし注意してください：複雑さ
増分です）。より高速な設計が多くを追加する場合
実装の複雑さの、またはそれが結果として生じる場合
より複雑なインターフェースでは、
より単純なアプローチから始めて、
パフォーマンスがbeaであることが判明した場合は、後で最適化する
問題。ただし、明確な証拠がある場合は
パフォーマンスは特に重要になります
状況に応じて、
すぐにアプローチします。

RAMCloudプロジェクトでは、全体の1つです
目標は、可能な限り低いレイテンシを提供することでした
ストレージシステムにアクセスするクライアントマシン
データセンターネットワーク。その結果、使用することにしました
ネットワーキング用の特別なハードウェア。
カーネルをバイパスして通信するRAMCloud
ネットワークインターフェイスコントローラを使用して直接
パケットを送受信します。私たちはこの決定をしました
複雑さが増したとしても、
以前の測定から、カーネルベースであることを知っていました
ネットワーキングは遅すぎて私たちのニーズを満たすことができません。 Ind：\ work \ Kindle \ phil \331.png@@残りのRAMCloudシステムのほとんどは
シンプルにするために設計することができます。これを大きくする
「正しい」問題は、他の多くのことを容易にしました。

一般に、単純なコードはより高速に実行される傾向があります
複雑なコード。特別なものを定義した場合
ケースと例外の場合、コードは必要ありません
これらのケースを確認すると、システムがより高速に実行されます。
深いクラスは浅いクラスよりも効率的です。
それぞれの方法でより多くの作業が行われるためです
電話。浅いクラスは、より多くのレイヤー交差をもたらします。
レイヤーが交差するたびにオーバーヘッドが追加されます。

20.2変更前（および変更後）の測定
しかし、システムがまだ遅すぎると仮定します。

説明どおりに設計した場合でも
その上。急いで作り始めたくなる
直感に基づいてパフォーマンスを微調整
何が遅いかについて。これをしないでください！プログラマーの
パフォーマンスに関する直感は信頼できません。これ
経験豊富な開発者にも当てはまります。もし、あんたが
直感に基づいて変更を加え始めると、
実際には改善されないことに時間を浪費する
パフォーマンス、そしてあなたはおそらくシステムを作るでしょう

プロセスがより複雑になります。d：\ work \ kindle \ phil \ 332.png @@変更を加える前に、
システムの既存の動作。これは2つになります
目的。まず、測定により識別されます
パフォーマンスチューニングが行われる場所
最大の影響。測定するだけでは不十分です
トップレベルのシステムパフォーマンス。これはかもしれません
システムが遅すぎると言いますが、
理由を教えてください。あなたはより深く測定する必要があります
に寄与する要因を詳細に特定する
全体的なパフォーマンス;目標は小さなものを特定することです
システムが存在する非常に特定の場所の数
現在多くの時間を費やしています、そしてあなたはどこに
改善のためのアイデアがあります。 2番目の目的
測定値の1つはベースラインを提供することであるため、
作成後にパフォーマンスを再測定できること
パフォーマンスを実際に確保するための変更
改善されました。変更によって測定可能にならない場合
パフォーマンスの違い、それからそれらを元に戻す
（システムを単純化した場合を除きます）。ありません
それが提供しない限り、複雑さを保持することのポイント
大幅なスピードアップ。

20.3クリティカルパスを中心とした設計

この時点で、慎重に
パフォーマンスを分析し、全体に影響を与えるのに十分遅いコードの断片：\ work \ Kindle \ phil \333.png@@を特定しました
システムパフォーマンス。改善するための最良の方法
そのパフォーマンスは「基本的な」chであります

アンジュ、
キャッシュの導入や別のキャッシュの使用など
アルゴリズム的アプローチ（バランスの取れたツリーとリスト、
実例）。カーネルをバイパスするという私たちの決定
RAMCloudのネットワーク通信は
基本的な修正の例。識別できれば
基本的な修正、それからあなたはそれを実装することができます
前に説明した設計手法を使用する
章。

残念ながら、状況が発生することがあります
基本的な修正がない場合。これは
この章の中心的な問題に私たちを
既存のコードを再設計して、
より速く実行されます。これがあなたの最後の手段になるはずです、そしてそれは
頻繁に発生することはありませんが、場合によっては発生します
大きな違いを生むことができます。重要なアイデアは設計することです
クリティカルパス周辺のコード。

最小のものは何かを自問することから始めます
実行するために実行する必要のあるコードの量
一般的な場合の目的のタスク。無視する
既存のコード構造。代わりにあなたが
ちょうどを実装する新しいメソッドを書いています
の最小量であるクリティカルパス
最も一般的な：\ work \ Kindle \ phil \334.png@@の場合に実行する必要のあるコード。現在のコードはおそらく散らかっています
特殊なケース;この演習ではそれらを無視してください。 The
現在のコードはいくつかのメソッドを通過する可能性があります
クリティカルパスを呼び出します。代わりにあなたが
関連するすべてのコードを1つのメソッドにまとめることができます。
現在のコードでもさまざまな変数を使用できます
およびデータ構造。必要なデータのみを検討する
クリティカルパスのために、そしてどんなデータでも仮定します
構造は重要な人にとって最も便利です

道。たとえば、組み合わせるのが理にかなっているかもしれません
複数の変数を1つの値に。と仮定する
システムを順番に完全に再設計できます
のために実行する必要があるコードを最小限に抑えるため
クリティカルパス。このコードを「理想」と呼びましょう。

理想的なコードはおそらくあなたと衝突します
既存のクラス構造であり、実用的ではない可能性がありますが、
しかし、それは良い目標を提供します：これは
コードがこれまでにないほど単純で最速です。 The
次のステップは、来る新しいデザインを探すことです
まだ持っている間、理想に可能な限り近い
きれいな構造。すべてのデザインを適用できます
この本の前の章からのアイデア、しかし
理想を維持するという追加の制約があります
コードは（ほとんど）無傷です。あなたは少し追加する必要があるかもしれません
きれいにするために理想への余分なコードの

抽象化;たとえば、コードにad：\ work \ Kindle \ phil \ 335.png @@ハッシュテーブルルックアップが含まれている場合は、追加のハッシュテーブルルックアップを導入しても問題ありません。
汎用ハッシュテーブルクラスへのメソッド呼び出し。の
私の経験では、ほとんどの場合、
クリーンでシンプルでありながら、非常に近いデザイン
理想に。

発生する最も重要なことの1つ
このプロセスでは、特別なケースをから削除します
クリティカルパス。コードが遅い場合、それは多くの場合、
さまざまな状況に対応する必要があり、
コードは、の処理を簡素化するように構造化されます
すべての異なるケース。それぞれの特殊なケースは、
クリティカルパスへのコードの少し
追加の条件文および/またはメソッドの
呼び出します。これらの追加のそれぞれは、コードを少しします
もっとゆっくり。パフォーマンスのために再設計するときは、
あなたがしなければならない特別なケースの数を最小限に抑える
小切手。理想的には、次の場所に単一のifステートメントがあります。
最初は、すべての特殊なケースを検出します
1つのテスト。通常の場合、この1つのテストのみが実行されます
作成する必要があります。その後、クリティカルパスを作成できます。
特別な場合の追加テストなしで実行されます。
最初のテストが失敗した場合（これは特別な場合を意味します
発生しました）コードは別のものに分岐できます
それを処理するためにクリティカルパスを外します。パフォーマンス

特殊なケースではそれほど重要ではないため、次のようにできます。\ work \ kindle \ phil \ 336.png @@構造化して、単純にするために特殊なケースのコードを

パフォーマンスより。

20.4例：RAMCloudバッファー

Bufferクラスの例を考えてみましょう
RAMCloudストレージシステムの
最も一般的なものの約2倍のスピードアップを達成する
オペレーション。

RAMCloudはBufferオブジェクトを使用して管理します
リクエストなどのメモリの可変長配列
リモートプロシージャコールの応答メッセージ。
バッファは、からのオーバーヘッドを削減するように設計されています
メモリのコピーと動的なストレージ割り当て。
バッファは、次の線形配列のように見えるものを格納します
バイトですが、効率のために、基礎となるものを許可します
複数の不連続に分割されるストレージ
図20.1に示すように、メモリのチャンク。 A
バッファは、データのチャンクを追加することによって作成されます。各
チャンクは外部または内部のいずれかです。チャンクが
外部の場合、そのストレージは呼び出し元が所有します。 the
バッファは、このストレージへの参照を保持します。外部の
チャンクは通常、大きなチャンクに順番に使用されます
メモリのコピーを避けるため。チャンクが内部の場合、
バッファはチャンクのストレージを所有します。 datad：\ work \ Kindle \ phil \ 337.png発信者から提供された@@は、バッファにコピーされます
内部記憶装置。

論理配列

ビルトイン
割り当て

cm

追加
割り当て



外部チャンク

バッファオブジェクト

図20.1：Bufferオブジェクトは

記憶のコレクション
バイトの線形配列のように見えるものを格納するチャンク。
内部チャンクはバッファによって所有され、
バッファが破壊されました。外部チャンクは、によって所有されていません
バッファ。

各バッファには、小さな組み込みの割り当てが含まれています。
これは、保存に使用できるメモリのブロックです。
内部チャンク。このスペースが使い果たされた場合、
バッファは追加の割り当てを作成します。
バッファが破壊されると解放されます。内部チャンク
メモリが小さなチャンクに便利です
コピーコストはごくわずかです。図20.1は
5つのチャンクを持つバッファ：最初のチャンクは内部であり、
次の2つは外部で、最後の2つのチャンクは
内部。

Bufferクラス自体は、「基本的な
修正してください。」それがなければ必要だったであろうコピーされた高価なメモリを排除するという点で：\ work \ Kindle \ phil \338.png@@。にとって
たとえば、応答メッセージを組み立てるとき
短いヘッダーとの内容を含む

RAMCloudストレージシステム内の大きなオブジェクト、
RAMCloudは、2つのチャンクを持つバッファーを使用します。最初
チャンクはヘッダーを含む内部のものです。
2番目のチャンクは参照する外部チャンクです

RAMCloudストレージのオブジェクトコンテンツに
システム。応答はバッファに収集できます
大きなオブジェクトをコピーせずに。

の基本的なアプローチは別として
不連続なチャンクを許可しましたが、
Bufferクラスのコードを最適化しようとします
元の実装では。時間とともに、
ただし、バッファがより多くで使用されていることに気づきました
およびその他の状況。たとえば、少なくとも4つ
バッファは、それぞれの実行中に作成されます
リモートプロシージャコール。最終的に、それは明らかになりました
バッファの実装をスピードアップします
システム全体に顕著な影響を与える可能性があります
パフォーマンス。改善できるかどうかを確認することにしました
Bufferクラスのパフォーマンス。

バッファの最も一般的な操作は次のとおりです。
を使用して少量の新しいデータ用のスペースを割り当てます
内部チャンク。これは、たとえば、発生します
リクエストとレスポンスのヘッダーを作成する場合：\ work \ Kindle \ phil \339.png@@メッセージ。この操作を次のように使用することにしました
最適化のクリティカルパス。最も単純な
考えられる場合、スペースはによって割り当てることができます
バッファ内の最後の既存のチャンクを拡大します。
ただし、これは最後に存在する場合にのみ可能です
チャンクは内部にあり、十分なスペースがある場合
新しいデータに対応するための割り当て。 The
理想的なコードは、確認のために1回のチェックを実行します
単純なアプローチが可能であるとすると、
既存のチャンクのサイズを調整します。

図20.2は、
メソッドで始まるクリティカルパス
バッファ::alloc。可能な限り最速の場合、
バッファ::allocはバッファ::allocateAppendを呼び出します。
Buffer :: Al location：：allocateAppendを呼び出します。から
パフォーマンスの観点から、このコードには2つあります
問題。最初の問題は、複数の特別なことです
ケースは個別にチェックされ、場合によってはチェックされます
繰り返し。まず、バッファ::allocateAppendチェックを
バッファに現在割り当てがあるかどうかを確認します。それで
コードは、現在の割り当てがあるかどうかを確認するために2回チェックします
新しいデータのための十分な余地があります：一度
バッファ::割り当て::allocateAppend、および
その戻り値は、Buffer::allocateAppendによってテストされます。
さらに、拡張しようとするのではなく
最後のチャンクを直接、コードは最後のチャンクを考慮せずに新しいspaced：\ work \ Kindle \ phil \340.png@@を割り当てます。それで
バッファ::allocは、割り当てられたスペースがあるかどうかを確認します
たまたま最後のチャンクに隣接していて、
新しいスペースを既存のスペースとマージする場合
チャンク。これにより、追加のチェックが行われます。全体、
このコードは、クリティカルで6つの異なる条件をテストします
道。

元のコードの2番目の問題
レイヤーが多すぎるということです。
浅い。これはパフォーマンスの問題であり、
設計上の問題。クリティカルパスは2つになります
元のメソッドに加えて追加のメソッド呼び出し
バッファの呼び出し::alloc。各メソッド呼び出し
追加の時間がかかり、これらのケースの1つでは
呼び出しの結果は、呼び出し元が確認する必要があります。
その結果、考慮すべき別の特別なケースが発生します。
第7章では、抽象化の方法について説明しました
通常、1つのレイヤーから
別の、しかし図の3つの方法すべて
20.2は同一の署名を持ち、それらは
本質的に同じ抽象化。これは危険信号です。
バッファ::allocateAppendはほぼパススルーです
方法;その唯一の貢献は、新しいものを作成することです
必要に応じて割り当てます。余分なレイヤーがコードを作成します

低速で複雑です。d：\ work \ kindle \ phil \ 341.png @@これらの問題を修正するために、バッファをリファクタリングしました
そのデザインが最も中心にあるようにクラス
パフォーマンスクリティカルパス。私たちは考えていません
上記の割り当てコードだけですが、他にもいくつかあります
の取得など、一般的に実行されるパス
現在格納されているデータの総バイト数
バッファ。これらのクリティカルパスのそれぞれについて、
必要なコードの最小量を特定する
一般的なケースで実行されます。それから私達はd

署名された
これらのクリティカルパスに関するクラスの残りの部分。我々
この本のデザイン原則も適用しました
一般的にクラスを簡素化するため。たとえば、
浅い層を排除し、より深い内部を作成しました
抽象化、および特別な数を減らしました
チェックするケース。リファクタリングされたクラスは20％小さくなります
元のバージョンよりも（1476行のコードに対して
オリジナルの1886行）.d：\ work \ kindle \ phil \ 342.png @@ chars Buffer :: allocCint nunBytes）

char data = aTocateappend（oumytes）
Buffer :: Chunk + lastchunk〜this-> branchsTaiT;
if Clastchunk！= NULL && TastChunk-> isntteralQ）68
（Gata〜lastChunk-> length = Tastchunk-> data））
U /高速パス：既存のチャンクを成長させ、
TastChunke>長さ
‘このstotallength
ペレ{
77割り当てられたデータから新しいチャンクを作成します。
append（data、munbytes）;、

戻りデータ：

1）バッファの最後に新しいスペースを配置します：最後にスペースを使用します
可能であれば、最後の現在の割り当ての7/。それ以外の場合は、
17の新しいaTlocation。新しいスペースへのポインタを返します。
Chars Buffer：：alTocatesppendCint size）{
ボイドデータ：
HF Cehis-> aTlocations t = NULL）￠
‘data = this al location-> alllocateAppend（size）：
Sf（ava l = NULL）f
V7ファストパス
データを返す

5

2
‘data = newAlTocation（0、size）-> aTTocateappend（size）：
assert（data I = NULL）;
戻りデータ：

、

1）既存の割り当ての最後にスペースを配置するように指示します。戻り値
1へのポインタ。新しいスペース、または十分なルースがない場合はマル。
'野ウサギ！バッファー：ATの場所：alTocateappendCintサイズ）{

CCthis-schunkTop〜this-> appendTop）〜<size）の場合

で新しいスペースを割り当てるための元のコード

内部チャンクを使用して、バッファの終わり。

chars Buffer :: alloc（int numBytes）
if（this-> availableAppend8ytes> = numBytes）{

//現在の直後に余分なスペースがあります
7 /広大なチャンクなので、新しいものを割り当てることができます
//そこにベジオン。
バッファ::チャンクチャンク=this->lastChunk：
charsresult=チャンク->データ+チャンク->長さ;
‘チャンク->強度+ = numBytes;
‘this-> avai lableAppendBytes
this-> totalLength + = numBytes
結果を返します。

numBytes;

7
//新しいチャンクを作成する必要があります。
oo
図20.3：新しいスペースを割り当てるための新しいコード

Buffer.d：\ work \ Kindle \ phil \ 343.png @@の内部チャンク図20.3は、の新しいクリティカルパスを示しています。
バッファ内の内部スペースの割り当て。新しい
コードは高速であるだけでなく、読みやすく、
浅い抽象化を回避するためです。全体
パスは単一のメソッドで処理され、
すべての特殊なケースを除外するための単一のテスト。 The
新しいコードは、新しいインスタンス変数を導入します。
avai lableAppendBytes、単純化するために
クリティカルパス。この変数は、どれだけを追跡します
最後の直後に未使用スペースが利用可能です
バッファ内のチャンク。利用可能なスペースがない場合は、
または、バッファの最後のチャンクが内部ではない場合
チャンク、またはバッファにチャンクがまったく含まれていない場合は、
その場合、availableAppendBytesはゼロです。 3つの異なる
テストするだけで、特殊なケースを一度にチェックできます
利用可能なableAppendBytes。図20.3のコード
可能な限り少ないコード量を表す
スペースが利用可能な一般的なケースを処理します。

注：totalLengthの更新は次のようになっている可能性があります
バッファの全長を再計算することで排除
必要なときにいつでも個々のチャンクから。
ただし、このアプローチは、
多くのチャンクを持つ大きなバッファ、およびフェッチ
バッファの合計の長さは、もう1つの一般的な操作です。
したがって、バッファを確保するために、allocに少量のextrad：\ work \ Kindle \ phil \344.png@@オーバーヘッドを追加することを選択しました。
長さはいつでもすぐに利用できます。

新しいコードは古いコードの約2倍の速さです
コード：1バイトの文字列を追加する合計時間
内部ストレージを使用するバッファーが8.8nsから
4.75ns。他の多くのバッファ操作も高速化されました
改訂のためにアップ。たとえば、時間
新しいバッファを構築するには、小さなチャンクを追加します
内部ストレージにあり、ドロップされたバッファを破棄します
24nsから12nsまで。

20.5結論

これからの最も重要な全体的な教訓
章はそのすっきりとしたデザインと高性能です
互換性があります。 Bufferクラスの書き換えが改善されました
簡素化しながら2倍のパフォーマンス
その設計とコードサイズの20％削減。
複雑なコードは遅い傾向があります
無関係または冗長な作業。一方で、
クリーンでシンプルなコードを書くと、システムは
おそらく十分に速いので、
そもそもパフォーマンスについては心配する必要があります。
最適化する必要があるいくつかのケースでは
パフォーマンス、鍵は再びシンプルさです：found：\ work \ Kindle \ phil \345.png@@最も重要なクリティカルパス
パフォーマンスを向上させ、可能な限りシンプルにします。d：\ work \ Kindle \ phil \346.png@@第21章

重要なことを決定する

善の最も重要な要素の1つ
ソフトウェア設計は、重要なものを分離しています
何でも構いません構造ソフトウェアシステム
重要なことの周り。そのことのために
それほど重要ではありません、それらの影響を最小限に抑えるようにしてください
システムの残りの部分。重要なことはすべきです
強調する

熱狂し、より明白になりました。そのこと
できる限り隠しておくべきです。
前の章のアイデアの多くは
彼らの心の中で重要なものを分離するという概念
そうでないものから。たとえば、これは私たちが
抽象化を設計するときに行います。のインターフェース
モジュールは、そのユーザーにとって重要なことを反映します
モジュール;モジュールに関係のないこと
ユーザーは実装で非表示にする必要があります、
それらがあまり明白でないところ。を選択するとき
変数名、目標はいくつかの単語を選ぶことです
d：\ work \ Kindle \ phil \ 347.png @@変数に関する最も可能性のある情報を伝達し、名前にそれらを使用します。これらは
最も重要な変数の側面。もしも
モジュールにとってパフォーマンスは本当に重要です。
モジュールの設計は、
パフォーマンス目標の達成。の例では
セクション20.4、これは、
パフォーマンスクリティカルパスでは、メソッド呼び出しがほとんどありませんでした
としながら、可能な限り特別な場合のチェック
クリーンでシンプル、そして明白です。

21.1重要なことを決定する方法は？

重要なことが課せられることもあります
システムの外部制約として、
セクション20.4のパフォーマンス。多くの場合、それは
重要なことを決定する設計者。ときでさえ
外部の制約がある場合、設計者は
それらを達成する上で最も重要なことを理解する
制約。

重要なことを決定するには、レバレッジを探します。
1つの問題の解決策により、他の多くの問題も可能になります
解決すべき問題、またはワンピースを知っている場所
情報の多くを理解しやすくします
他のもの。たとえば、
汎用のセクション6.2にテキストを保存する方法
d：\ work \ Kindle \ phil \ 348.png @@文字の範囲を挿入および削除するためのインターフェースは、多くの問題を解決するために使用できます。
一方、バックスペースなどの特殊な方法
1つの問題だけを解決しました。汎用
インターフェイスはより多くのレバレッジを提供しました。のレベルで
テキストクラスのインターフェース、
インターフェイスは、に応答して呼び出されていました
バックスペースキー;本当に重要だったのはそれだけでした
テキストを削除する必要がありました。不変量は別のものです
レバレッジポイントの例：一度知ったら
変数または構造に対して不変であるため、予測できます
その変数または構造が多くの場合どのように動作するか
さまざまな状況。

何が最も重要かを判断するのは簡単です
複数のオプションから選択できる場合。にとって
たとえば、変数名を選択するときは、
その変数に関連する単語の精神的なリスト、
次に、最もよく伝える単語をいくつか選びます
情報。それらの単語を使用して変数を形成します
名前。これは「2回デザインする」の例です。
原理。

時々、どれがはっきりしないかもしれません
最も重要なのは;これは特に難しい場合があります
あまり持っていない若い開発者向け
経験。このような状況では、私はお勧めします
仮説を立てる：「これが重要だと思う
多くの。"次に、その仮説にコミットし、その仮定の下でシステムを構築しました：\ work \ Kindle \ phil \ 349.png @@

それはうまくいきます。あなたの仮説が正しかったなら、考えてください
なぜそれが正しくなったのか、そして何の手がかりについて
で使用できることがあったかもしれません
将来。あなたの仮説が間違っていたとしても、それはまだです
OK：なぜそれが間違っていたのか考えてください
あなたが使うことができた手がかりがあったかどうか
この選択を避けるために。いずれにせよ、あなたはから学ぶでしょう
経験とあなたは徐々に良くなります
そしてより良い選択。

21.2重要なことを最小限に抑える

できるだけ問題を少なくするようにしてください：これは
よりシンプルなシステムになります。たとえば、
必要なパラメータの数を最小限に抑える
オブジェクトを構築するため、またはデフォルトを提供するために指定
最も一般的な使用法を反映する値。物事のために
それは重要です、の数を最小限に抑えるようにしてください
それらが重要な場所。ある情報
モジュール内に隠されていることはコーディングに関係ありません
そのモジュールの外。例外を処理できる場合
システム内で完全に低レベルである場合、そうではありません
システムの残りの部分にとって重要です。構成の場合
パラメータは自動的に計算できます

システムの動作について（and：\ work \ Kindle \ phil \ 350.png @@管理者が手動で選択するために公開するのではなく）、それはもはやありません
管理者にとって重要です。

21.3重要なことを強調する方法

重要なことを特定したら、
デザインでそれらを強調する必要があります。 1
強調する方法は目立つことです：重要
物事はより多くの場所に表示される必要があります
インターフェイスのドキュメントなど、見られる可能性が高い、
名前、または頻繁に使用されるメソッドのパラメーター。
強調するもう1つの方法は、繰り返しです。キー
アイデアは何度も何度も現れます。第三の道

強調するのは中心性です。そのこと
最も重要なのは、
システム、彼らはの構造を決定します
それらの周りのもの。一例はインターフェースです
オペレーティングシステムのデバイスドライバー用。これは
何百または何千もの
ドライバーはそれに依存します。

もちろん、

rseも当てはまります：アイデアの場合
見られる可能性が高い、またはそれが上に表示され、
もう一度、またはそれがシステムの構造に影響を与える場合
重要な方法、そしてその考えは重要です。

同様に、重要ではないことは
強調されていない。 それらはできるだけ隠されるべきです

d：\ work \ Kindle \ phil \ 351.png @@可能な限り、遭遇しないようにしてください
頻繁に、そしてそれらは影響を与えるべきではありません
システムの構造。

21.4間違い

重要なことを決定する際には、2種類あります
あなたが犯すことができる間違い。最初の間違いは
あまりにも多くのものを重要なものとして扱います。このとき
重要でないことがデザインを乱雑にし、
複雑さを増し、認知的負荷を増大させます。
1つの例は、次の引数を持つメソッドです。
ほとんどの発信者には関係ありません。別の例は
26ページで説明されているJavaI/ Oインターフェース：強制
開発者は、
バッファリングされたI/OとバッファリングされていないI/O
区別はほとんど重要ではありません（開発者
ほとんどの場合、バッファリングが必要であり、
明示的にそれを求める時間を無駄にします）。浅いクラス
多くの場合、あまりにも多くのものを次のように扱った結果です
重要。

2番目の種類の間違いは認識に失敗することです
その何かが重要です。この間違いは
重要な情報が隠されている状況、
または重要な機能が利用できないので
開発者は継続的にそれを再作成する必要があります。この種の：\ work \ Kindle \ phil \ 352.png @@の間違いは、開発者の生産性を妨げ、

未知の未知数につながります。

21.5より広く考える

最も重要なことに焦点を当てるという考え
ソフトウェア設計以外の他のドメインにも適用されます。
テクニカルライティングでも重要です：最高
ドキュメントを読みやすくする方法は、
最初のいくつかの重要な概念と構造
それらの周りのドキュメントの残りの部分。いつ
システムの詳細について話し合うと、結び付けるのに役立ちます
それらを全体的な概念に戻します。

重要なことに集中することも素晴らしい人生です
哲学：最も重要なことをいくつか特定する
あなたに、そしてあなたのエネルギーの多くを費やしてみてください
それらについて可能な限り。すべてをフリッターしないでください
あなたが考慮していないことにあなたの時間の
重要またはやりがいがあります。

「美味しさ」という言葉は能力を表しています
重要なものとそうでないものを区別するため
重要。味が良いことは重要な部分です
優れたソフトウェアデザイナーであることの

結論

この本は一つのことについてです：複雑さ。取引
複雑さを伴うことが最も重要な課題です
ソフトウェア設計で。それがシステムを作るものです

構築と保守が難しく、多くの場合、
それらも遅くなります。本の過程で私は
につながる根本的な原因を説明しようとしました
依存関係やあいまいさなどの複雑さ。私
識別に役立つ危険信号について話し合った
情報などの不必要な複雑さ
漏れ、不要なエラー状態、またはその名前
あまりにも一般的です。私はいくつかの一般的なものを提示しました
よりシンプルなソフトウェアを作成するために使用できるアイデア
深いクラスのために努力するなどのシステム
存在しないエラーを定義する一般的な、

インターフェースのドキュメントを
実装ドキュメント。そして最後に、私は
に必要な投資の考え方について話し合った

シンプルなデザインを作成します。d：\ work \ kindle \ phil \ 354.png@@これらすべての提案の欠点は、
彼らは初期の段階で余分な仕事を作成します
事業。さらに、あなたが考えることに慣れていないなら
デザインの問題については、あなたも遅くなります
優れた設計手法を学びながら、さらに多くのことを学びます。

あなたにとって重要なのは作ることだけなら
現在のコードはできるだけ早く機能し、その後
デザインを考えるのは大変な作業のように思えます
それはあなたの本当の目標の邪魔になっています。

一方、良いデザインが
あなたにとって重要な目標、そしてこの本のアイデア
プログラミングをもっと楽しくするはずです。デザインは
魅力的なパズル：特定の問題をどのように解決できるか
可能な限り単純な構造で解決しますか？これは
さまざまなアプローチを探求するのは楽しいです、そしてそれは素晴らしいです
両方ともシンプルな解決策を発見する気持ち
強力です。すっきりとしたシンプルでわかりやすいデザインは
美しいもの。

さらに、あなたが行う投資
良いデザインはすぐに報われるでしょう。あなたのモジュール
プロジェクトの開始時に慎重に定義すると、
後でそれらを再利用して時間を節約できます
以上。あなたが6つ書いた明確な文書
数ヶ月前に戻ったときに時間を節約できます
新しい機能を追加するためのコードに。あなたの時間
デザインスキルを磨くために費やした費用も支払われます：\ work \ Kindle \ phil \ 355.png @@それ自体：スキルと経験が増えるにつれて、あなたは
あなたがより良いデザインを生み出すことができることを見つけて
より迅速に。良いデザインはそれほど多くはかかりません
一度知ったら、手っ取り早いデザインよりも長い
どうやって。

優れたデザイナーになることの見返りは、あなたが
あなたの時間の大部分を
楽しいデザインフェーズ。貧しいデザイナーは費やします
彼らの時間のほとんどは、複雑でバグを追いかけています
もろいコード。あなたがあなたのデザインスキルを向上させるなら、
より高品質のソフトウェアをより多く生産するだけです
迅速に、しかしソフトウェア開発プロセスは
もっと楽しくなる.d：\ work \ Kindle \ phil \356.png@@インデックス

注：このインデックスのエントリは、逐語的に引き継がれます
このタイトルの印刷版から、
c
または任意の電子書籍のページネーションに対応する
読者。ただし、このインデックスのエントリ、およびその他
用語は、検索機能を使用して簡単に見つけることができます
あなたの電子書籍リーダーの。

抽象化、21,171
例外の集約、84

アジャイル開発、2,155

増幅の変化、7、99
クラスインターフェイスコメント、110
分類、26
クリーンコード、76,99
コーディングスタイル、143
認知的負荷、7、43、99
コメント

デザインツールとして、133

メリット、98d：\ work \ Kindle \ phil \ 357.png @@炭鉱のカナリア、133

の規則、102

複製、140

直感のために、107

精度のために、105

実装、116

インターフェイス、110

ニアコード、139

廃止、98

先延ばし、131

繰り返しコード、103

抽象化における役割、101

価値がない、98

コードの前に書く、131
複雑

の原因、9

定義、5

のインクリメンタルな性質、11、163

下に引っ張る、61、84

症状、7
構成、154
構成パラメーター、62
結合されたメソッド、74
一貫性、143、148

コンテキストオブジェクト、57d：\ work \ Kindle \ phil \ 358.png @@クロスモジュール設計の決定、117

デコレータ、55

ディープモジュール、23
デフォルト、36

依存関係、9

2回設計する、91,172
デザインパターン、144,158
designNotesファイル、118、141
デバイスドライバー、45

ディスクI/O、162

コーディネーター、53

正しいことをしなさい、36

エディターテキストクラスの例、41、56、62、172
イベント駆動型プログラミング、150
例

リンクリスト、25

テキストエディタの選択、48
例

構成パラメーター、62

エディターテキストクラス、41、56、62、91、172

エディター元に戻る、45

ファイルデータの損失、121

ファイル削除、81d：\ work \ Kindle \ phil \ 359.png @@ HTTPパラメータ、34

HTTP応答、36

HTTPサーバー、32、66

IndexLookup、112

Java I / O、26、55、67、173

Javaサブストリング、82

パラメータがありません、84

NFSサーバーのクラッシュ、83

存在しない選択、48

メモリ不足、88

RAMCloudバッファー、165

RAMCloudエラープロモーション、87

RAMCloudステータス、117

選択/カーソル、70

Tcl未設定、80

元に戻す、45

Unix I / O、23

Webサイトの色、7
例外、77

集計、84

マスキング、83

Facebook、17
誤った抽象化、22、43

フェンス、元に戻すため、47d：\ work \ Kindle \ phil \ 360.png @@ファイルデータ損失の例、121
ファイル削除の例、81
ファイル記述子、24

フラッシュストレージ、162

ガベージコレクション、162
汎用クラス、40、72
汎用コード、45、68
ジェネリックコンテナ、151
ゲッター、158
グローバル変数、57
言語に行く、127

の短い名前、127

グーグル、18

HTTPパラメータの例、34
HTTP応答の例、36
HTTPサーバーの例、32、66

ハンガリアン記法、127

実装、20、56
実装ドキュメント、116
実装の継承、154
インクリメンタル開発、2、40
IndexLookupの例、112

情報隠蔽、29d：\ work \ Kindle \ phil \ 361.png @@情報漏えい、30
継承、153
統合テスト、156
インターフェイス、20、56

フォーマルパーツ、20

非公式の部分、21
インターフェイスコメント

クラス、110

メソッド、110
インターフェイスドキュメント、110
インターフェイスの継承、153
不変、144、172

投資の考え方、15、40、129、138、146

Java I / Oの例、26、55、67、173
Javaサブストリングの例、82
リンクリストの例、25

長い方法、73

マーティン、ロバート、76,99

マスキング例外、83

メモリ割り当て、動的、162
メソッドインターフェイスコメント、110
マイクロベンチマーク、162

パラメータの例がありません、84d：\ work \ Kindle \ phil \ 362.png @@モジュラー設計、2、19

モジュール、20

名前
一貫性、126、143
ジェネリック、123
選び方、121,171
コードをより明確にする、148
正確、123
Goの短い名前、127
ネットワーク通信、162
NFSサーバーのクラッシュの例、83
存在しない選択例、48

不揮発性メモリ、162

オブジェクト指向プログラミング、153
あいまいさ、10、147
明らかなコード、9、147

メモリ不足の例、88

パーナス、デイビッド、29歳
パススルー方式、52
パススルー変数、57
パフォーマンス

のための設計、161,171

マイクロベンチマーク、162d：\ work \ Kindle \ phil \ 363.png @@プライベート変数、30
事業

テキストエディタ、70

RAMCloudバッファーの例、165
RAMCloudエラープロモーションの例、87

RAMCloudステータスの例、117

選択/カーソルの例、70
自己文書化コード、96
セッター、158

浅いモジュール、25

少人数クラス、26

特別な場合、48、167
専用コード、45、68
仕様、正式、21
戦略的プログラミング、14、137
スタイル、コーディング、143

サブストリングの例（Java）、82

システムテスト、156

戦術プログラミング、13、137、155
戦術竜巻、14

Tcl未設定の例、80

技術的負債、16

時間的分解、31d：\ work \ Kindle \ phil \ 364.png @@テスト駆動開発、157
テスト
統合、156
システム、156
ユニット、156
テキストエディタプロジェクト、70
テキストエディタの選択例、48

ブロックしてみてください、79

元に戻す例、45

ユニットテスト、156

Unix I / Oの例、23

未知の未知数、8、99、173

URLエンコード、34

VMware、18歳

ウォーターフォールモデル、2
Webサイトの色の例、7

ホワイトスペース、148d：\ work \ Kindle \ phil \365.png@@設計原則の概要

これが最も重要なソフトウェア設計です

この本で議論されている原則：

1.複雑さは段階的です：あなたはしなければなりません
小さなものを汗をかきます（11ページを参照）。

2.動作するコードでは不十分です（14ページを参照）。

3.継続的に少額の投資を行います
システム設計を改善します（15ページを参照）。

4. Modulesは深くする必要があります（23ページを参照）

5.インターフェースは、
最も一般的な使用法は可能な限り単純です
（27ページ参照）。

6.モジュールにとってより重要なのは
シンプルなインターフェースよりもシンプルなインターフェース
実装（61、74ページを参照）。

7.汎用モジュールはより深くなっています（p。
39）。

8.汎用と特殊を分離する-
目的コード（45、68ページを参照）d：\ work \ Kindle \ phil \ 366.png@@14。

15.

16.16。

。異なるレイヤーは異なる必要があります

抽象化（51ページを参照）。

。複雑さを引き下げます（p.61を参照）。

。存在しないエラーを定義します（p.81を参照）。

。 2回設計します（p.91を参照）。

。コメントは次のことを説明する必要があります

コードからは明らかではありません（p.101を参照）。
ソフトウェアは、簡単に設計する必要があります
読みやすさではなく、読みやすさ（p.151を参照）。
ソフトウェア開発の増分
機能ではなく、抽象化する必要があります（p。
156）。

重要なものとそうでないものを分離する
重要であり、
問題（p。171を参照）。d：\ work \ Kindle \ phil \367.png@@危険信号の概要

ここにいくつかの最も重要な危険信号があります
この本で議論されています。これらのいずれかの存在
システムの症状は、
システムの設計に関する問題：

浅いモジュール：クラスまたはメソッドのインターフェース
実装よりもそれほど単純ではありません（ppを参照）。
25,110）。

情報漏えい：設計上の決定が反映されます
複数のモジュールで（p.31を参照）。

時間的分解：コード構造

操作の順序に基づいています
情報隠蔽ではなく、実行されます（p.32を参照）。
露出オーバー：APIにより、発信者は注意を払う必要があります
一般的に使用される機能を使用するためにめったに使用されない機能
機能（p.36を参照）。

パススルーメソッド：メソッドはほとんど実行します
引数を別の引数に渡す以外は何もありません
同様の署名を持つメソッド（p.52を参照）。
繰り返し：重要なコードが繰り返されます
何度も何度も（p.68を参照）。d：\ work \ Kindle \ phil \ 368.png @@特殊-一般混合物：特殊用途のコードは
汎用コードから明確に分離されていない
（71ページ参照）。

結合されたメソッド：2つのメソッドには非常に多くの方法があります
理解するのが難しい依存関係
理解せずに1つの実装
もう一方の実装（p.75を参照）。

コメントリピートコード：のすべての情報
コメントはコードからすぐにわかります
コメントの横（p.104参照）。

実装ドキュメントが汚染する
インターフェイス：インターフェイスのコメントで説明されています
のユーザーが必要としない実装の詳細
文書化されているもの（p.114を参照）。

あいまいな名前：変数またはメソッドの名前は
あまりにも不正確なのであまり役に立たない
情報（p.123を参照）。

名前を選ぶのが難しい：思いつくのは難しい
エンティティの正確で直感的な名前（p.125を参照）。
説明するのは難しい：完全にするために、
変数またはメソッドのドキュメントは、
長さ。 （p.133参照）。

非自明なコード：の振る舞いまたは意味
コードの一部を簡単に理解することはできません。 （p。
150）.d：\ work \ Kindle \ phil \369.png@@作者について

ジョン・オースターハウトはボサック・ラーナー教授です
スタンフォード大学でコンピュータサイエンスを専攻。

彼の現在の研究は新しいソフトウェアに焦点を合わせています
データセンターアプリケーションができるようにレイヤーをスタックする
通信とストレージを活用する
マイクロ秒スケールのレイテンシーを備えたテクノロジー。
Ousterhoutの以前のポジションには14年が含まれます

彼は2つの会社を設立しました
（Scriptics and Electric Cloud）、前に14
U.C.でコンピュータサイエンスの教授を務めた年
バークレー。彼はTclスクリプトの作成者です
言語と彼の仕事でもよく知られています
分散オペレーティングシステムとストレージシステム。
Ousterhoutは、物理学のBS学位を取得しました。
イェール大学とコンピュータサイエンスの博士号
カーネギーメロン大学から。彼はメンバーです
全米技術アカデミーの
ACMを含む数々の賞を受賞
ソフトウェアシステム賞、ACMグレースマレー
ホッパー賞、全米科学財団：\ work \ Kindle \ phil \ 370.png @@大統領若手研究者賞、およびU.C.
Berkeley Distinguished Teaching Award.d：\ work \ Kindle \ phil \ 371.png @@

